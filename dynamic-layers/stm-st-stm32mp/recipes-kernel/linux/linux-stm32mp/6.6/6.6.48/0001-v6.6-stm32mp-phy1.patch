diff --git a/Documentation/devicetree/bindings/media/i2c/onsemi,ar0144.yaml b/Documentation/devicetree/bindings/media/i2c/onsemi,ar0144.yaml
new file mode 100644
index 000000000000..f6be7eab793c
--- /dev/null
+++ b/Documentation/devicetree/bindings/media/i2c/onsemi,ar0144.yaml
@@ -0,0 +1,388 @@
+# SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)
+%YAML 1.2
+---
+$id: http://devicetree.org/schemas/media/i2c/onsemi,ar0144.yaml#
+$schema: http://devicetree.org/meta-schemas/core.yaml#
+
+title: OnSemi CMOS Digital Image Sensor
+
+maintainers:
+  - Stefan Riedmueller <s.riedmueller@phytec.de>
+
+description: |
+  The OnSemiconductor AR0144 is a 1/4-inch 1.0 Mp CMOS digital image sensor
+  with an active-pixel array of 1280H x 800V. It features a 1 or 2 lane
+  MIPI-CSI2 interface or a parallel interface. It is programmable through a
+  simple two-wire serial interface.
+
+  The AR0234CS is a 1/2.6−inch 2Mp CMOS digital image sensor with an
+  active−pixel array of 1920H x 1200V. It features a 1, 2 or 4 lane MIPI-CSI2
+  interface as well as a parallel interface. It is programmable through a
+  simple two-wire serial interface.
+
+properties:
+  compatible:
+    enum:
+      - onsemi,ar0144
+      - onsemi,ar0144c
+      - onsemi,ar0144m
+      - onsemi,ar0234
+      - onsemi,ar0234c
+      - onsemi,ar0234m
+
+  reg:
+    description: I2C device address
+    maxItems: 1
+
+  clocks:
+    maxItems: 1
+
+  clock-names:
+    const: ext
+
+  reset-gpios:
+    maxItems: 1
+    description: Chip reset GPIO
+
+  onsemi,reset-delay-ms:
+    description: Reset delay in milliseconds applied after sensor reset.
+    $ref: /schemas/types.yaml#/definitions/uint32
+    default: 0
+
+  port:
+    $ref: /schemas/graph.yaml#/$defs/port-base
+    additionalProperties: false
+
+    properties:
+      endpoint:
+        $ref: /schemas/media/video-interfaces.yaml#
+        unevaluatedProperties: false
+
+        properties:
+          bus-type:
+            oneOf:
+              - const: 4 # MIPI CSI-2 D-PHY
+              - const: 5 # Parallel
+
+          onsemi,slew-rate-dat:
+            description: Data lines slew rate
+            $ref: /schemas/types.yaml#/definitions/uint32
+            minimum: 0
+            maximum: 7
+            default: 0
+
+          onsemi,slew-rate-clk:
+            description: Clock line slew rate
+            $ref: /schemas/types.yaml#/definitions/uint32
+            minimum: 0
+            maximum: 7
+            default: 0
+
+          onsemi,t-hs-prep:
+            description: MIPI Ths_prep value
+            $ref: /schemas/types.yaml#/definitions/uint32
+            minimum: 0
+            maximum: 15
+            default: 2
+
+          onsemi,t-hs-zero:
+            description: MIPI Ths_zero value
+            $ref: /schemas/types.yaml#/definitions/uint32
+            minimum: 0
+            maximum: 15
+            default: 6
+
+          onsemi,t-hs-trail:
+            description: MIPI Ths_trail value
+            $ref: /schemas/types.yaml#/definitions/uint32
+            minimum: 0
+            maximum: 15
+            default: 6
+
+          onsemi,t-clk-trail:
+            description: MIPI Tclk_trail value
+            $ref: /schemas/types.yaml#/definitions/uint32
+            minimum: 0
+            maximum: 15
+            default: 5
+
+          onsemi,t-clk-prep:
+            description: MIPI Tclk_prep value
+            $ref: /schemas/types.yaml#/definitions/uint32
+            minimum: 0
+            maximum: 15
+            default: 1
+
+          onsemi,t-hs-exit:
+            description: MIPI Ths_exit value
+            $ref: /schemas/types.yaml#/definitions/uint32
+            minimum: 0
+            maximum: 63
+            default: 4
+
+          onsemi,t-clk-zero:
+            description: MIPI Tclk_zero value
+            $ref: /schemas/types.yaml#/definitions/uint32
+            minimum: 0
+            maximum: 63
+            default: 14
+
+          onsemi,t-bgap:
+            description: MIPI Tbgap value
+            $ref: /schemas/types.yaml#/definitions/uint32
+            minimum: 0
+            maximum: 15
+            default: 2
+
+          onsemi,t-clk-pre:
+            description: MIPI Tclk_pre value
+            $ref: /schemas/types.yaml#/definitions/uint32
+            minimum: 0
+            maximum: 63
+            default: 1
+
+          onsemi,t-clk-post:
+            description: MIPI Tclk_post value
+            $ref: /schemas/types.yaml#/definitions/uint32
+            minimum: 0
+            maximum: 63
+            default: 7
+
+          onsemi,t-lpx:
+            description: MIPI Tlpx value
+            $ref: /schemas/types.yaml#/definitions/uint32
+            minimum: 0
+            maximum: 63
+            default: 2
+
+          onsemi,t-wakeup:
+            description: MIPI Twakeup value
+            $ref: /schemas/types.yaml#/definitions/uint32
+            minimum: 0
+            maximum: 127
+            default: 5
+
+          onsemi,t-init:
+            description: MIPI Tinit value
+            $ref: /schemas/types.yaml#/definitions/uint32
+            minimum: 0
+            maximum: 127
+            default: 4
+
+          onsemi,cont-tx-clk:
+            description: MIPI continuous TX clock
+            type: boolean
+
+          onsemi,heavy-lp-load:
+            description: MIPI set heavy LP load
+            type: boolean
+
+          link-frequencies:
+            description: |
+              Maximum link frequency of the interface.
+            maxItems: 1
+
+          data-lanes:
+            oneOf:
+              - items:
+                - const: 1
+                - const: 2
+              - items:
+                - const: 1
+
+          clock-lanes: true
+          clock-noncontinuous: true
+
+        allOf:
+          - if:
+              properties:
+                bus-type:
+                  const: 4 # MIPI CSI-2 D-PHY
+
+            then:
+              properties:
+                onsemi,slew-rate-dat: false
+                onsemi,slew-rate-clk: false
+
+              required:
+                - data-lanes
+                - clock-lanes
+
+          - if:
+              properties:
+                bus-type:
+                  const: 5 # Parallel
+
+            then:
+              properties:
+                data-lanes: false
+                clock-lanes: false
+                clock-noncontinuous: false
+                onsemi,t-hs-prep: false
+                onsemi,t-hs-zero: false
+                onsemi,t-hs-trail: false
+                onsemi,t-clk-trail: false
+                onsemi,t-clk-prep: false
+                onsemi,t-hs-exit: false
+                onsemi,t-clk-zero: false
+                onsemi,t-bgap: false
+                onsemi,t-clk-pre: false
+                onsemi,t-clk-post: false
+                onsemi,t-lpx: false
+                onsemi,t-wakeup: false
+                onsemi,t-init: false
+                onsemi,cont-tx-clk: false
+                onsemi,heavy-lp-load: false
+
+        required:
+          - bus-type
+          - link-frequencies
+
+
+allOf:
+  - if:
+      properties:
+        compatible:
+          enum:
+            - onsemi,ar0234
+            - onsemi,ar0234m
+            - onsemi,ar0234c
+        bus-type:
+          const: 4 # MIPI CSI-2 D-PHY
+
+    then:
+      - if:
+          properties:
+            port:
+              endpoint:
+                properties:
+                  bus-type:
+                    const: 4 # MIPI CSI-2 D-PHY
+
+        then:
+          properties:
+            port:
+              endpoint:
+                properties:
+                  data-lanes:
+                    oneOf:
+                      - items:
+                        - const: 1
+                        - const: 2
+                        - const: 3
+                        - const: 4
+                      - items:
+                        - const: 1
+                        - const: 2
+                      - items:
+                        - const: 1
+
+                  link-frequencies:
+                    maximum: 350000000
+
+                  onsemi,t-hs-prep:
+                    default: 5
+
+                  onsemi,t-hs-zero: false
+
+                  onsemi,t-hs-trail:
+                    maximum: 31
+                    default: 9
+
+                  onsemi,t-clk-trail:
+                    maximum: 31
+                    default: 8
+
+                  onsemi,t-clk-prep:
+                    default: 8
+
+                  onsemi,t-hs-exit:
+                    default: 10
+
+                  onsemi,t-clk-zero:
+                    default: 24
+
+                  onsemi,t-bgap:
+                    default: 9
+
+                  onsemi,t-clk-post:
+                    default: 11
+
+                  onsemi,t-lpx:
+                    default: 6
+
+                  onsemi,t-wakeup:
+                    default: 12
+
+                  onsemi,t-init:
+                    default: 10
+
+                  onsemi,cont-tx-clk:
+                    default: true
+
+        else:
+          properties:
+            port:
+              endpoint:
+                properties:
+                  link-frequencies:
+                    maximum: 90000000
+
+
+required:
+  - compatible
+  - reg
+  - clocks
+  - clock-names
+  - port
+
+additionalProperties: false
+
+examples:
+  - |
+    i2c0 {
+        #address-cells = <1>;
+        #size-cells = <0>;
+
+        camera@10 {
+            compatible = "onsemi,ar0144";
+            reg = <0x10>;
+            reset-gpios = <&gpio_sensor 0 0>;
+
+            clocks = <&sensor_clk>;
+            clock-names = "ext";
+
+            port {
+                camera_1: endpoint {
+                    bus-type = <4>; /* MIPI CSI-2 D-PHY */
+                    link-frequencies = /bits/ 64 <384000000>;
+                    data-lanes = <1 2>;
+                    clock-lanes = <0>;
+                    clock-noncontinuous = <1>;
+                };
+            };
+        };
+    };
+
+    i2c1 {
+        #address-cells = <1>;
+        #size-cells = <0>;
+
+        camera@10 {
+            compatible = "onsemi,ar0144";
+            reg = <0x10>;
+            reset-gpios = <&gpio_sensor 0 0>;
+
+            clocks = <&sensor_clk>;
+            clock-names = "ext";
+
+            port {
+                camera_1: endpoint {
+                    bus-type = <5>; /* Parallel */
+                    link-frequencies = /bits/ 64 <74250000>;
+                };
+            };
+        };
+    };
+
+...
diff --git a/arch/arm/boot/dts/st/overlays/phyboard-stm32mp1-dsi-lcd-mb1407.dts b/arch/arm/boot/dts/st/overlays/phyboard-stm32mp1-dsi-lcd-mb1407.dts
new file mode 100644
index 000000000000..7b498ace5470
--- /dev/null
+++ b/arch/arm/boot/dts/st/overlays/phyboard-stm32mp1-dsi-lcd-mb1407.dts
@@ -0,0 +1,90 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)
+/*
+ * Copyright (C) PHYTEC GmbH 2021 - All Rights Reserved
+ * Author: Christophe PARANT <c.parant@phytec.fr>.
+ * Devicetree overlay for ST MB1407 4" TFT 480x800 pixels DSI display
+ */
+
+/dts-v1/;
+/plugin/;
+
+#include <dt-bindings/gpio/gpio.h>
+
+/ {
+	compatible = "phytec,stm32mp1-pcm939";
+};
+
+&i2c1 {
+	#address-cells = <1>;
+	#size-cells = <0>;
+	status = "okay";
+
+	touchscreen@2a {
+		compatible = "focaltech,ft6236";
+		reg = <0x2a>;
+		interrupts = <8 2>;
+		interrupt-parent = <&gpioi>;
+		interrupt-controller;
+		touchscreen-size-x = <480>;
+		touchscreen-size-y = <800>;
+		panel = <&dsi_panel>;
+		status = "okay";
+	};
+
+	touchscreen@38 {
+		compatible = "focaltech,ft6336";
+		reg = <0x38>;
+		interrupts = <8 2>;
+		interrupt-parent = <&gpioi>;
+		interrupt-controller;
+		touchscreen-size-x = <480>;
+		touchscreen-size-y = <800>;
+		panel = <&dsi_panel>;
+		status = "okay";
+	};
+};
+
+&ltdc {
+	default-on;
+	status = "okay";
+
+	port {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		ltdc_ep0_out: endpoint@0 {
+			reg = <0>;
+			remote-endpoint = <&dsi_in>;
+		};
+	};
+};
+
+&dsi {
+	#address-cells = <1>;
+	#size-cells = <0>;
+	status = "okay";
+
+	dsi_panel:panel@0 {
+		compatible = "orisetech,otm8009a";
+		reg = <0>;
+		reset-gpios = <&gpiod 9 GPIO_ACTIVE_LOW>;
+		power-supply = <&v3v3>;
+		default-on;
+		status = "okay";
+
+		port {
+			panel_in: endpoint {
+				remote-endpoint = <&dsi_out>;
+			};
+		};
+	};
+};
+
+
+&dsi_in {
+	remote-endpoint = <&ltdc_ep0_out>;
+};
+
+&dsi_out {
+	remote-endpoint = <&panel_in>;
+};
diff --git a/arch/arm/boot/dts/st/overlays/phyboard-stm32mp1-dsi-rpi-official-display.dts b/arch/arm/boot/dts/st/overlays/phyboard-stm32mp1-dsi-rpi-official-display.dts
new file mode 100644
index 000000000000..20fcc55a6f6b
--- /dev/null
+++ b/arch/arm/boot/dts/st/overlays/phyboard-stm32mp1-dsi-rpi-official-display.dts
@@ -0,0 +1,68 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)
+/*
+ * Copyright (C) PHYTEC GmbH 2021 - All Rights Reserved
+ * Author: Christophe PARANT <c.parant@phytec.fr>.
+ * Devicetree overlay for Official Raspberry Pi Touch 7" Display
+ */
+
+/dts-v1/;
+/plugin/;
+
+/ {
+	compatible = "phytec,stm32mp1-pcm939";
+};
+
+&i2c1 {
+	#address-cells = <1>;
+	#size-cells = <0>;
+	status = "okay";
+
+	touchscreen@38 {
+		compatible = "sitronix,st1633";
+		reg = <0x38>;
+		interrupts = <2 2>;
+		interrupt-parent = <&gpiof>;
+		interrupt-controller;
+		status = "okay";
+	};
+
+	lcd@45 {
+		compatible = "raspberrypi,7inch-touchscreen-panel";
+		reg = <0x45>;
+		status = "okay";
+
+		port {
+			panel_in: endpoint {
+				remote-endpoint = <&dsi_out>;
+			};
+		};
+	};
+};
+
+&ltdc {
+	status = "okay";
+
+	port {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		ltdc_ep0_out: endpoint@0 {
+			reg = <0>;
+			remote-endpoint = <&dsi_in>;
+		};
+	};
+};
+
+&dsi {
+	#address-cells = <1>;
+	#size-cells = <0>;
+	status = "okay";
+};
+
+&dsi_in {
+	remote-endpoint = <&ltdc_ep0_out>;
+};
+
+&dsi_out {
+	remote-endpoint = <&panel_in>;
+};
diff --git a/arch/arm/boot/dts/st/overlays/phyboard-stm32mp1-motor-control-m4.dts b/arch/arm/boot/dts/st/overlays/phyboard-stm32mp1-motor-control-m4.dts
new file mode 100644
index 000000000000..f22ebfca0aa7
--- /dev/null
+++ b/arch/arm/boot/dts/st/overlays/phyboard-stm32mp1-motor-control-m4.dts
@@ -0,0 +1,187 @@
+/* SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause) */
+/*
+ * Copyright (C) PHYTEC GmbH 2021 - All Rights Reserved
+ * Author: Christophe PARANT <c.parant@phytec.fr>.
+ * Devicetree overlay for ST motor control connector - Cortex M4 example
+ */
+
+/dts-v1/;
+/plugin/;
+
+#include <dt-bindings/pinctrl/stm32-pinfunc.h>
+
+/ {
+	compatible = "phytec,stm32mp1-pcm939";
+};
+
+&usart3{
+	status = "disabled";
+};
+
+&adc {
+	status = "disabled";
+};
+
+&timers8 {
+	status = "disabled";
+};
+
+&timers3 {
+	status = "disabled";
+};
+
+
+&dma2 {
+	status = "disabled";
+};
+
+&dmamux1 {
+	dma-masters = <&dma1>;
+	dma-channels = <8>;
+};
+
+&m4_rproc{
+	m4_system_resources{
+		status = "okay";
+
+		button {
+			compatible = "rproc-srm-dev";
+			interrupt-parent = <&gpioa>;
+			interrupts = <14 2>;
+			interrupt-names = "irq";
+			status = "okay";
+		};
+
+		m4_led: m4_led {
+			compatible = "rproc-srm-dev";
+			pinctrl-names = "rproc_default", "rproc_sleep";
+			pinctrl-0 = <&leds_red_pins>;
+			pinctrl-1 = <&leds_red_sleep_pins>;
+			status = "okay";
+		};
+	};
+};
+
+
+&m4_dma2 {
+	status = "okay";
+};
+
+
+&vrefbuf {
+	status = "okay";
+};
+
+&m4_adc{
+	vdd-supply = <&vdd>;
+	vref-supply = <&vrefbuf>;
+
+	pinctrl-names = "rproc_default", "rproc_sleep";
+	pinctrl-0 = <&adc_pins>;
+	pinctrl-1 = <&adc_sleep_pins>;
+	status = "okay";
+};
+
+&m4_timers8{
+	pinctrl-names = "rproc_default", "rproc_sleep";
+	pinctrl-0 = <&tim8_pins &tim8_pwm_pins>;
+	pinctrl-1 = <&tim8_sleep_pins &tim8_pwm_sleep_pins>;
+	status = "okay";
+};
+
+&m4_timers3{
+	pinctrl-names = "rproc_default", "rproc_sleep";
+	pinctrl-0 = <&tim3_pins>;
+	pinctrl-1 = <&tim3_sleep_pins>;
+	status = "okay";
+};
+
+
+&m4_usart3 {
+	pinctrl-names = "rproc_default", "rproc_sleep";
+	pinctrl-0 = <&usart3_pins_b>;
+	pinctrl-1 = <&usart3_sleep_pins_b>;
+	pinctrl-2 = <&usart3_idle_pins_b>;
+	status = "okay";
+};
+
+
+&pinctrl {
+	adc_pins: adc-0 {
+		pins {
+			pinmux = <STM32_PINMUX('F', 12, ANALOG)>; /* ADC1_INP6 */
+		};
+	};
+
+	tim8_pins: tim8-0 {
+		pins {
+			pinmux = <STM32_PINMUX('C', 7, AF3)>, /* TIM8_CH2 */
+				 <STM32_PINMUX('I', 5, AF3)>, /* TIM8_CH1 */
+				 <STM32_PINMUX('I', 7, AF3)>; /* TIM8_CH3 */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <0>;
+		};
+	};
+
+	tim8_pwm_pins: tim8_pwm-0 {
+		pins {
+			pinmux = <STM32_PINMUX('G', 3, AF3)>; /* TIM8_BKIN2 */
+			bias-disable;
+			drive-open-drain;
+			slew-rate = <0>;
+		};
+	};
+
+	tim3_pins: tim3-0 {
+		pins {
+			pinmux = <STM32_PINMUX('A', 6, AF2)>; /* TIM3_CH1 */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <0>;
+		};
+	};
+
+	adc_sleep_pins: adc_sleep-0 {
+		pins {
+			pinmux = <STM32_PINMUX('F', 12, ANALOG)>; /* ADC1_INP6 */
+		};
+	};
+
+	tim8_sleep_pins: tim8_sleep-0 {
+		pins {
+			pinmux = <STM32_PINMUX('C', 7, ANALOG)>, /* TIM8_CH2 */
+				 <STM32_PINMUX('I', 5, ANALOG)>, /* TIM8_CH1 */
+				 <STM32_PINMUX('I', 7, ANALOG)>; /* TIM8_CH3 */
+		};
+	};
+
+	tim8_pwm_sleep_pins: tim8_pwm_sleep-0 {
+		pins {
+			pinmux = <STM32_PINMUX('G', 3, ANALOG)>; /* TIM8_BKIN2 */
+		};
+	};
+
+
+	tim3_sleep_pins: tim3_sleep-0 {
+		pins {
+			pinmux = <STM32_PINMUX('A', 6, ANALOG)>; /* TIM3_CH1 */
+		};
+	};
+
+	leds_red_pins: leds_red_test-0 {
+		pins {
+			pinmux = <STM32_PINMUX('A', 13, GPIO)>;
+			bias-pull-up;
+			drive-push-pull;
+			output-low;
+			slew-rate = <0>;
+		};
+	};
+
+	leds_red_sleep_pins: leds_red_sleep_test-0 {
+		pins {
+			pinmux = <STM32_PINMUX('A', 13, ANALOG)>;
+		};
+	};
+};
diff --git a/arch/arm/boot/dts/st/overlays/phyboard-stm32mp1-motor-control.dts b/arch/arm/boot/dts/st/overlays/phyboard-stm32mp1-motor-control.dts
new file mode 100644
index 000000000000..fd05a3aef407
--- /dev/null
+++ b/arch/arm/boot/dts/st/overlays/phyboard-stm32mp1-motor-control.dts
@@ -0,0 +1,211 @@
+/* SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause) */
+/*
+ * Copyright (C) PHYTEC GmbH 2021 - All Rights Reserved
+ * Author: Christophe PARANT <c.parant@phytec.fr>.
+ * Devicetree overlay for ST motor control connector - Cortex A7 example
+ */
+
+/dts-v1/;
+/plugin/;
+
+#include <dt-bindings/pinctrl/stm32-pinfunc.h>
+
+/ {
+	compatible = "phytec,stm32mp1-pcm939";
+};
+
+&vrefbuf {
+	status = "okay";
+};
+
+&adc {
+	pinctrl-names = "default";
+	pinctrl-0 = <&adc12_pins_mx>;
+	pinctrl-1 = <&adc12_sleep_pins_mx>;
+
+	vdd-supply = <&vdd>;
+	vdda-supply = <&vdd>;
+	vref-supply = <&vrefbuf>;
+	status = "okay";
+
+	adc1: adc@0 {
+		st,min-sample-time-nsecs = <5000>;
+		/* in6, in13, in15 */
+		st,adc-channels = <6 13 15>;
+		status = "okay";
+	};
+
+	adc2: adc@100 {
+		/* ANA0, ANA1, in2 */
+		st,adc-channels = <0 1 2>;
+		/* temperature sensor min sample time */
+		st,min-sample-time-nsecs = <10000>;
+		status = "okay";
+	};
+};
+
+
+&timers1{
+	status = "okay";
+
+	/* USER CODE BEGIN timers1 */
+	/* USER CODE END timers1 */
+
+	pwm1: pwm{
+		pinctrl-names = "default", "sleep";
+		pinctrl-0 = <&tim1_pwm_pins_mx>;
+		pinctrl-1 = <&tim1_pwm_sleep_pins_mx>;
+		status = "okay";
+
+		/* USER CODE BEGIN timers1_pwm */
+		/* USER CODE END timers1_pwm */
+	};
+};
+
+&timers3{
+	status = "okay";
+
+	/* USER CODE BEGIN timers3 */
+	/* USER CODE END timers3 */
+
+	pwm3: pwm{
+		pinctrl-names = "default", "sleep";
+		pinctrl-0 = <&tim3_pwm_pins_mx>;
+		pinctrl-1 = <&tim3_pwm_sleep_pins_mx>;
+		status = "okay";
+
+		/* USER CODE BEGIN timers3_pwm */
+		/* USER CODE END timers3_pwm */
+	};
+};
+
+&timers5{
+	status = "okay";
+
+	/* USER CODE BEGIN timers5 */
+	/* USER CODE END timers5 */
+
+	pwm{
+		pinctrl-names = "default", "sleep";
+		pinctrl-0 = <&tim5_pwm_pins_mx>;
+		pinctrl-1 = <&tim5_pwm_sleep_pins_mx>;
+		status = "okay";
+
+		/* USER CODE BEGIN timers5_pwm */
+		/* USER CODE END timers5_pwm */
+	};
+};
+
+&timers8{
+	status = "okay";
+
+	/* USER CODE BEGIN timers8 */
+	/* USER CODE END timers8 */
+
+	pwm8: pwm{
+		pinctrl-names = "default", "sleep";
+		pinctrl-0 = <&tim8_pwm_pins_mx>;
+		pinctrl-1 = <&tim8_pwm_sleep_pins_mx>;
+		status = "okay";
+
+		/* USER CODE BEGIN timers8_pwm */
+		/* USER CODE END timers8_pwm */
+	};
+};
+
+
+&pinctrl {
+	adc12_pins_mx: adc12_mx-0 {
+		pins {
+			pinmux = <STM32_PINMUX('A', 3, ANALOG)>, /* ADC1 in15 */
+				 <STM32_PINMUX('C', 3, ANALOG)>, /* ADC1 in13 */
+				 <STM32_PINMUX('F', 12, ANALOG)>, /* ADC1 in6 */
+				 <STM32_PINMUX('F', 13, ANALOG)>; /* ADC2 in2 */
+		};
+	};
+
+	adc12_sleep_pins_mx: adc12_sleep_mx-0 {
+		pins {
+			pinmux = <STM32_PINMUX('A', 3, ANALOG)>, /* ADC1 in15 */
+				 <STM32_PINMUX('C', 3, ANALOG)>, /* ADC1 in13 */
+				 <STM32_PINMUX('F', 12, ANALOG)>, /* ADC1 in6 */
+				 <STM32_PINMUX('F', 13, ANALOG)>; /* ADC2 in2 */
+		};
+	};
+
+	tim1_pwm_pins_mx: tim1_pwm_mx-0 {
+		pins {
+			pinmux = <STM32_PINMUX('E', 11, AF1)>, /* TIM1_CH2 */
+				 <STM32_PINMUX('E', 14, AF1)>; /* TIM1_CH4 */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <0>;
+		};
+	};
+
+	tim1_pwm_sleep_pins_mx: tim1_pwm_sleep_mx-0 {
+		pins {
+			pinmux = <STM32_PINMUX('E', 11, ANALOG)>, /* TIM1_CH2 */
+				 <STM32_PINMUX('E', 14, ANALOG)>; /* TIM1_CH4 */
+		};
+	};
+
+	tim3_pwm_pins_mx: tim3_pwm_mx-0 {
+		pins {
+			pinmux = <STM32_PINMUX('A', 6, AF2)>; /* TIM3_CH1 */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <0>;
+		};
+	};
+
+	tim3_pwm_sleep_pins_mx: tim3_pwm_sleep_mx-0 {
+		pins {
+			pinmux = <STM32_PINMUX('A', 6, ANALOG)>; /* TIM3_CH1 */
+		};
+	};
+
+	tim5_pwm_pins_mx: tim5_pwm_mx-0 {
+		pins {
+			pinmux = <STM32_PINMUX('H', 10, AF2)>, /* TIM5_CH1 */
+				 <STM32_PINMUX('H', 12, AF2)>, /* TIM5_CH3 */
+				 <STM32_PINMUX('I', 0, AF2)>; /* TIM5_CH4 */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <0>;
+		};
+	};
+
+	tim5_pwm_sleep_pins_mx: tim5_pwm_sleep_mx-0 {
+		pins {
+			pinmux = <STM32_PINMUX('H', 10, ANALOG)>, /* TIM5_CH1 */
+				 <STM32_PINMUX('H', 12, ANALOG)>, /* TIM5_CH3 */
+				 <STM32_PINMUX('I', 0, ANALOG)>; /* TIM5_CH4 */
+		};
+	};
+
+	tim8_pwm_pins_mx: tim8_pwm_mx-0 {
+		pins {
+			pinmux = <STM32_PINMUX('A', 5, AF3)>, /* TIM8_CH1N */
+				 <STM32_PINMUX('B', 0, AF3)>, /* TIM8_CH2N */
+				 <STM32_PINMUX('C', 7, AF3)>, /* TIM8_CH2 */
+				 <STM32_PINMUX('H', 15, AF3)>, /* TIM8_CH3N */
+				 <STM32_PINMUX('I', 5, AF3)>, /* TIM8_CH1 */
+				 <STM32_PINMUX('I', 7, AF3)>; /* TIM8_CH3 */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <0>;
+		};
+	};
+
+	tim8_pwm_sleep_pins_mx: tim8_pwm_sleep_mx-0 {
+		pins {
+			pinmux = <STM32_PINMUX('A', 5, ANALOG)>, /* TIM8_CH1N */
+				 <STM32_PINMUX('B', 0, ANALOG)>, /* TIM8_CH2N */
+				 <STM32_PINMUX('C', 7, ANALOG)>, /* TIM8_CH2 */
+				 <STM32_PINMUX('H', 15, ANALOG)>, /* TIM8_CH3N */
+				 <STM32_PINMUX('I', 5, ANALOG)>, /* TIM8_CH1 */
+				 <STM32_PINMUX('I', 7, ANALOG)>; /* TIM8_CH3 */
+		};
+	};
+};
diff --git a/arch/arm/boot/dts/st/overlays/phyboard-stm32mp1-pcm939-phycam-vm016-10bits.dts b/arch/arm/boot/dts/st/overlays/phyboard-stm32mp1-pcm939-phycam-vm016-10bits.dts
new file mode 100644
index 000000000000..83316e6a355c
--- /dev/null
+++ b/arch/arm/boot/dts/st/overlays/phyboard-stm32mp1-pcm939-phycam-vm016-10bits.dts
@@ -0,0 +1,60 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)
+/*
+ * Copyright (C) PHYTEC Messtechnik GmbH 2022 - All Rights Reserved
+ * Author: Christophe Parant <c.parant@phytec.fr>.
+ */
+
+/dts-v1/;
+/plugin/;
+
+/ {
+	compatible = "phytec,stm32mp1-pcm939";
+};
+
+
+&clk_ext_camera {
+	status = "okay";
+};
+
+&i2c1 {
+	#address-cells = <1>;
+	#size-cells = <0>;
+	status = "okay";
+
+	vm016: camera@10 {
+		#address-cells = <0x1>;
+		#size-cells = <0x0>;
+
+		compatible = "onsemi,ar0144";
+		reg = <0x10>;
+		clock-names = "ext";
+		clocks = <&clk_ext_camera>;
+
+		port@0 {
+			reg = <0>;
+
+			vm016_ep0: endpoint {
+				remote-endpoint = <&dcmi_ep0>;
+				bus-type = <5>; /* Parallel */
+				bus-width = <10>;
+				data-shift = <2>;
+				link-frequencies = /bits/ 64 <42000000>;
+			};
+		};
+	};
+};
+
+&dcmi {
+	status = "okay";
+
+	port {
+		dcmi_ep0: endpoint {
+			remote-endpoint = <&vm016_ep0>;
+			bus-width = <10>;
+			hsync-active = <0>;
+			vsync-active = <0>;
+			pclk-max-frequency = <77000000>;
+			pclk-sample = <1>;
+		};
+	};
+};
diff --git a/arch/arm/boot/dts/st/overlays/phyboard-stm32mp1-pcm939-phycam-vm016-8bits.dts b/arch/arm/boot/dts/st/overlays/phyboard-stm32mp1-pcm939-phycam-vm016-8bits.dts
new file mode 100644
index 000000000000..b57d33369c6b
--- /dev/null
+++ b/arch/arm/boot/dts/st/overlays/phyboard-stm32mp1-pcm939-phycam-vm016-8bits.dts
@@ -0,0 +1,60 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)
+/*
+ * Copyright (C) PHYTEC Messtechnik GmbH 2022 - All Rights Reserved
+ * Author: Christophe Parant <c.parant@phytec.fr>.
+ */
+
+/dts-v1/;
+/plugin/;
+
+/ {
+	compatible = "phytec,stm32mp1-pcm939";
+};
+
+
+&clk_ext_camera {
+	status = "okay";
+};
+
+&i2c1 {
+	#address-cells = <1>;
+	#size-cells = <0>;
+	status = "okay";
+
+	vm016: camera@10 {
+		#address-cells = <0x1>;
+		#size-cells = <0x0>;
+
+		compatible = "onsemi,ar0144";
+		reg = <0x10>;
+		clock-names = "ext";
+		clocks = <&clk_ext_camera>;
+
+		port@0 {
+			reg = <0>;
+
+			vm016_ep0: endpoint {
+				remote-endpoint = <&dcmi_ep0>;
+				bus-type = <5>; /* Parallel */
+				bus-width = <8>;
+				data-shift = <2>;
+				link-frequencies = /bits/ 64 <74250000>;
+			};
+		};
+	};
+};
+
+&dcmi {
+	status = "okay";
+
+	port {
+		dcmi_ep0: endpoint {
+			remote-endpoint = <&vm016_ep0>;
+			bus-width = <8>;
+			hsync-active = <0>;
+			vsync-active = <0>;
+			pclk-max-frequency = <77000000>;
+			pclk-sample = <1>;
+		};
+	};
+};
diff --git a/arch/arm/boot/dts/st/overlays/phyboard-stm32mp1-pcm939l-phycam-vm016-8bits.dts b/arch/arm/boot/dts/st/overlays/phyboard-stm32mp1-pcm939l-phycam-vm016-8bits.dts
new file mode 100644
index 000000000000..27042bdb6522
--- /dev/null
+++ b/arch/arm/boot/dts/st/overlays/phyboard-stm32mp1-pcm939l-phycam-vm016-8bits.dts
@@ -0,0 +1,60 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)
+/*
+ * Copyright (C) PHYTEC Messtechnik GmbH 2022 - All Rights Reserved
+ * Author: Christophe Parant <c.parant@phytec.fr>.
+ */
+
+/dts-v1/;
+/plugin/;
+
+/ {
+	compatible = "phytec,stm32mp1-pcm939";
+};
+
+
+&clk_ext_camera {
+	status = "okay";
+};
+
+&i2c1 {
+	#address-cells = <1>;
+	#size-cells = <0>;
+	status = "okay";
+
+	vm016: camera@10 {
+		#address-cells = <0x1>;
+		#size-cells = <0x0>;
+
+		compatible = "onsemi,ar0144";
+		reg = <0x10>;
+		clock-names = "ext";
+		clocks = <&clk_ext_camera>;
+
+		port@0 {
+			reg = <0>;
+
+			vm016_ep0: endpoint {
+				remote-endpoint = <&dcmi_ep0>;
+				bus-type = <5>; /* Parallel */
+				bus-width = <8>;
+				data-shift = <4>;
+				link-frequencies = /bits/ 64 <74250000>;
+			};
+		};
+	};
+};
+
+&dcmi {
+	status = "okay";
+
+	port {
+		dcmi_ep0: endpoint {
+			remote-endpoint = <&vm016_ep0>;
+			bus-width = <8>;
+			hsync-active = <0>;
+			vsync-active = <0>;
+			pclk-max-frequency = <77000000>;
+			pclk-sample = <1>;
+		};
+	};
+};
diff --git a/arch/arm/boot/dts/st/overlays/phyboard-stm32mp1-peb-av01-hdmi.dts b/arch/arm/boot/dts/st/overlays/phyboard-stm32mp1-peb-av01-hdmi.dts
new file mode 100644
index 000000000000..cea7e6f13f56
--- /dev/null
+++ b/arch/arm/boot/dts/st/overlays/phyboard-stm32mp1-peb-av01-hdmi.dts
@@ -0,0 +1,74 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)
+/*
+ * Copyright (C) PHYTEC GmbH 2021 - All Rights Reserved
+ * Author: Christophe PARANT <c.parant@phytec.fr>.
+ * Devicetree overlay for PEB-AV-01 expansion (HDMI interface)
+ */
+
+/dts-v1/;
+/plugin/;
+
+#include <dt-bindings/gpio/gpio.h>
+
+/ {
+	compatible = "phytec,stm32mp1-pcm939";
+
+	fragment@0 {
+		target-path = "/";
+		__overlay__ {
+			reg_hdmi_en: hdmi_en {
+				compatible = "regulator-fixed";
+				regulator-name = "hdmi_en";
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <1800000>;
+				gpio = <&gpiod 9 GPIO_ACTIVE_HIGH>;
+				startup-delay-us = <100>;
+				enable-active-high;
+				regulator-always-on;
+			};
+		};
+	};
+
+	fragment@1 {
+		target = <&i2c1>;
+		__overlay__ {
+			#address-cells = <1>;
+			#size-cells = <0>;
+			status = "okay";
+
+			tda19988@70 {
+				compatible = "nxp,tda998x";
+				pinctrl-names = "default", "sleep";
+				pinctrl-0 = <&ltdc_pins_a>;
+				pinctrl-1 = <&ltdc_pins_sleep_a>;
+				reg = <0x70>;
+				status = "okay";
+
+				ports {
+					port@0 {
+						hdmi_in: endpoint@0 {
+							remote-endpoint = <&ltdc_ep0_out>;
+						};
+					};
+				};
+			};
+		};
+	};
+
+	fragment@2 {
+		target = <&ltdc>;
+		__overlay__ {
+			status = "okay";
+
+			port {
+				#address-cells = <1>;
+				#size-cells = <0>;
+
+				ltdc_ep0_out: endpoint@0 {
+					reg = <0>;
+					remote-endpoint = <&hdmi_in>;
+				};
+			};
+		};
+	};
+};
diff --git a/arch/arm/boot/dts/st/overlays/phyboard-stm32mp1-peb-av02-lcd.dts b/arch/arm/boot/dts/st/overlays/phyboard-stm32mp1-peb-av02-lcd.dts
new file mode 100644
index 000000000000..4f1ac570e19b
--- /dev/null
+++ b/arch/arm/boot/dts/st/overlays/phyboard-stm32mp1-peb-av02-lcd.dts
@@ -0,0 +1,113 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)
+/*
+ * Copyright (C) PHYTEC GmbH 2021 - All Rights Reserved
+ * Author: Christophe PARANT <c.parant@phytec.fr>.
+ * Devicetree overlay for PEB-AV-02 expansion (Capacitive 7" EDT Display)
+ */
+
+/dts-v1/;
+/plugin/;
+
+#include <dt-bindings/gpio/gpio.h>
+
+/ {
+	compatible = "phytec,stm32mp1-pcm939";
+
+	fragment@0 {
+		target-path = "/";
+		__overlay__ {
+			panel_rgb: panel {
+				compatible = "edt,etm0700g0edh6";
+				status = "okay";
+				backlight = <&panel_backlight>;
+				enable-gpios = <&gpioa 4 GPIO_ACTIVE_HIGH>;
+
+				port {
+					panel_in_rgb: endpoint {
+						remote-endpoint = <&ltdc_ep0_out>;
+					};
+				};
+			};
+
+			panel_backlight: panel-backlight {
+				compatible = "pwm-backlight";
+				status = "okay";
+				pwms = <&pwm_5 3 100000>;
+				power-supply = <&v3v3>;
+				brightness-levels = <0 4 8 16 32 64 128 255>;
+				default-brightness-level = <6>;
+			};
+		};
+	};
+
+	fragment@1 {
+		target = <&timers5>;
+		__overlay__ {
+			status = "okay";
+			/delete-property/dmas;
+			/delete-property/dma-names;
+
+			pwm_5: pwm {
+				#pwm-cells = <2>;
+				pinctrl-0 = <&pwm5_pins_a>;
+				pinctrl-1 = <&pwm5_sleep_pins_a>;
+				pinctrl-names = "default", "sleep";
+				status = "okay";
+			};
+
+			timer@4 {
+				status = "disabled";
+			};
+		};
+	};
+
+	fragment@2 {
+		target = <&ltdc>;
+		__overlay__ {
+			status = "okay";
+
+			pinctrl-names = "default", "sleep";
+			pinctrl-0 = <&ltdc_pins_a>;
+			pinctrl-1 = <&ltdc_pins_sleep_a>;
+
+			port {
+				#address-cells = <1>;
+				#size-cells = <0>;
+
+				ltdc_ep0_out: endpoint@0 {
+					reg = <0>;
+					remote-endpoint = <&panel_in_rgb>;
+				};
+			};
+		};
+	};
+
+	fragment@3 {
+		target = <&i2c1>;
+		__overlay__ {
+			#address-cells = <1>;
+			#size-cells = <0>;
+			status = "okay";
+
+			edt_ts: touchscreen@38 {
+				compatible = "edt,edt-ft5406", "edt,edt-ft5x06";
+				reg = <0x38>;
+				interrupts = <8 2>;
+				interrupt-parent = <&gpioi>;
+				interrupt-controller;
+				reset-gpios = <&gpiod 9 1>;
+				status = "okay";
+			};
+
+			ili_ts: touchscreen@41 {
+				compatible = "ilitek,ili2130";
+				reg = <0x41>;
+				interrupts = <8 2>;
+				interrupt-parent = <&gpioi>;
+				interrupt-controller;
+				reset-gpios = <&gpiod 9 1>;
+				status = "okay";
+			};
+		};
+	};
+};
diff --git a/arch/arm/boot/dts/st/overlays/phyboard-stm32mp1-peb-wlbt-05-bluetooth-usart1.dts b/arch/arm/boot/dts/st/overlays/phyboard-stm32mp1-peb-wlbt-05-bluetooth-usart1.dts
new file mode 100644
index 000000000000..59f1aabcace3
--- /dev/null
+++ b/arch/arm/boot/dts/st/overlays/phyboard-stm32mp1-peb-wlbt-05-bluetooth-usart1.dts
@@ -0,0 +1,32 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)
+/*
+ * Copyright (C) PHYTEC GmbH 2021 - All Rights Reserved
+ * Author: Christophe PARANT <c.parant@phytec.fr>.
+ * Devicetree overlay for PEB-WLBT-05 expansion - Bluetooth function using usart1
+ */
+
+/dts-v1/;
+/plugin/;
+
+#include <dt-bindings/gpio/gpio.h>
+
+/ {
+	compatible = "phytec,stm32mp1-pcm939";
+};
+
+&gpio_keys {
+	enter {
+		status = "disabled"; /* disable PA14 (key enter) as input event */
+	};
+};
+
+
+&usart1 {
+	status = "okay";
+	uart-has-rtscts;
+	bluetooth {
+		shutdown-gpios = <&gpioa 14 (GPIO_ACTIVE_HIGH|GPIO_OPEN_DRAIN)>;
+		compatible = "brcm,bcm43438-bt";
+		max-speed = <3000000>;
+	};
+};
diff --git a/arch/arm/boot/dts/st/overlays/phyboard-stm32mp1-peb-wlbt-05-bluetooth-usart3.dts b/arch/arm/boot/dts/st/overlays/phyboard-stm32mp1-peb-wlbt-05-bluetooth-usart3.dts
new file mode 100644
index 000000000000..2793165bdcd0
--- /dev/null
+++ b/arch/arm/boot/dts/st/overlays/phyboard-stm32mp1-peb-wlbt-05-bluetooth-usart3.dts
@@ -0,0 +1,42 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)
+/*
+ * Copyright (C) PHYTEC GmbH 2021 - All Rights Reserved
+ * Author: Christophe PARANT <c.parant@phytec.fr>.
+ * Devicetree overlay for PEB-WLBT-05 module - Bluetooth function using usart3
+ */
+
+/dts-v1/;
+/plugin/;
+
+/ {
+	compatible = "phytec,stm32mp1-pcm939";
+};
+
+#include <dt-bindings/gpio/gpio.h>
+
+&gpio_keys {
+	enter {
+		status = "disabled"; /* disable PA14 (key enter) as input event */
+	};
+};
+
+&m_can2 {
+	status = "disabled"; /* disable CAN2 (TX pin used as USART3_CTS for bluetooth) */
+};
+
+&usart3 {
+	status = "okay";
+	uart-has-rtscts;
+
+	/* redefine usart3 pinctrl with additional rts/cts pins */
+	pinctrl-names = "default", "sleep", "idle";
+	pinctrl-0 = <&usart3_pins_a &usart3_pins_b>;
+	pinctrl-1 = <&usart3_sleep_pins_a &usart3_sleep_pins_b>;
+	pinctrl-2 = <&usart3_idle_pins_a &usart3_idle_pins_b>;
+
+	bluetooth {
+		shutdown-gpios = <&gpioa 14 (GPIO_ACTIVE_HIGH|GPIO_OPEN_DRAIN)>;
+		compatible = "brcm,bcm43438-bt";
+		max-speed = <3000000>;
+	};
+};
diff --git a/arch/arm/boot/dts/st/overlays/phyboard-stm32mp1-peb-wlbt-05-wlan.dts b/arch/arm/boot/dts/st/overlays/phyboard-stm32mp1-peb-wlbt-05-wlan.dts
new file mode 100644
index 000000000000..7de663961d56
--- /dev/null
+++ b/arch/arm/boot/dts/st/overlays/phyboard-stm32mp1-peb-wlbt-05-wlan.dts
@@ -0,0 +1,60 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)
+/*
+ * Copyright (C) PHYTEC GmbH 2021 - All Rights Reserved
+ * Author: Christophe PARANT <c.parant@phytec.fr>.
+ * Devicetree overlay for PEB-WLBT-05 expansion - WLAN function
+ */
+
+/dts-v1/;
+/plugin/;
+
+#include <dt-bindings/gpio/gpio.h>
+
+/ {
+	compatible = "phytec,stm32mp1-pcm939";
+
+	fragment@0 {
+		target-path = "/";
+		__overlay__ {
+			reg_wlan_en: wlan_en {
+				compatible = "regulator-fixed";
+				regulator-name = "wlan_en";
+				regulator-min-microvolt = <3300000>;
+				regulator-max-microvolt = <3300000>;
+				gpio = <&gpioa 13 (GPIO_ACTIVE_HIGH|GPIO_OPEN_DRAIN)>;
+				enable-active-high;
+				regulator-always-on;
+			};
+		};
+	};
+
+	fragment@1 {
+		target = <&gpio_keys>;
+		__overlay__ {
+			home {
+				status = "disabled"; /* disable PA13 (key home) as input event */
+			};
+		};
+	};
+
+	fragment@2 {
+		target = <&sdmmc3>;
+		__overlay__ {
+			status = "okay";
+			arm,primecell-periphid = <0x10153180>;
+			pinctrl-names = "default", "opendrain", "sleep";
+			pinctrl-0 = <&sdmmc3_b4_pins_a>;
+			pinctrl-1 = <&sdmmc3_b4_od_pins_a>;
+			pinctrl-2 = <&sdmmc3_b4_sleep_pins_a>;
+			non-removable;
+			st,neg-edge;
+			bus-width = <4>;
+			max-frequency = <10000000>;
+			vmmc-supply = <&v3v3>;
+
+			brcmf: bcrmf@1 {
+				compatible = "brcm,bcm4329-fmac";
+			};
+		};
+	};
+};
diff --git a/arch/arm/boot/dts/st/overlays/phyboard-stm32mp1-pi-hat-extension.dts b/arch/arm/boot/dts/st/overlays/phyboard-stm32mp1-pi-hat-extension.dts
new file mode 100644
index 000000000000..7305ea41b7fa
--- /dev/null
+++ b/arch/arm/boot/dts/st/overlays/phyboard-stm32mp1-pi-hat-extension.dts
@@ -0,0 +1,38 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)
+/*
+ * Copyright (C) PHYTEC GmbH 2021 - All Rights Reserved
+ * Author: Christophe PARANT <c.parant@phytec.fr>.
+ * Device tree overlay for Raspberry PI HAT pinout configuration example
+ */
+
+/dts-v1/;
+/plugin/;
+
+/ {
+	compatible = "phytec,stm32mp1-pcm939";
+};
+
+&spi1 {
+	status = "okay";
+};
+
+&sdmmc3 {
+	pinctrl-names = "default", "opendrain", "sleep";
+	pinctrl-0 = <&sdmmc3_b4_pins_a>;
+	pinctrl-1 = <&sdmmc3_b4_od_pins_a>;
+	pinctrl-2 = <&sdmmc3_b4_sleep_pins_a>;
+	st,neg-edge;
+	bus-width = <4>;
+	max-frequency = <10000000>;
+	vmmc-supply = <&v3v3>;
+	status = "disabled";
+};
+
+&i2c1 {
+	status = "okay";
+};
+
+&usart1 {
+	status = "okay";
+};
+
diff --git a/arch/arm/boot/dts/st/overlays/phyboard-stm32mp1-pi-hat-redbear.dts b/arch/arm/boot/dts/st/overlays/phyboard-stm32mp1-pi-hat-redbear.dts
new file mode 100644
index 000000000000..a3cee7993e79
--- /dev/null
+++ b/arch/arm/boot/dts/st/overlays/phyboard-stm32mp1-pi-hat-redbear.dts
@@ -0,0 +1,87 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)
+/*
+ * Copyright (C) PHYTEC GmbH 2021 - All Rights Reserved
+ * Author: Christophe PARANT <c.parant@phytec.fr>.
+ * Devicetree overlay for RedBear IoT pHAT Wifi Bluetooth module
+ */
+
+/dts-v1/;
+/plugin/;
+
+#include <dt-bindings/gpio/gpio.h>
+
+/ {
+	compatible = "phytec,stm32mp1-pcm939";
+
+	fragment@0 {
+		target-path = "/";
+		__overlay__ {
+			gpio_led_wl: leds {
+				compatible = "gpio-leds";
+				status = "okay";
+
+				wl_reg {
+					gpios = <&gpioe 4 0>;
+					linux,default-trigger = "default-on";
+				};
+			};
+		};
+	};
+
+	fragment@1 {
+		target = <&spi1>;
+		__overlay__ {
+			status = "okay";
+			cs-gpios = <&gpioz 3 0>;
+			spi@0 {
+				compatible = "linux,spidev";
+				spi-max-frequency = <10000000>;
+				reg = <0>;
+			};
+		};
+	};
+
+	fragment@2 {
+		target = <&sdmmc3>;
+		__overlay__ {
+			status = "okay";
+			arm,primecell-periphid = <0x10153180>;
+			pinctrl-names = "default", "opendrain", "sleep";
+			pinctrl-0 = <&sdmmc3_b4_pins_a>;
+			pinctrl-1 = <&sdmmc3_b4_od_pins_a>;
+			pinctrl-2 = <&sdmmc3_b4_sleep_pins_a>;
+			non-removable;
+			st,neg-edge;
+			bus-width = <4>;
+			max-frequency = <10000000>;
+			vmmc-supply = <&v3v3>;
+
+			brcmf: bcrmf@1 {
+				reg = <1>;
+				compatible = "brcm,bcm4329-fmac";
+			};
+		};
+	};
+
+	fragment@3 {
+		target = <&i2c1>;
+		__overlay__ {
+			status = "okay";
+		};
+	};
+
+	fragment@4 {
+		target = <&usart1>;
+		__overlay__ {
+			status = "okay";
+			uart-has-rtscts;
+
+			bluetooth {
+				shutdown-gpios = <&gpiog 2 GPIO_ACTIVE_HIGH>;
+				compatible = "brcm,bcm43438-bt";
+				max-speed = <3000000>;
+			};
+		};
+	};
+
+};
diff --git a/arch/arm/boot/dts/st/overlays/phyboard-stm32mp1-rs485.dts b/arch/arm/boot/dts/st/overlays/phyboard-stm32mp1-rs485.dts
new file mode 100644
index 000000000000..a64f21bf53eb
--- /dev/null
+++ b/arch/arm/boot/dts/st/overlays/phyboard-stm32mp1-rs485.dts
@@ -0,0 +1,21 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)
+/*
+ * Copyright (C) PHYTEC GmbH 2021 - All Rights Reserved
+ * Author: Christophe PARANT <c.parant@phytec.fr>.
+ * Devicetree overlay for RS485 configuration on phyBOARD-Sargas
+ */
+
+/dts-v1/;
+/plugin/;
+
+#include <dt-bindings/gpio/gpio.h>
+
+/ {
+	compatible = "phytec,stm32mp1-pcm939";
+};
+
+
+&usart1 {
+	linux,rs485-enabled-at-boot-time;
+	status = "okay";
+};
diff --git a/arch/arm/boot/dts/st/overlays/phyboard-stm32mp1-uno-r3-extension.dts b/arch/arm/boot/dts/st/overlays/phyboard-stm32mp1-uno-r3-extension.dts
new file mode 100644
index 000000000000..e70fd668cff4
--- /dev/null
+++ b/arch/arm/boot/dts/st/overlays/phyboard-stm32mp1-uno-r3-extension.dts
@@ -0,0 +1,73 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)
+/*
+ * Copyright (C) PHYTEC GmbH 2021 - All Rights Reserved
+ * Author: Christophe PARANT <c.parant@phytec.fr>.
+ * Devicetree overlay for Arduino Uno R3 connector
+ */
+
+/dts-v1/;
+/plugin/;
+
+#include <dt-bindings/pinctrl/stm32-pinfunc.h>
+
+/ {
+	compatible = "phytec,stm32mp1-pcm939";
+};
+
+&timers4{
+	status = "okay";
+
+	pwm4: pwm{
+		pinctrl-names = "default", "sleep";
+		pinctrl-0 = <&tim4_pwm_pins_mx>;
+		pinctrl-1 = <&tim4_pwm_sleep_pins_mx>;
+		status = "okay";
+	};
+};
+
+&timers15{
+	status = "okay";
+
+	pwm15: pwm{
+		pinctrl-names = "default", "sleep";
+		pinctrl-0 = <&tim15_pwm_pins_mx>;
+		pinctrl-1 = <&tim15_pwm_sleep_pins_mx>;
+		status = "okay";
+	};
+};
+
+/* Other Timers and ADCs for the Arduino Shield connector can be settled using "phyboard-stm32mp1-motor-control.dts" overlay */
+
+
+&pinctrl {
+
+	tim4_pwm_pins_mx: tim4_pwm_mx-0 {
+		pins {
+			pinmux = <STM32_PINMUX('B', 7, AF2)>; /* TIM4_CH2 */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <0>;
+		};
+	};
+
+	tim4_pwm_sleep_pins_mx: tim4_pwm_sleep_mx-0 {
+		pins {
+			pinmux = <STM32_PINMUX('B', 7, ANALOG)>; /* TIM4_CH2 */
+		};
+	};
+
+	tim15_pwm_pins_mx: tim15_pwm_mx-0 {
+		pins {
+			pinmux = <STM32_PINMUX('E', 5, AF4)>; /* TIM15_CH1 */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <0>;
+		};
+	};
+
+	tim15_pwm_sleep_pins_mx: tim15_pwm_sleep_mx-0 {
+		pins {
+			pinmux = <STM32_PINMUX('E', 5, ANALOG)>; /* TIM15_CH1 */
+		};
+	};
+};
diff --git a/arch/arm/boot/dts/st/overlays/stm32mp135x-phyboard-segin-peb-av-01-hdmi.dts b/arch/arm/boot/dts/st/overlays/stm32mp135x-phyboard-segin-peb-av-01-hdmi.dts
new file mode 100644
index 000000000000..28b2ca599c79
--- /dev/null
+++ b/arch/arm/boot/dts/st/overlays/stm32mp135x-phyboard-segin-peb-av-01-hdmi.dts
@@ -0,0 +1,73 @@
+// SPDX-License-Identifier: GPL-2.0+ 
+/*
+ * Copyright (C) 2023 PHYTEC Messtechnik GmbH
+ * Author: Christophe PARANT <c.parant@phytec.fr>
+ */
+
+/dts-v1/;
+/plugin/;
+
+#include <dt-bindings/gpio/gpio.h>
+
+/ {
+	compatible = "phytec,stm32mp13-pbacd-10";
+
+	fragment@0 {
+		target-path = "/";
+		__overlay__ {
+			reg_hdmi_en: hdmi_en {
+				compatible = "regulator-fixed";
+				regulator-name = "hdmi_en";
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <1800000>;
+				gpio = <&gpioi 0 GPIO_ACTIVE_HIGH>;
+				startup-delay-us = <100>;
+				enable-active-high;
+				regulator-always-on;
+			};
+		};
+	};
+
+	fragment@1 {
+		target = <&i2c5>;
+		__overlay__ {
+			#address-cells = <1>;
+			#size-cells = <0>;
+			status = "okay";
+
+			tda19988@70 {
+				compatible = "nxp,tda998x";
+				pinctrl-names = "default", "sleep";
+				pinctrl-0 = <&ltdc_pins_mx>;
+				pinctrl-1 = <&ltdc_sleep_pins_mx>;
+				reg = <0x70>;
+				status = "okay";
+
+				ports {
+					port@0 {
+						hdmi_in: endpoint@0 {
+							remote-endpoint = <&ltdc_ep0_out>;
+						};
+					};
+				};
+			};
+		};
+	};
+
+	fragment@2 {
+		target = <&ltdc>;
+		__overlay__ {
+			status = "okay";
+
+			port {
+				#address-cells = <1>;
+				#size-cells = <0>;
+
+				ltdc_ep0_out: endpoint@0 {
+					reg = <0>;
+					remote-endpoint = <&hdmi_in>;
+				};
+			};
+		};
+	};
+};
diff --git a/arch/arm/boot/dts/st/overlays/stm32mp135x-phyboard-segin-peb-av-02-lcd-resistive.dts b/arch/arm/boot/dts/st/overlays/stm32mp135x-phyboard-segin-peb-av-02-lcd-resistive.dts
new file mode 100644
index 000000000000..c9ba9c9905c9
--- /dev/null
+++ b/arch/arm/boot/dts/st/overlays/stm32mp135x-phyboard-segin-peb-av-02-lcd-resistive.dts
@@ -0,0 +1,99 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright (C) 2023 PHYTEC Messtechnik GmbH
+ * Author: Christophe PARANT <c.parant@phytec.fr>
+ */
+
+/dts-v1/;
+/plugin/;
+
+#include <dt-bindings/gpio/gpio.h>
+#include <dt-bindings/interrupt-controller/arm-gic.h>
+
+/ {
+	compatible = "phytec,stm32mp13-pbacd-10";
+
+	fragment@0 {
+		target-path = "/";
+		__overlay__ {
+			panel_rgb: panel {
+				compatible = "edt,etm0700g0edh6";
+				status = "okay";
+				backlight = <&panel_backlight>;
+				enable-gpios = <&gpiob 1 GPIO_ACTIVE_HIGH>;
+
+				port {
+					panel_in_rgb: endpoint {
+						remote-endpoint = <&ltdc_ep0_out>;
+					};
+				};
+			};
+
+			panel_backlight: panel-backlight {
+				compatible = "pwm-backlight";
+				status = "okay";
+				pwms = <&pwm_8 2 100000 0>;
+				power-supply = <&vdd>;
+				brightness-levels = <0 4 8 16 32 64 128 255>;
+				default-brightness-level = <6>;
+			};
+		};
+	};
+
+	fragment@1 {
+		target = <&timers8>;
+		__overlay__ {
+			status = "okay";
+			/delete-property/dmas;
+			/delete-property/dma-names;
+
+			pwm_8: pwm {
+				pinctrl-0 = <&tim8_pwm_pins_mx>;
+				pinctrl-1 = <&tim8_pwm_sleep_pins_mx>;
+				pinctrl-names = "default", "sleep";
+				status = "okay";
+			};
+		};
+	};
+
+	fragment@2 {
+		target = <&ltdc>;
+		__overlay__ {
+			status = "okay";
+
+			pinctrl-names = "default", "sleep";
+			pinctrl-0 = <&ltdc_pins_mx>;
+			pinctrl-1 = <&ltdc_sleep_pins_mx>;
+
+			port {
+				#address-cells = <1>;
+				#size-cells = <0>;
+
+				ltdc_ep0_out: endpoint@0 {
+					reg = <0>;
+					remote-endpoint = <&panel_in_rgb>;
+				};
+			};
+		};
+	};
+
+	fragment@3 {
+		target = <&i2c5>;
+		__overlay__ {
+			#address-cells = <1>;
+			#size-cells = <0>;
+			status = "okay";
+
+			tsc2004: touchscreen@49 {
+				compatible = "ti,tsc2004";
+				reg = <0x49>;
+				interrupts-extended = <&gpioa 13 IRQ_TYPE_LEVEL_LOW>;
+
+				touchscreen-inverted-x;
+				touchscreen-inverted-y;
+
+				status = "okay";
+			};
+		};
+	};
+};
diff --git a/arch/arm/boot/dts/st/overlays/stm32mp135x-phyboard-segin-peb-av-02-lcd.dts b/arch/arm/boot/dts/st/overlays/stm32mp135x-phyboard-segin-peb-av-02-lcd.dts
new file mode 100644
index 000000000000..b85cc6aa89f2
--- /dev/null
+++ b/arch/arm/boot/dts/st/overlays/stm32mp135x-phyboard-segin-peb-av-02-lcd.dts
@@ -0,0 +1,107 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright (C) 2023 PHYTEC Messtechnik GmbH
+ * Author: Christophe PARANT <c.parant@phytec.fr>
+ */
+
+/dts-v1/;
+/plugin/;
+
+#include <dt-bindings/gpio/gpio.h>
+
+/ {
+	compatible = "phytec,stm32mp13-pbacd-10";
+
+	fragment@0 {
+		target-path = "/";
+		__overlay__ {
+			panel_rgb: panel {
+				compatible = "edt,etm0700g0edh6";
+				status = "okay";
+				backlight = <&panel_backlight>;
+				enable-gpios = <&gpiob 1 GPIO_ACTIVE_HIGH>;
+
+				port {
+					panel_in_rgb: endpoint {
+						remote-endpoint = <&ltdc_ep0_out>;
+					};
+				};
+			};
+
+			panel_backlight: panel-backlight {
+				compatible = "pwm-backlight";
+				status = "okay";
+				pwms = <&pwm_8 2 100000 0>;
+				power-supply = <&vdd>;
+				brightness-levels = <0 4 8 16 32 64 128 255>;
+				default-brightness-level = <6>;
+			};
+		};
+	};
+
+	fragment@1 {
+		target = <&timers8>;
+		__overlay__ {
+			status = "okay";
+			/delete-property/dmas;
+			/delete-property/dma-names;
+
+			pwm_8: pwm {
+				pinctrl-0 = <&tim8_pwm_pins_mx>;
+				pinctrl-1 = <&tim8_pwm_sleep_pins_mx>;
+				pinctrl-names = "default", "sleep";
+				status = "okay";
+			};
+		};
+	};
+
+	fragment@2 {
+		target = <&ltdc>;
+		__overlay__ {
+			status = "okay";
+
+			pinctrl-names = "default", "sleep";
+			pinctrl-0 = <&ltdc_pins_mx>;
+			pinctrl-1 = <&ltdc_sleep_pins_mx>;
+
+			port {
+				#address-cells = <1>;
+				#size-cells = <0>;
+
+				ltdc_ep0_out: endpoint@0 {
+					reg = <0>;
+					remote-endpoint = <&panel_in_rgb>;
+				};
+			};
+		};
+	};
+
+	fragment@3 {
+		target = <&i2c5>;
+		__overlay__ {
+			#address-cells = <1>;
+			#size-cells = <0>;
+			status = "okay";
+
+			edt_ts: touchscreen@38 {
+				compatible = "edt,edt-ft5406", "edt,edt-ft5x06";
+				reg = <0x38>;
+				interrupts = <5 2>;
+				interrupt-parent = <&gpiof>;
+				interrupt-controller;
+				reset-gpios = <&gpioi 0 1>;
+				status = "okay";
+			};
+
+			ili_ts: touchscreen@41 {
+				compatible = "ilitek,ili2130";
+				reg = <0x41>;
+				interrupts = <5 2>;
+				interrupt-parent = <&gpiof>;
+				interrupt-controller;
+				reset-gpios = <&gpioi 0 1>;
+				status = "okay";
+			};
+		};
+	};
+};
diff --git a/arch/arm/boot/dts/st/overlays/stm32mp135x-phyboard-segin-phycam-vm016.dts b/arch/arm/boot/dts/st/overlays/stm32mp135x-phyboard-segin-phycam-vm016.dts
new file mode 100644
index 000000000000..c6b1d633105c
--- /dev/null
+++ b/arch/arm/boot/dts/st/overlays/stm32mp135x-phyboard-segin-phycam-vm016.dts
@@ -0,0 +1,55 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright (C) 2023 PHYTEC Messtechnik GmbH
+ * Author: Christophe Parant <c.parant@phytec.fr>
+ */
+
+/dts-v1/;
+/plugin/;
+
+/ {
+	compatible = "phytec,stm32mp13-pbacd-10";
+};
+
+&i2c5 {
+	#address-cells = <1>;
+	#size-cells = <0>;
+	status = "okay";
+
+	vm016: camera@10 {
+		#address-cells = <0x1>;
+		#size-cells = <0x0>;
+
+		compatible = "onsemi,ar0144";
+		reg = <0x10>;
+		clock-names = "ext";
+		clocks = <&clk_mco1>;
+
+		port@0 {
+			reg = <0>;
+
+			vm016_ep0: endpoint {
+				remote-endpoint = <&dcmi_ep0>;
+				bus-type = <5>; /* Parallel */
+				bus-width = <8>;
+				data-shift = <4>;
+				link-frequencies = /bits/ 64 <74250000>;
+			};
+		};
+	};
+};
+
+&dcmipp {
+	status = "okay";
+
+	port {
+		dcmi_ep0: endpoint {
+			remote-endpoint = <&vm016_ep0>;
+			bus-width = <8>;
+			hsync-active = <0>;
+			vsync-active = <0>;
+			pclk-max-frequency = <77000000>;
+			pclk-sample = <1>;
+		};
+	};
+};
diff --git a/arch/arm/boot/dts/st/overlays/stm32mp13xx-phyboard-segin-peb-eval-01-jtag.dts b/arch/arm/boot/dts/st/overlays/stm32mp13xx-phyboard-segin-peb-eval-01-jtag.dts
new file mode 100644
index 000000000000..1a948ed3e24e
--- /dev/null
+++ b/arch/arm/boot/dts/st/overlays/stm32mp13xx-phyboard-segin-peb-eval-01-jtag.dts
@@ -0,0 +1,16 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright (C) 2023 PHYTEC Messtechnik GmbH
+ * Author: Christophe PARANT <c.parant@phytec.fr>
+ */
+
+/dts-v1/;
+/plugin/;
+
+/ {
+	compatible = "phytec,stm32mp13-pbacd-10";
+};
+
+&sai1{
+	status = "disabled";
+};
diff --git a/arch/arm/boot/dts/st/overlays/stm32mp13xx-phyboard-segin-peb-eval-01-leds-buttons.dts b/arch/arm/boot/dts/st/overlays/stm32mp13xx-phyboard-segin-peb-eval-01-leds-buttons.dts
new file mode 100644
index 000000000000..de7024df5617
--- /dev/null
+++ b/arch/arm/boot/dts/st/overlays/stm32mp13xx-phyboard-segin-peb-eval-01-leds-buttons.dts
@@ -0,0 +1,61 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright (C) 2023 PHYTEC Messtechnik GmbH
+ * Author: Christophe PARANT <c.parant@phytec.fr>
+ */
+
+/dts-v1/;
+/plugin/;
+
+#include <dt-bindings/gpio/gpio.h>
+#include <dt-bindings/input/linux-event-codes.h>
+
+/ {
+	compatible = "phytec,stm32mp13-pbacd-10";
+	fragment@1 {
+		target-path= "/";
+
+		__overlay__ {
+
+			gpio-keys {
+				compatible = "gpio-key";
+
+				button0 {
+					label = "Home";
+					linux,code = <KEY_HOME>;
+					gpios = <&gpiog 15 GPIO_ACTIVE_LOW>;
+					wakeup-source;
+				};
+
+				button1 {
+					label = "Enter";
+					linux,code = <KEY_ENTER>;
+					gpios = <&gpioa 6 GPIO_ACTIVE_LOW>;
+					wakeup-source;
+				};
+
+				button2 {
+					label = "Menu";
+					linux,code = <KEY_MENU>;
+					gpios = <&gpioh 2 GPIO_ACTIVE_LOW>;
+					wakeup-source;
+				};
+			};
+
+			user-leds {
+				compatible = "gpio-leds";
+
+				user-led1 {
+					gpios = <&gpioe 8 GPIO_ACTIVE_HIGH>;
+					linux,default-trigger = "heartbeat";
+				};
+
+				user-led2 {
+					gpios = <&gpioe 10 GPIO_ACTIVE_HIGH>;
+					linux,default-trigger = "gpio";
+					default-state = "on";
+				};
+			};
+		};
+	};
+};
diff --git a/arch/arm/boot/dts/st/stm32mp135f-phyboard-segin-ff-rdk-1gib.dts b/arch/arm/boot/dts/st/stm32mp135f-phyboard-segin-ff-rdk-1gib.dts
new file mode 100644
index 000000000000..7a9c2340a972
--- /dev/null
+++ b/arch/arm/boot/dts/st/stm32mp135f-phyboard-segin-ff-rdk-1gib.dts
@@ -0,0 +1,30 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)
+/*
+ * Copyright (C) 2023 PHYTEC Messtechnik GmbH
+ * Authors: Christophe Parant <c.parant@phytec.fr>
+ */
+
+/dts-v1/;
+
+#include "stm32mp135f-phyboard-segin-ff-rdk.dtsi"
+
+/ {
+	model = "PHYTEC phyBOARD-Segin STM32MP135F Full Featured 1Gib RAM";
+	compatible = "phytec,stm32mp135f-pbacd10", "phytec,stm32mp135f-pcl076",
+		     "st,stm32mp135";
+
+	memory@c0000000 {
+		reg = <0xc0000000 0x40000000>;
+	};
+
+	reserved-memory {
+		#address-cells = <1>;
+		#size-cells = <1>;
+		ranges;
+
+		optee@dd000000 {
+			reg = <0xfd000000 0x3000000>;
+			no-map;
+		};
+	};
+};
diff --git a/arch/arm/boot/dts/st/stm32mp135f-phyboard-segin-ff-rdk-512mb.dts b/arch/arm/boot/dts/st/stm32mp135f-phyboard-segin-ff-rdk-512mb.dts
new file mode 100644
index 000000000000..682299e9785d
--- /dev/null
+++ b/arch/arm/boot/dts/st/stm32mp135f-phyboard-segin-ff-rdk-512mb.dts
@@ -0,0 +1,30 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)
+/*
+ * Copyright (C) 2023 PHYTEC Messtechnik GmbH
+ * Authors: Christophe Parant <c.parant@phytec.fr>
+ */
+
+/dts-v1/;
+
+#include "stm32mp135f-phyboard-segin-ff-rdk.dtsi"
+
+/ {
+	model = "PHYTEC phyBOARD-Segin STM32MP135F Full Featured 512MB RAM";
+	compatible = "phytec,stm32mp135f-pbacd10", "phytec,stm32mp135f-pcl076",
+		     "st,stm32mp135";
+
+	memory@c0000000 {
+		reg = <0xc0000000 0x20000000>;
+	};
+
+	reserved-memory {
+		#address-cells = <1>;
+		#size-cells = <1>;
+		ranges;
+
+		optee@dd000000 {
+			reg = <0xdd000000 0x3000000>;
+			no-map;
+		};
+	};
+};
diff --git a/arch/arm/boot/dts/st/stm32mp135f-phyboard-segin-ff-rdk.dtsi b/arch/arm/boot/dts/st/stm32mp135f-phyboard-segin-ff-rdk.dtsi
new file mode 100644
index 000000000000..fbbc4355b248
--- /dev/null
+++ b/arch/arm/boot/dts/st/stm32mp135f-phyboard-segin-ff-rdk.dtsi
@@ -0,0 +1,90 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)
+/*
+ * Copyright (C) 2023 PHYTEC Messtechnik GmbH
+ * Authors: Christophe Parant <c.parant@phytec.fr>
+ */
+
+#include "stm32mp135.dtsi"
+#include "stm32mp13xf.dtsi"
+#include "stm32mp13xx-phycore-som.dtsi"
+#include "stm32mp13xx-phyboard-segin.dtsi"
+
+&i2c5_eeprom {
+	status = "okay";
+};
+
+&sdmmc1 {
+	status = "okay";
+};
+
+&sdmmc2 {
+	status = "okay";
+};
+
+&cryp {
+	status = "okay";
+};
+
+&adc1 {
+	status = "okay";
+};
+
+&m_can2 {
+	status = "okay";
+};
+
+&spi1 {
+	status = "okay";
+};
+
+&ethernet1 {
+	status = "okay";
+};
+
+&ethernet2 {
+	status = "okay";
+};
+
+&i2c_rtc {
+	status = "okay";
+};
+
+&reg_m_can {
+	status = "okay";
+};
+
+&reg_sound_1v8 {
+	status = "okay";
+};
+
+&reg_sound_3v3 {
+	status = "okay";
+};
+
+&sai1 {
+	status = "okay";
+};
+
+&sound {
+	status = "okay";
+};
+
+&tlv320 {
+	status = "okay";
+};
+
+&usart2 {
+	status = "okay";
+};
+
+&usbotg_hs {
+	status = "okay";
+};
+
+&usbh_ehci {
+	status = "okay";
+};
+
+&usbh_ohci{
+	status = "okay";
+};
diff --git a/arch/arm/boot/dts/st/stm32mp13xx-phyboard-segin-pinctrl.dtsi b/arch/arm/boot/dts/st/stm32mp13xx-phyboard-segin-pinctrl.dtsi
new file mode 100644
index 000000000000..2d75683d6f1a
--- /dev/null
+++ b/arch/arm/boot/dts/st/stm32mp13xx-phyboard-segin-pinctrl.dtsi
@@ -0,0 +1,393 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)
+/*
+ * Copyright (C) 2023 PHYTEC Messtechnik GmbH
+ * Authors: Christophe Parant <c.parant@phytec.fr>
+ */
+
+#include <dt-bindings/pinctrl/stm32-pinfunc.h>
+
+&pinctrl {
+
+	adc1_pins_mx: adc1-mx-0 {
+		pins {
+			pinmux = <STM32_PINMUX('F', 12, ANALOG)>; /* ADC1_INP6 */
+		};
+	};
+
+	adc1_sleep_pins_mx: adc1-sleep-mx-0 {
+		pins {
+			pinmux = <STM32_PINMUX('F', 12, ANALOG)>; /* ADC1_INP6 */
+		};
+	};
+
+	dcmipp_pins_mx: dcmipp-mx-0 {
+		pins {
+			pinmux = <STM32_PINMUX('A', 9, AF13)>, /* DCMIPP_D0 */
+					 <STM32_PINMUX('B', 7, AF14)>, /* DCMIPP_PIXCLK */
+					 <STM32_PINMUX('B', 8, AF13)>, /* DCMIPP_D6 */
+					 <STM32_PINMUX('D', 0, AF13)>, /* DCMIPP_D1 */
+					 <STM32_PINMUX('D', 3, AF13)>, /* DCMIPP_D5 */
+					 <STM32_PINMUX('D', 11, AF14)>, /* DCMIPP_D4 */
+					 <STM32_PINMUX('E', 4, AF13)>, /* DCMIPP_D3 */
+					 <STM32_PINMUX('E', 14, AF13)>, /* DCMIPP_D7 */
+					 <STM32_PINMUX('G', 9, AF13)>, /* DCMIPP_VSYNC */
+					 <STM32_PINMUX('G', 10, AF13)>, /* DCMIPP_D2 */
+					 <STM32_PINMUX('H', 8, AF13)>; /* DCMIPP_HSYNC */
+			bias-disable;
+		};
+	};
+
+	dcmipp_sleep_pins_mx: dcmipp-sleep-mx-0 {
+		pins {
+			pinmux = <STM32_PINMUX('A', 9, ANALOG)>, /* DCMIPP_D0 */
+					 <STM32_PINMUX('B', 7, ANALOG)>, /* DCMIPP_PIXCLK */
+					 <STM32_PINMUX('B', 8, ANALOG)>, /* DCMIPP_D6 */
+					 <STM32_PINMUX('D', 0, ANALOG)>, /* DCMIPP_D1 */
+					 <STM32_PINMUX('D', 3, ANALOG)>, /* DCMIPP_D5 */
+					 <STM32_PINMUX('D', 11, ANALOG)>, /* DCMIPP_D4 */
+					 <STM32_PINMUX('E', 4, ANALOG)>, /* DCMIPP_D3 */
+					 <STM32_PINMUX('E', 14, ANALOG)>, /* DCMIPP_D7 */
+					 <STM32_PINMUX('G', 9, ANALOG)>, /* DCMIPP_VSYNC */
+					 <STM32_PINMUX('G', 10, ANALOG)>, /* DCMIPP_D2 */
+					 <STM32_PINMUX('H', 8, ANALOG)>; /* DCMIPP_HSYNC */
+		};
+	};
+
+	eth2_pins_mx: eth2-mx-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('A', 12, AF11)>, /* ETH2_CRS_DV */
+					 <STM32_PINMUX('E', 2, AF10)>, /* ETH2_RXD1 */
+					 <STM32_PINMUX('F', 4, AF11)>, /* ETH2_RXD0 */
+					 <STM32_PINMUX('F', 11, AF12)>; /* ETH2_RX_ER */
+			bias-disable;
+		};
+		pins2 {
+			pinmux = <STM32_PINMUX('B', 2, AF11)>; /* ETH2_MDIO */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <0>;
+		};
+		pins3 {
+			pinmux = <STM32_PINMUX('F', 6, AF11)>, /* ETH2_TX_EN */
+					 <STM32_PINMUX('F', 7, AF11)>, /* ETH2_TXD0 */
+					 <STM32_PINMUX('G', 5, AF10)>, /* ETH2_MDC */
+					 <STM32_PINMUX('G', 8, AF13)>, /* ETH2_CLK */
+					 <STM32_PINMUX('G', 11, AF10)>; /* ETH2_TXD1 */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <1>;
+		};
+	};
+
+	eth2_sleep_pins_mx: eth2-sleep-mx-0 {
+		pins {
+			pinmux = <STM32_PINMUX('A', 12, ANALOG)>, /* ETH2_CRS_DV */
+					 <STM32_PINMUX('B', 2, ANALOG)>, /* ETH2_MDIO */
+					 <STM32_PINMUX('E', 2, ANALOG)>, /* ETH2_RXD1 */
+					 <STM32_PINMUX('F', 4, ANALOG)>, /* ETH2_RXD0 */
+					 <STM32_PINMUX('F', 6, ANALOG)>, /* ETH2_TX_EN */
+					 <STM32_PINMUX('F', 7, ANALOG)>, /* ETH2_TXD0 */
+					 <STM32_PINMUX('F', 11, ANALOG)>, /* ETH2_RX_ER */
+					 <STM32_PINMUX('G', 5, ANALOG)>, /* ETH2_MDC */
+					 <STM32_PINMUX('G', 8, ANALOG)>, /* ETH2_CLK */
+					 <STM32_PINMUX('G', 11, ANALOG)>; /* ETH2_TXD1 */
+		};
+	};
+
+	fdcan2_pins_mx: fdcan2-mx-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('G', 1, AF9)>; /* FDCAN2_TX */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <0>;
+		};
+		pins2 {
+			pinmux = <STM32_PINMUX('G', 3, AF9)>; /* FDCAN2_RX */
+			bias-disable;
+		};
+	};
+
+	fdcan2_sleep_pins_mx: fdcan2-sleep-mx-0 {
+		pins {
+			pinmux = <STM32_PINMUX('G', 1, ANALOG)>, /* FDCAN2_TX */
+					 <STM32_PINMUX('G', 3, ANALOG)>; /* FDCAN2_RX */
+		};
+	};
+
+	ltdc_pins_mx: ltdc-mx-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('A', 15, AF11)>, /* LTDC_G7 */
+					 <STM32_PINMUX('B', 6, AF7)>, /* LTDC_B6 */
+					 <STM32_PINMUX('B', 12, AF13)>, /* LTDC_R3 */
+					 <STM32_PINMUX('D', 5, AF14)>, /* LTDC_G4 */
+					 <STM32_PINMUX('D', 10, AF14)>, /* LTDC_B2 */
+					 <STM32_PINMUX('D', 14, AF14)>, /* LTDC_R4 */
+					 <STM32_PINMUX('E', 0, AF14)>, /* LTDC_B5 */
+					 <STM32_PINMUX('E', 7, AF14)>, /* LTDC_R5 */
+					 <STM32_PINMUX('E', 9, AF14)>, /* LTDC_R7 */
+					 <STM32_PINMUX('E', 13, AF14)>, /* LTDC_R6 */
+					 <STM32_PINMUX('F', 1, AF13)>, /* LTDC_B7 */
+					 <STM32_PINMUX('F', 2, AF14)>, /* LTDC_B3 */
+					 <STM32_PINMUX('F', 3, AF14)>, /* LTDC_G3 */
+					 <STM32_PINMUX('G', 0, AF14)>, /* LTDC_G5 */
+					 <STM32_PINMUX('G', 4, AF11)>, /* LTDC_VSYNC */
+					 <STM32_PINMUX('G', 7, AF14)>, /* LTDC_R2 */
+					 <STM32_PINMUX('H', 9, AF11)>, /* LTDC_DE */
+					 <STM32_PINMUX('H', 10, AF13)>, /* LTDC_HSYNC */
+					 <STM32_PINMUX('H', 11, AF14)>, /* LTDC_G6 */
+					 <STM32_PINMUX('H', 13, AF14)>, /* LTDC_G2 */
+					 <STM32_PINMUX('H', 14, AF11)>; /* LTDC_B4 */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <0>;
+		};
+		pins2 {
+			pinmux = <STM32_PINMUX('D', 9, AF13)>; /* LTDC_CLK */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <1>;
+		};
+	};
+
+	ltdc_sleep_pins_mx: ltdc-sleep-mx-0 {
+		pins {
+			pinmux = <STM32_PINMUX('A', 15, ANALOG)>, /* LTDC_G7 */
+					 <STM32_PINMUX('B', 6, ANALOG)>, /* LTDC_B6 */
+					 <STM32_PINMUX('B', 12, ANALOG)>, /* LTDC_R3 */
+					 <STM32_PINMUX('D', 5, ANALOG)>, /* LTDC_G4 */
+					 <STM32_PINMUX('D', 9, ANALOG)>, /* LTDC_CLK */
+					 <STM32_PINMUX('D', 10, ANALOG)>, /* LTDC_B2 */
+					 <STM32_PINMUX('D', 14, ANALOG)>, /* LTDC_R4 */
+					 <STM32_PINMUX('E', 0, ANALOG)>, /* LTDC_B5 */
+					 <STM32_PINMUX('E', 7, ANALOG)>, /* LTDC_R5 */
+					 <STM32_PINMUX('E', 9, ANALOG)>, /* LTDC_R7 */
+					 <STM32_PINMUX('E', 13, ANALOG)>, /* LTDC_R6 */
+					 <STM32_PINMUX('F', 1, ANALOG)>, /* LTDC_B7 */
+					 <STM32_PINMUX('F', 2, ANALOG)>, /* LTDC_B3 */
+					 <STM32_PINMUX('F', 3, ANALOG)>, /* LTDC_G3 */
+					 <STM32_PINMUX('G', 0, ANALOG)>, /* LTDC_G5 */
+					 <STM32_PINMUX('G', 4, ANALOG)>, /* LTDC_VSYNC */
+					 <STM32_PINMUX('G', 7, ANALOG)>, /* LTDC_R2 */
+					 <STM32_PINMUX('H', 9, ANALOG)>, /* LTDC_DE */
+					 <STM32_PINMUX('H', 10, ANALOG)>, /* LTDC_HSYNC */
+					 <STM32_PINMUX('H', 11, ANALOG)>, /* LTDC_G6 */
+					 <STM32_PINMUX('H', 13, ANALOG)>, /* LTDC_G2 */
+					 <STM32_PINMUX('H', 14, ANALOG)>; /* LTDC_B4 */
+		};
+	};
+
+	sai1a_pins_mx: sai1a-mx-0 {
+		pins {
+			pinmux = <STM32_PINMUX('A', 5, AF6)>; /* SAI1_SD_A */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <0>;
+		};
+	};
+
+	sai1a_sleep_pins_mx: sai1a-sleep-mx-0 {
+		pins {
+			pinmux = <STM32_PINMUX('A', 5, ANALOG)>; /* SAI1_SD_A */
+		};
+	};
+
+	sai1b_pins_mx: sai1b-mx-0 {
+		pins {
+			pinmux = <STM32_PINMUX('A', 0, AF6)>, /* SAI1_SD_B */
+					 <STM32_PINMUX('A', 3, AF6)>, /* SAI1_FS_B */
+					 <STM32_PINMUX('A', 4, AF4)>, /* SAI1_SCK_B */
+					 <STM32_PINMUX('F', 13, AF2)>; /* SAI1_MCLK_B */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <0>;
+		};
+	};
+
+	sai1b_sleep_pins_mx: sai1b-sleep-mx-0 {
+		pins {
+			pinmux = <STM32_PINMUX('A', 0, ANALOG)>, /* SAI1_SD_B */
+					 <STM32_PINMUX('A', 3, ANALOG)>, /* SAI1_FS_B */
+					 <STM32_PINMUX('A', 4, ANALOG)>, /* SAI1_SCK_B */
+					 <STM32_PINMUX('F', 13, ANALOG)>; /* SAI1_MCLK_B */
+		};
+	};
+
+	sdmmc1_pins_mx: sdmmc1-mx-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('C', 8, AF12)>, /* SDMMC1_D0 */
+					 <STM32_PINMUX('C', 9, AF12)>, /* SDMMC1_D1 */
+					 <STM32_PINMUX('C', 10, AF12)>, /* SDMMC1_D2 */
+					 <STM32_PINMUX('C', 11, AF12)>, /* SDMMC1_D3 */
+					 <STM32_PINMUX('D', 2, AF12)>; /* SDMMC1_CMD */
+			bias-pull-up;
+			drive-push-pull;
+			slew-rate = <1>;
+		};
+		pins2 {
+			pinmux = <STM32_PINMUX('C', 12, AF12)>; /* SDMMC1_CK */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <2>;
+		};
+	};
+
+	sdmmc1_opendrain_pins_mx: sdmmc1-opendrain-mx-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('C', 8, AF12)>, /* SDMMC1_D0 */
+					 <STM32_PINMUX('C', 9, AF12)>, /* SDMMC1_D1 */
+					 <STM32_PINMUX('C', 10, AF12)>, /* SDMMC1_D2 */
+					 <STM32_PINMUX('C', 11, AF12)>; /* SDMMC1_D3 */
+			bias-pull-up;
+			drive-push-pull;
+			slew-rate = <1>;
+		};
+		pins2 {
+			pinmux = <STM32_PINMUX('C', 12, AF12)>; /* SDMMC1_CK */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <2>;
+		};
+		pins3 {
+			pinmux = <STM32_PINMUX('D', 2, AF12)>; /* SDMMC1_CMD */
+			bias-pull-up;
+			drive-open-drain;
+			slew-rate = <1>;
+		};
+	};
+
+	sdmmc1_sleep_pins_mx: sdmmc1-sleep-mx-0 {
+		pins {
+			pinmux = <STM32_PINMUX('C', 8, ANALOG)>, /* SDMMC1_D0 */
+					 <STM32_PINMUX('C', 9, ANALOG)>, /* SDMMC1_D1 */
+					 <STM32_PINMUX('C', 10, ANALOG)>, /* SDMMC1_D2 */
+					 <STM32_PINMUX('C', 11, ANALOG)>, /* SDMMC1_D3 */
+					 <STM32_PINMUX('C', 12, ANALOG)>, /* SDMMC1_CK */
+					 <STM32_PINMUX('D', 2, ANALOG)>; /* SDMMC1_CMD */
+		};
+	};
+
+	spi1_pins_mx: spi1-mx-0 {
+		pins {
+			pinmux = <STM32_PINMUX('A', 7, AF5)>, /* SPI1_SCK */
+					 <STM32_PINMUX('C', 0, AF6)>, /* SPI1_MOSI */
+					 <STM32_PINMUX('C', 3, AF5)>; /* SPI1_MISO */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <1>;
+		};
+	};
+
+	spi1_sleep_pins_mx: spi1-sleep-mx-0 {
+		pins {
+			pinmux = <STM32_PINMUX('A', 7, ANALOG)>, /* SPI1_SCK */
+					 <STM32_PINMUX('C', 0, ANALOG)>, /* SPI1_MOSI */
+					 <STM32_PINMUX('C', 3, ANALOG)>; /* SPI1_MISO */
+		};
+	};
+
+	tim8_pwm_pins_mx: tim8-pwm-mx-0 {
+		pins {
+			pinmux = <STM32_PINMUX('E', 5, AF3)>; /* TIM8_CH3 */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <0>;
+		};
+	};
+
+	tim8_pwm_sleep_pins_mx: tim8-pwm-sleep-mx-0 {
+		pins {
+			pinmux = <STM32_PINMUX('E', 5, ANALOG)>; /* TIM8_CH3 */
+		};
+	};
+
+	uart7_pins_mx: uart7-mx-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('E', 10, AF7)>; /* UART7_RX */
+			bias-disable;
+		};
+		pins2 {
+			pinmux = <STM32_PINMUX('H', 2, AF8)>; /* UART7_TX */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <0>;
+		};
+	};
+
+	uart7_sleep_pins_mx: uart7-sleep-mx-0 {
+		pins {
+			pinmux = <STM32_PINMUX('E', 10, ANALOG)>, /* UART7_RX */
+					 <STM32_PINMUX('H', 2, ANALOG)>; /* UART7_TX */
+		};
+	};
+
+	usart2_pins_mx: usart2-mx-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('D', 15, AF1)>, /* USART2_RX */
+					 <STM32_PINMUX('E', 11, AF2)>; /* USART2_CTS */
+			bias-disable;
+		};
+		pins2 {
+			pinmux = <STM32_PINMUX('D', 4, AF3)>, /* USART2_RTS */
+					 <STM32_PINMUX('H', 12, AF1)>; /* USART2_TX */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <0>;
+		};
+	};
+
+	usart2_sleep_pins_mx: usart2-sleep-mx-0 {
+		pins {
+			pinmux = <STM32_PINMUX('D', 4, ANALOG)>, /* USART2_RTS */
+					 <STM32_PINMUX('D', 15, ANALOG)>, /* USART2_RX */
+					 <STM32_PINMUX('E', 11, ANALOG)>, /* USART2_CTS */
+					 <STM32_PINMUX('H', 12, ANALOG)>; /* USART2_TX */
+		};
+	};
+
+	usb_otg_hs_pins_mx: usb-otg-hs-mx-0 {
+		pins {
+			pinmux = <STM32_PINMUX('A', 10, ANALOG)>, /* USB_OTG_HS_ID */
+					 <STM32_PINMUX('I', 7, ANALOG)>; /* USB_OTG_HS_VBUS */
+		};
+	};
+
+	usb_otg_hs_sleep_pins_mx: usb-otg-hs-sleep-mx-0 {
+		pins {
+			pinmux = <STM32_PINMUX('A', 10, ANALOG)>, /* USB_OTG_HS_ID */
+					 <STM32_PINMUX('I', 7, ANALOG)>; /* USB_OTG_HS_VBUS */
+		};
+	};
+
+	usart1_pins_mx: usart1-mx-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('A', 7, AF7)>, /* USART1_CTS */
+					 <STM32_PINMUX('B', 0, AF4)>; /* USART1_RX */
+			bias-disable;
+		};
+		pins2 {
+			pinmux = <STM32_PINMUX('C', 0, AF7)>, /* USART1_TX */
+					 <STM32_PINMUX('C', 2, AF7)>; /* USART1_RTS */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <0>;
+		};
+	};
+
+	usart1_sleep_pins_mx: usart1-sleep-mx-0 {
+		pins {
+			pinmux = <STM32_PINMUX('A', 7, ANALOG)>, /* USART1_CTS */
+					 <STM32_PINMUX('B', 0, ANALOG)>, /* USART1_RX */
+					 <STM32_PINMUX('C', 0, ANALOG)>, /* USART1_TX */
+					 <STM32_PINMUX('C', 2, ANALOG)>; /* USART1_RTS */
+		};
+	};
+
+        jtag_pins_disabled: jtag-disabled-0 {
+                pins {
+                        pinmux = <STM32_PINMUX('H', 4, ANALOG)>, /* JTAG_TDI */
+                                         <STM32_PINMUX('F', 14, ANALOG)>, /* JTAG_TCK */
+                                         <STM32_PINMUX('H', 5, ANALOG)>, /* JTAG_TD0 */
+                                         <STM32_PINMUX('F', 15, ANALOG)>; /* JTAG_TMS */
+                };
+        };
+};
diff --git a/arch/arm/boot/dts/st/stm32mp13xx-phyboard-segin.dtsi b/arch/arm/boot/dts/st/stm32mp13xx-phyboard-segin.dtsi
new file mode 100644
index 000000000000..b982fd7abf36
--- /dev/null
+++ b/arch/arm/boot/dts/st/stm32mp13xx-phyboard-segin.dtsi
@@ -0,0 +1,286 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (C) 2023 PHYTEC Messtechnik GmbH
+ * Author: Christophe Parant <c.parant@phytec.fr>
+ */
+
+#include "stm32mp13xx-phyboard-segin-pinctrl.dtsi"
+
+/ {
+	model = "PHYTEC phyBOARD-Segin STM32MP13";
+	compatible = "phytec,stm32mp13-pbacd-10", "phytec,stm32mp13-pcl076", "st,stm32mp13";
+
+	aliases {
+		ethernet1 = &ethernet2;
+		rtc0 = &i2c_rtc;
+		rtc1 = &rtc;
+		serial1 = &usart2;
+	};
+
+	reg_sound_1v8: regulator-1v8 {
+		compatible = "regulator-fixed";
+		regulator-name = "i2s-audio-1v8";
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <1800000>;
+		status = "okay";
+	};
+
+	reg_sound_3v3: regulator-3v3 {
+		compatible = "regulator-fixed";
+		regulator-name = "i2s-audio-3v3";
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+		status = "okay";
+	};
+
+	reg_m_can: regulator-mcan {
+		compatible = "regulator-fixed";
+		regulator-name = "mcan-reg";
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+		gpio = <&gpioa 14 GPIO_ACTIVE_HIGH>;
+		regulator-always-on;
+		status = "okay";
+	};
+
+	sound: sound {
+		compatible = "audio-graph-card";
+		label = "STM32MP1-PHYCORE";
+		routing =
+			"Playback", "MCLK", /* Set a route between "MCLK" and "playback" widgets */
+			"Capture", "MCLK";
+		dais = <&sai1b_port &sai1a_port>;
+		status = "okay";
+	};
+
+	clocks {
+		clk_mco1: clk-mco1 {
+			#clock-cells = <0>;
+			compatible = "fixed-clock";
+			clock-frequency = <24000000>;
+		};
+	};
+
+	wake_up {
+		compatible = "gpio-keys";
+		status = "okay";
+
+		button {
+			label = "wake-up";
+			linux,code = <KEY_WAKEUP>;
+			interrupts-extended = <&optee 0>;
+			status = "okay";
+		};
+	};
+};
+
+&adc_1 {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&adc1_pins_mx>;
+	pinctrl-1 = <&adc1_sleep_pins_mx>;
+	vdd-supply = <&vdd>;
+	vdda-supply = <&vdd>;
+	vref-supply = <&vdd>;
+	status = "disabled";
+
+	adc1: adc@0 {
+		st,min-sample-time-nsecs = <5000>;
+		/* in6 */
+		st,adc-channels = <6>;
+		status = "okay";
+	};
+};
+
+&dcmipp{
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&dcmipp_pins_mx>;
+	pinctrl-1 = <&dcmipp_sleep_pins_mx>;
+	status = "disabled";
+};
+
+&m_can2 {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&fdcan2_pins_mx>;
+	pinctrl-1 = <&fdcan2_sleep_pins_mx>;
+	status = "disabled";
+};
+
+&spi1 {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&spi1_pins_mx>;
+	pinctrl-1 = <&spi1_sleep_pins_mx>;
+	cs-gpios = <&gpioc 2 GPIO_ACTIVE_LOW>;
+	status = "disabled";
+
+	spi@0 {
+		compatible = "linux,spidev";
+		spi-max-frequency = <10000000>;
+		reg = <0>;
+	};
+};
+
+&ethernet2 {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&eth2_pins_mx>;
+	pinctrl-1 = <&eth2_sleep_pins_mx>;
+	phy-mode = "rmii";
+	max-speed = <100>;
+	phy-handle = <&phy0_eth2>;
+	st,ext-phyclk;
+	nvmem-cells = <&ethernet_mac2_address>;
+	nvmem-cell-names = "mac-address";
+	status = "disabled";
+
+	mdio1 {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		compatible = "snps,dwmac-mdio";
+		phy0_eth2: ethernet-phy@2 {
+			clocks = <&rcc ETH2CK_K>;
+			clock-names = "rmii-ref";
+			micrel,led-mode = <1>;
+			reg = <2>;
+		};
+	};
+};
+
+&i2c5 {
+	tlv320: codec@18 {
+		compatible = "ti,tlv320aic3007";
+		#sound-dai-cells = <0>;
+		reg = <0x18>;
+		AVDD-supply = <&reg_sound_3v3>;
+		IOVDD-supply = <&reg_sound_3v3>;
+		DRVDD-supply = <&reg_sound_3v3>;
+		DVDD-supply = <&reg_sound_1v8>;
+
+		clocks = <&sai1b>;
+		clock-names = "MCLK";
+
+		status = "okay";
+
+		tlv320_port: port {
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			tlv320_tx_endpoint: endpoint@0 {
+				reg = <0>;
+				remote-endpoint = <&sai1b_endpoint>;
+				frame-master;
+				bitclock-master;
+			};
+
+			tlv320_rx_endpoint: endpoint@1 {
+				reg = <1>;
+				remote-endpoint = <&sai1a_endpoint>;
+				frame-master;
+				bitclock-master;
+			};
+		};
+
+	};
+
+	i2c_rtc: rtc@68 {
+		compatible = "microcrystal,rv4162";
+		reg = <0x68>;
+		interrupt-parent = <&gpiog>;
+		interrupts = <12 IRQ_TYPE_LEVEL_LOW>;
+		status = "disabled";
+	};
+};
+
+&sai1 {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&sai1a_pins_mx>, <&sai1b_pins_mx>, <&jtag_pins_disabled>;
+	pinctrl-1 = <&sai1a_sleep_pins_mx>, <&sai1b_sleep_pins_mx>;
+	clocks = <&rcc SAI1>, <&scmi_clk CK_SCMI_PLL3_Q>, <&scmi_clk CK_SCMI_PLL3_R>;
+	clock-names = "pclk", "x8k", "x11k";
+	status = "disabled";
+
+	sai1a:audio-controller@4400a004{
+		dma-names = "rx";
+		st,sync = <&sai1b 2>;
+		clocks = <&rcc SAI1_K>, <&sai1b>;
+		clock-names = "sai_ck", "MCLK";
+		status = "okay";
+
+		sai1a_port: port {
+			sai1a_endpoint: endpoint {
+				remote-endpoint = <&tlv320_rx_endpoint>;
+				format = "i2s";
+				mclk-fs = <256>;
+				dai-tdm-slot-num = <2>;
+				dai-tdm-slot-width = <16>;
+			};
+		};
+	};
+
+	sai1b:audio-controller@4400a024{
+		#clock-cells = <0>;
+		dma-names = "tx";
+		status = "okay";
+
+		sai1b_port: port {
+			sai1b_endpoint: endpoint {
+				remote-endpoint = <&tlv320_tx_endpoint>;
+				format = "i2s";
+				mclk-fs = <256>;
+				dai-tdm-slot-num = <2>;
+				dai-tdm-slot-width = <16>;
+			};
+		};
+	};
+};
+
+&usart2 {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&usart2_pins_mx>;
+	pinctrl-1 = <&usart2_sleep_pins_mx>;
+	uart-has-rtscts;
+	status = "disabled";
+};
+
+&usbh_ehci {
+	phys = <&usbphyc_port0>;
+	phy-names = "usb";
+	status = "disabled";
+};
+
+&usbh_ohci {
+	phys = <&usbphyc_port0>;
+	phy-names = "usb";
+	status = "disabled";
+};
+
+&usbotg_hs {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&usb_otg_hs_pins_mx>;
+	pinctrl-1 = <&usb_otg_hs_sleep_pins_mx>;
+	phys = <&usbphyc_port1 0>;
+	phy-names = "usb2-phy";
+	status = "disabled";
+};
+
+&usbphyc {
+	status = "okay";
+};
+
+&usbphyc_port0 {
+	phy-supply = <&vdd_usb>;
+};
+
+&usbphyc_port1 {
+	phy-supply = <&vdd_usb>;
+};
+
+&sdmmc1 {
+	pinctrl-names = "default", "opendrain", "sleep";
+	pinctrl-0 = <&sdmmc1_pins_mx>;
+	pinctrl-1 = <&sdmmc1_opendrain_pins_mx>;
+	pinctrl-2 = <&sdmmc1_sleep_pins_mx>;
+	cd-gpios = <&gpioi 1 GPIO_ACTIVE_LOW>;
+	st,neg-edge;
+	vmmc-supply = <&vdd>;
+	bus-width = <4>;
+	status = "okay";
+};
diff --git a/arch/arm/boot/dts/st/stm32mp13xx-phycore-som-pinctrl.dtsi b/arch/arm/boot/dts/st/stm32mp13xx-phycore-som-pinctrl.dtsi
new file mode 100644
index 000000000000..8e20034a6321
--- /dev/null
+++ b/arch/arm/boot/dts/st/stm32mp13xx-phycore-som-pinctrl.dtsi
@@ -0,0 +1,152 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)
+/*
+ * Copyright (C) 2023 PHYTEC Messtechnik GmbH
+ * Authors: Christophe Parant <c.parant@phytec.fr>
+ */
+
+#include <dt-bindings/pinctrl/stm32-pinfunc.h>
+
+&pinctrl {
+
+	eth1_pins_mx: eth1-mx-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('A', 1, AF11)>, /* ETH1_REF_CLK */
+					 <STM32_PINMUX('B', 11, AF11)>, /* ETH1_TX_EN */
+					 <STM32_PINMUX('G', 2, AF11)>, /* ETH1_MDC */
+					 <STM32_PINMUX('G', 13, AF11)>, /* ETH1_TXD0 */
+					 <STM32_PINMUX('G', 14, AF11)>; /* ETH1_TXD1 */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <1>;
+		};
+		pins2 {
+			pinmux = <STM32_PINMUX('A', 2, AF11)>; /* ETH1_MDIO */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <0>;
+		};
+		pins3 {
+			pinmux = <STM32_PINMUX('C', 1, AF10)>, /* ETH1_CRS_DV */
+					 <STM32_PINMUX('C', 4, AF11)>, /* ETH1_RXD0 */
+					 <STM32_PINMUX('C', 5, AF11)>; /* ETH1_RXD1 */
+			bias-disable;
+		};
+	};
+
+	eth1_sleep_pins_mx: eth1-sleep-mx-0 {
+		pins {
+			pinmux = <STM32_PINMUX('A', 1, ANALOG)>, /* ETH1_REF_CLK */
+					 <STM32_PINMUX('A', 2, ANALOG)>, /* ETH1_MDIO */
+					 <STM32_PINMUX('B', 11, ANALOG)>, /* ETH1_TX_EN */
+					 <STM32_PINMUX('C', 1, ANALOG)>, /* ETH1_CRS_DV */
+					 <STM32_PINMUX('C', 4, ANALOG)>, /* ETH1_RXD0 */
+					 <STM32_PINMUX('C', 5, ANALOG)>, /* ETH1_RXD1 */
+					 <STM32_PINMUX('G', 2, ANALOG)>, /* ETH1_MDC */
+					 <STM32_PINMUX('G', 13, ANALOG)>, /* ETH1_TXD0 */
+					 <STM32_PINMUX('G', 14, ANALOG)>; /* ETH1_TXD1 */
+		};
+	};
+
+	i2c5_pins_mx: i2c5-mx-0 {
+		pins {
+			pinmux = <STM32_PINMUX('D', 1, AF4)>, /* I2C5_SCL */
+					 <STM32_PINMUX('H', 6, AF4)>; /* I2C5_SDA */
+			bias-disable;
+			drive-open-drain;
+			slew-rate = <0>;
+		};
+	};
+
+	i2c5_sleep_pins_mx: i2c5-sleep-mx-0 {
+		pins {
+			pinmux = <STM32_PINMUX('D', 1, ANALOG)>, /* I2C5_SCL */
+					 <STM32_PINMUX('H', 6, ANALOG)>; /* I2C5_SDA */
+		};
+	};
+
+	sdmmc2_pins_mx: sdmmc2-mx-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('B', 3, AF10)>, /* SDMMC2_D2 */
+					 <STM32_PINMUX('B', 4, AF10)>, /* SDMMC2_D3 */
+					 <STM32_PINMUX('B', 9, AF10)>, /* SDMMC2_D5 */
+					 <STM32_PINMUX('B', 14, AF10)>, /* SDMMC2_D0 */
+					 <STM32_PINMUX('B', 15, AF10)>, /* SDMMC2_D1 */
+					 <STM32_PINMUX('C', 6, AF10)>, /* SDMMC2_D6 */
+					 <STM32_PINMUX('C', 7, AF10)>, /* SDMMC2_D7 */
+					 <STM32_PINMUX('F', 0, AF10)>, /* SDMMC2_D4 */
+					 <STM32_PINMUX('G', 6, AF10)>; /* SDMMC2_CMD */
+			bias-pull-up;
+			drive-push-pull;
+			slew-rate = <1>;
+		};
+		pins2 {
+			pinmux = <STM32_PINMUX('E', 3, AF10)>; /* SDMMC2_CK */
+			bias-pull-up;
+			drive-push-pull;
+			slew-rate = <2>;
+		};
+	};
+
+	sdmmc2_opendrain_pins_mx: sdmmc2-opendrain-mx-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('B', 3, AF10)>, /* SDMMC2_D2 */
+					 <STM32_PINMUX('B', 4, AF10)>, /* SDMMC2_D3 */
+					 <STM32_PINMUX('B', 9, AF10)>, /* SDMMC2_D5 */
+					 <STM32_PINMUX('B', 14, AF10)>, /* SDMMC2_D0 */
+					 <STM32_PINMUX('B', 15, AF10)>, /* SDMMC2_D1 */
+					 <STM32_PINMUX('C', 6, AF10)>, /* SDMMC2_D6 */
+					 <STM32_PINMUX('C', 7, AF10)>, /* SDMMC2_D7 */
+					 <STM32_PINMUX('F', 0, AF10)>; /* SDMMC2_D4 */
+			bias-pull-up;
+			drive-push-pull;
+			slew-rate = <1>;
+		};
+		pins2 {
+			pinmux = <STM32_PINMUX('E', 3, AF10)>; /* SDMMC2_CK */
+			bias-pull-up;
+			drive-push-pull;
+			slew-rate = <2>;
+		};
+		pins3 {
+			pinmux = <STM32_PINMUX('G', 6, AF10)>; /* SDMMC2_CMD */
+			bias-disable;
+			drive-open-drain;
+			slew-rate = <1>;
+		};
+	};
+
+	sdmmc2_sleep_pins_mx: sdmmc2-sleep-mx-0 {
+		pins {
+			pinmux = <STM32_PINMUX('B', 3, ANALOG)>, /* SDMMC2_D2 */
+					 <STM32_PINMUX('B', 4, ANALOG)>, /* SDMMC2_D3 */
+					 <STM32_PINMUX('B', 9, ANALOG)>, /* SDMMC2_D5 */
+					 <STM32_PINMUX('B', 14, ANALOG)>, /* SDMMC2_D0 */
+					 <STM32_PINMUX('B', 15, ANALOG)>, /* SDMMC2_D1 */
+					 <STM32_PINMUX('C', 6, ANALOG)>, /* SDMMC2_D6 */
+					 <STM32_PINMUX('C', 7, ANALOG)>, /* SDMMC2_D7 */
+					 <STM32_PINMUX('E', 3, ANALOG)>, /* SDMMC2_CK */
+					 <STM32_PINMUX('F', 0, ANALOG)>, /* SDMMC2_D4 */
+					 <STM32_PINMUX('G', 6, ANALOG)>; /* SDMMC2_CMD */
+		};
+	};
+
+	uart4_pins_mx: uart4-mx-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('D', 6, AF8)>; /* UART4_TX */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <0>;
+		};
+		pins2 {
+			pinmux = <STM32_PINMUX('D', 8, AF8)>; /* UART4_RX */
+			bias-pull-up;
+		};
+	};
+
+	uart4_sleep_pins_mx: uart4-sleep-mx-0 {
+		pins {
+			pinmux = <STM32_PINMUX('D', 6, ANALOG)>, /* UART4_TX */
+						<STM32_PINMUX('D', 8, ANALOG)>; /* UART4_RX */
+		};
+	};
+};
diff --git a/arch/arm/boot/dts/st/stm32mp13xx-phycore-som.dtsi b/arch/arm/boot/dts/st/stm32mp13xx-phycore-som.dtsi
new file mode 100644
index 000000000000..ce1b03cbb8fd
--- /dev/null
+++ b/arch/arm/boot/dts/st/stm32mp13xx-phycore-som.dtsi
@@ -0,0 +1,131 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)
+/*
+ * Copyright (C) 2023 PHYTEC Messtechnik GmbH
+ * Authors: Christophe Parant <c.parant@phytec.fr>
+ */
+
+#include "stm32mp13xx-phycore-som-pinctrl.dtsi"
+#include <dt-bindings/gpio/gpio.h>
+#include <dt-bindings/input/input.h>
+#include <dt-bindings/net/ti-dp83867.h>
+
+/ {
+	model = "PHYTEC phyCORE-STM32MP13";
+	compatible = "phytec,stm32mp13-pcl076", "st,stm32mp13";
+
+	aliases {
+		ethernet0 = &ethernet1;
+		serial0 = &uart4;
+		mmc0 = &sdmmc1;
+		mmc1 = &sdmmc2;
+	};
+
+	chosen {
+		stdout-path = "serial0:115200n8";
+	};
+
+	vdd: vdd {
+		compatible = "regulator-fixed";
+		regulator-name = "vdd";
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+		regulator-always-on;
+	};
+
+	vdd_usb: vdd-usb {
+		compatible = "regulator-fixed";
+		regulator-name = "vdd_usb";
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+	};
+};
+
+&dts {
+	status = "okay";
+};
+
+&bsec{
+	status = "okay";
+};
+
+&crc1 {
+	status = "okay";
+};
+
+&i2c5 {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&i2c5_pins_mx>;
+	pinctrl-1 = <&i2c5_sleep_pins_mx>;
+	i2c-scl-rising-time-ns = <185>;
+	i2c-scl-falling-time-ns = <20>;
+	status = "okay";
+	/* spare dmas for other usage */
+	/delete-property/dmas;
+	/delete-property/dma-names;
+
+	i2c5_eeprom: eeprom@52 {
+		compatible = "microchip,24c32", "atmel,24c32";
+		reg = <0x52>;
+		status = "disabled";
+	};
+};
+
+&arm_wdt {
+	timeout-sec = <32>;
+	status = "okay";
+};
+
+&rtc {
+	status = "okay";
+};
+
+&ethernet1{
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&eth1_pins_mx>;
+	pinctrl-1 = <&eth1_sleep_pins_mx>;
+	phy-mode = "rmii";
+	max-speed = <100>;
+	phy-handle = <&phy0_eth1>;
+	nvmem-cells = <&ethernet_mac1_address>;
+	nvmem-cell-names = "mac-address";
+	status = "disabled";
+
+	mdio1 {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		compatible = "snps,dwmac-mdio";
+
+		phy0_eth1: ethernet-phy@1 {
+			compatible = "ethernet-phy-ieee802.3-c22";
+			reg = <1>;
+			interrupt-parent = <&gpioi>;
+			interrupts = <3 IRQ_TYPE_EDGE_FALLING>;
+			wakeup-source;
+		};
+	};
+};
+
+&sdmmc2 {
+	pinctrl-names = "default", "opendrain", "sleep";
+	pinctrl-0 = <&sdmmc2_pins_mx>;
+	pinctrl-1 = <&sdmmc2_opendrain_pins_mx>;
+	pinctrl-2 = <&sdmmc2_sleep_pins_mx>;
+	non-removable;
+	no-sd;
+	no-sdio;
+	st,neg-edge;
+	bus-width = <8>;
+	vmmc-supply = <&vdd>;
+	vqmmc-supply = <&vdd>;
+	mmc-ddr-3_3v;
+	status = "disabled";
+};
+
+&uart4 {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&uart4_pins_mx>;
+	pinctrl-1 = <&uart4_sleep_pins_mx>;
+	/delete-property/dmas;
+	/delete-property/dma-names;
+	status = "okay";
+};
diff --git a/arch/arm/boot/dts/st/stm32mp153a-phyboard-sargas-rdk-nand-a7-examples.dts b/arch/arm/boot/dts/st/stm32mp153a-phyboard-sargas-rdk-nand-a7-examples.dts
new file mode 100644
index 000000000000..9d710a73cac0
--- /dev/null
+++ b/arch/arm/boot/dts/st/stm32mp153a-phyboard-sargas-rdk-nand-a7-examples.dts
@@ -0,0 +1,27 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)
+/*
+ * Copyright (C) 2020 PHYTEC Messtechnik GmbH
+ * Authors: Dom Vovard <dom.vovard@linrt.com>
+ *	    Christophe Parant <c.parant@phytec.fr>
+ */
+
+/dts-v1/;
+
+#include "stm32mp153a-phyboard-sargas-rdk-nand.dts"
+
+/ {
+	model = "PHYTEC phyBOARD-Sargas STM32MP153A with NAND configured to run Linux A7 examples";
+	compatible = "stm32mp153a-phyboard-sargas-rdk-nand-a7-examples",
+		     "phytec,stm32mp153a-phyboard-sargas-rdk-nand",
+		     "phytec,stm32mp153a-phycore-som", "st,stm32mp153";
+};
+
+/* device tree specificities to run Linux-A7-examples */
+&gpio_keys {
+	enter {
+		status = "disabled"; //disable PA14 (key enter) as input event
+	};
+	home {
+		status = "disabled"; //disable PA13 (key home) as input event
+	};
+};
diff --git a/arch/arm/boot/dts/st/stm32mp153a-phyboard-sargas-rdk-nand-m4-examples.dts b/arch/arm/boot/dts/st/stm32mp153a-phyboard-sargas-rdk-nand-m4-examples.dts
new file mode 100644
index 000000000000..74a1176ae497
--- /dev/null
+++ b/arch/arm/boot/dts/st/stm32mp153a-phyboard-sargas-rdk-nand-m4-examples.dts
@@ -0,0 +1,176 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)
+/*
+ * Copyright (C) 2020 PHYTEC Messtechnik GmbH
+ * Authors: Dom Vovard <dom.vovard@linrt.com>
+ *	    Christophe Parant <c.parant@phytec.fr>
+ */
+
+/dts-v1/;
+
+#include "stm32mp153a-phyboard-sargas-rdk-nand.dts"
+
+/ {
+	model = "PHYTEC phyBOARD-Sargas STM32MP153A with NAND configured to run Cube M4 examples";
+	compatible = "stm32mp153a-phyboard-sargas-rdk-nand-m4-examples",
+		     "phytec,stm32mp153a-phycore-som", "st,stm32mp153";
+};
+
+&adc {
+	status = "disabled";
+};
+
+&dac {
+	status = "disabled";
+};
+
+&dma2 {
+	status = "disabled";
+};
+
+&dmamux1 {
+	dma-masters = <&dma1>;
+	dma-channels = <8>;
+};
+
+&spi1 {
+	status = "disabled";
+};
+
+&i2c1 {
+	status = "disabled";
+};
+
+&timers1 {
+	status = "disabled";
+};
+
+&usart3 {
+	status = "disabled";
+};
+
+&gpio_keys {
+	home {
+		status = "disabled"; //disable PA13 (key home) as Linux input event
+	};
+	enter {
+		status = "disabled"; //disable PA14 (key enter) as Linux input event
+	};
+};
+
+&vrefbuf {
+	status = "okay";
+};
+
+&m4_adc {
+	vref-supply = <&vrefbuf>;
+	status = "okay";
+};
+
+&m4_dac {
+	vref-supply = <&vrefbuf>;
+	status = "okay";
+};
+
+&m4_dma2 {
+	status = "okay";
+};
+
+&m4_crc2 {
+	status = "okay";
+};
+
+&m4_cryp2 {
+	status = "okay";
+};
+
+&m4_hash2 {
+	status = "okay";
+};
+
+&m4_i2c1 {
+	pinctrl-names = "rproc_default";
+	pinctrl-0 = <&m4_i2c1_pins_a>;
+	status = "okay";
+};
+
+&m4_rng2 {
+	status = "okay";
+};
+
+&m4_rproc {
+	m4_system_resources {
+		status = "okay";
+
+		button {
+			compatible = "rproc-srm-dev";
+			interrupt-parent = <&gpioa>;
+			interrupts = <14 2>;
+			interrupt-names = "irq";
+			status = "okay";
+		};
+
+		m4_led: m4-led {
+			compatible = "rproc-srm-dev";
+			pinctrl-names = "default";
+			pinctrl-0 = <&m4_led_red_pin>;
+			status = "okay";
+		};
+	};
+};
+
+&m4_spi1 {
+	pinctrl-names = "rproc_default";
+	pinctrl-0 = <&m4_spi1_pins_a>;
+	status = "okay";
+};
+
+
+&m4_timers1 {
+	pinctrl-names = "rproc_default";
+	pinctrl-0 = <&m4_tim1_pwm_pins>;
+	status = "okay";
+};
+
+&m4_usart3 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&m4_usart3_pins_a>;
+	status = "okay";
+};
+
+&pinctrl {
+	m4_tim1_pwm_pins: m4-tim1-pwm-0 {
+		pins {
+			pinmux = <STM32_PINMUX('E', 14, RSVD)>; /* TIM1_CH4 */
+		};
+	};
+
+	m4_i2c1_pins_a: m4-i2c1-0 {
+		pins {
+			pinmux = <STM32_PINMUX('F', 14, RSVD)>, /* I2C1_SCL */
+				 <STM32_PINMUX('F', 15, RSVD)>; /* I2C1_SDA */
+		};
+	};
+
+	m4_led_red_pin: m4-led-red-0 {
+		pins {
+			pinmux = <STM32_PINMUX('A', 13, RSVD)>;
+		};
+	};
+
+	m4_usart3_pins_a: m4-usart3-0 {
+		pins {
+			pinmux = <STM32_PINMUX('B', 12, RSVD)>, /* USART3_RX */
+				 <STM32_PINMUX('B', 10, RSVD)>; /* USART3_TX */
+		};
+	};
+};
+
+&pinctrl_z {
+	m4_spi1_pins_a: m4-spi1-0 {
+		pins {
+			pinmux = <STM32_PINMUX('Z', 0, RSVD)>, /* SPI1_SCK */
+				 <STM32_PINMUX('Z', 1, RSVD)>, /* SPI1_MISO */
+				 <STM32_PINMUX('Z', 2, RSVD)>; /* SPI1_MOSI */
+		};
+	};
+};
diff --git a/arch/arm/boot/dts/st/stm32mp153a-phyboard-sargas-rdk-nand.dts b/arch/arm/boot/dts/st/stm32mp153a-phyboard-sargas-rdk-nand.dts
new file mode 100644
index 000000000000..dc701b6941d6
--- /dev/null
+++ b/arch/arm/boot/dts/st/stm32mp153a-phyboard-sargas-rdk-nand.dts
@@ -0,0 +1,48 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)
+/*
+ * Copyright (C) 2020 PHYTEC Messtechnik GmbH
+ * Authors: Dom Vovard <dom.vovard@linrt.com>
+ *	    Christophe Parant <c.parant@phytec.fr>
+ */
+
+/dts-v1/;
+
+#include "stm32mp153.dtsi"
+#include "stm32mp15xa.dtsi"
+#include "stm32mp153a-phycore-scmi.dtsi"
+#include "stm32mp15xx-phycore-som.dtsi"
+#include "stm32mp15xx-phyboard-sargas.dtsi"
+
+/ {
+	model = "PHYTEC phyBOARD-Sargas STM32MP153A with NAND";
+	compatible = "phytec,stm32mp153a-phyboard-sargas-rdk-nand",
+		     "phytec,stm32mp153a-phycore-som", "st,stm32mp153";
+
+	memory@c0000000 {
+		reg = <0xc0000000 0x20000000>;
+	};
+};
+
+&dts {
+	status = "okay";
+};
+
+&i2c4_rtc {
+	status = "okay";
+};
+
+&i2c4_eeprom {
+	status = "okay";
+};
+
+&qspi {
+	status = "okay";
+};
+
+&fmc {
+	status = "okay";
+};
+
+&sdmmc2 {
+	status = "disabled";
+};
diff --git a/arch/arm/boot/dts/st/stm32mp153a-phycore-scmi.dtsi b/arch/arm/boot/dts/st/stm32mp153a-phycore-scmi.dtsi
new file mode 100644
index 000000000000..b58ced9aa69f
--- /dev/null
+++ b/arch/arm/boot/dts/st/stm32mp153a-phycore-scmi.dtsi
@@ -0,0 +1,16 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)
+/*
+ * Copyright (C) 2025 PHYTEC Messtechnik GmbH
+ * Authors: Christophe Parant <c.parant@phytec.fr>
+ */
+
+#include "stm32mp15xx-phycore-scmi.dtsi"
+
+/ {
+	reserved-memory {
+		optee@de000000 {
+			reg = <0xde000000 0x2000000>;
+			no-map;
+		};
+	};
+};
diff --git a/arch/arm/boot/dts/st/stm32mp157c-phyboard-sargas-rdk-a7-examples.dts b/arch/arm/boot/dts/st/stm32mp157c-phyboard-sargas-rdk-a7-examples.dts
new file mode 100644
index 000000000000..4c46b1a5637a
--- /dev/null
+++ b/arch/arm/boot/dts/st/stm32mp157c-phyboard-sargas-rdk-a7-examples.dts
@@ -0,0 +1,27 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)
+/*
+ * Copyright (C) 2020 PHYTEC Messtechnik GmbH
+ * Authors: Dom Vovard <dom.vovard@linrt.com>
+ *	    Christophe Parant <c.parant@phytec.fr>
+ */
+
+/dts-v1/;
+
+#include "stm32mp157c-phyboard-sargas-rdk.dts"
+
+/ {
+	model = "PHYTEC phyBOARD-Sargas STM32MP157C with eMMC configured to run Linux A7 examples";
+	compatible = "stm32mp157c-phyboard-sargas-rdk-emmc-a7-examples",
+		     "phytec,stm32mp157c-phyboard-sargas-rdk-emmc",
+		     "phytec,stm32mp157c-phycore-som", "st,stm32mp157";
+};
+
+/* device tree specificities to run Linux-A7-examples */
+&gpio_keys {
+	enter {
+		status = "disabled"; //disable PA14 (key enter) as input event
+	};
+	home {
+		status = "disabled"; //disable PA13 (key home) as input event
+	};
+};
diff --git a/arch/arm/boot/dts/st/stm32mp157c-phyboard-sargas-rdk-m4-examples.dts b/arch/arm/boot/dts/st/stm32mp157c-phyboard-sargas-rdk-m4-examples.dts
new file mode 100644
index 000000000000..5fbb4a2745cf
--- /dev/null
+++ b/arch/arm/boot/dts/st/stm32mp157c-phyboard-sargas-rdk-m4-examples.dts
@@ -0,0 +1,177 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)
+/*
+ * Copyright (C) 2020 PHYTEC Messtechnik GmbH
+ * Authors: Dom Vovard <dom.vovard@linrt.com>
+ *	    Christophe Parant <c.parant@phytec.fr>
+ */
+
+/dts-v1/;
+
+#include "stm32mp157c-phyboard-sargas-rdk.dts"
+
+/ {
+	model = "PHYTEC phyBOARD-Sargas STM32MP157C with eMMC configured to run Cube M4 examples";
+	compatible = "stm32mp157c-phyboard-sargas-rdk-emmc-m4-examples",
+		     "phytec,stm32mp157c-phyboard-sargas-rdk-emmc",
+		     "phytec,stm32mp157c-phycore-som", "st,stm32mp157";
+};
+
+&adc {
+	status = "disabled";
+};
+
+&dac {
+	status = "disabled";
+};
+
+&dma2 {
+	status = "disabled";
+};
+
+&dmamux1 {
+	dma-masters = <&dma1>;
+	dma-channels = <8>;
+};
+
+&spi1 {
+	status = "disabled";
+};
+
+&i2c1 {
+	status = "disabled";
+};
+
+&timers1 {
+	status = "disabled";
+};
+
+&usart3 {
+	status = "disabled";
+};
+
+&gpio_keys {
+	home {
+		status = "disabled"; //disable PA13 (key home) as Linux input event
+	};
+	enter {
+		status = "disabled"; //disable PA14 (key enter) as Linux input event
+	};
+};
+
+&vrefbuf {
+	status = "okay";
+};
+
+&m4_adc {
+	vref-supply = <&vrefbuf>;
+	status = "okay";
+};
+
+&m4_dac {
+	vref-supply = <&vrefbuf>;
+	status = "okay";
+};
+
+&m4_dma2 {
+	status = "okay";
+};
+
+&m4_crc2 {
+	status = "okay";
+};
+
+&m4_cryp2 {
+	status = "okay";
+};
+
+&m4_hash2 {
+	status = "okay";
+};
+
+&m4_i2c1 {
+	pinctrl-names = "rproc_default";
+	pinctrl-0 = <&m4_i2c1_pins_a>;
+	status = "okay";
+};
+
+&m4_rng2 {
+	status = "okay";
+};
+
+&m4_rproc {
+	m4_system_resources {
+		status = "okay";
+
+		button {
+			compatible = "rproc-srm-dev";
+			interrupt-parent = <&gpioa>;
+			interrupts = <14 2>;
+			interrupt-names = "irq";
+			status = "okay";
+		};
+
+		m4_led: m4-led {
+			compatible = "rproc-srm-dev";
+			pinctrl-names = "default";
+			pinctrl-0 = <&m4_led_red_pin>;
+			status = "okay";
+		};
+	};
+};
+
+&m4_spi1 {
+	pinctrl-names = "rproc_default";
+	pinctrl-0 = <&m4_spi1_pins_a>;
+	status = "okay";
+};
+
+
+&m4_timers1 {
+	pinctrl-names = "rproc_default";
+	pinctrl-0 = <&m4_tim1_pwm_pins>;
+	status = "okay";
+};
+
+&m4_usart3 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&m4_usart3_pins_a>;
+	status = "okay";
+};
+
+&pinctrl {
+	m4_tim1_pwm_pins: m4-tim1-pwm-0 {
+		pins {
+			pinmux = <STM32_PINMUX('E', 14, RSVD)>; /* TIM1_CH4 */
+		};
+	};
+
+	m4_i2c1_pins_a: m4-i2c1-0 {
+		pins {
+			pinmux = <STM32_PINMUX('F', 14, RSVD)>, /* I2C1_SCL */
+			<STM32_PINMUX('F', 15, RSVD)>; /* I2C1_SDA */
+		};
+	};
+
+	m4_led_red_pin: m4-led-red-0 {
+		pins {
+			pinmux = <STM32_PINMUX('A', 13, RSVD)>;
+		};
+	};
+
+	m4_usart3_pins_a: m4-usart3-0 {
+		pins {
+			pinmux = <STM32_PINMUX('B', 12, RSVD)>, /* USART3_RX */
+				 <STM32_PINMUX('B', 10, RSVD)>; /* USART3_TX */
+		};
+	};
+};
+
+&pinctrl_z {
+	m4_spi1_pins_a: m4-spi1-0 {
+		pins {
+			pinmux = <STM32_PINMUX('Z', 0, RSVD)>, /* SPI1_SCK */
+				 <STM32_PINMUX('Z', 1, RSVD)>, /* SPI1_MISO */
+				 <STM32_PINMUX('Z', 2, RSVD)>; /* SPI1_MOSI */
+		};
+	};
+};
diff --git a/arch/arm/boot/dts/st/stm32mp157c-phyboard-sargas-rdk.dts b/arch/arm/boot/dts/st/stm32mp157c-phyboard-sargas-rdk.dts
new file mode 100644
index 000000000000..3cbb33fc6400
--- /dev/null
+++ b/arch/arm/boot/dts/st/stm32mp157c-phyboard-sargas-rdk.dts
@@ -0,0 +1,64 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)
+/*
+ * Copyright (C) 2020 PHYTEC Messtechnik GmbH
+ * Authors: Dom Vovard <dom.vovard@linrt.com>
+ *	    Christophe Parant <c.parant@phytec.fr>
+ */
+
+/dts-v1/;
+
+#include "stm32mp157.dtsi"
+#include "stm32mp15xc.dtsi"
+#include "stm32mp157c-phycore-scmi.dtsi"
+#include "stm32mp15xx-phycore-som.dtsi"
+#include "stm32mp15xx-phyboard-sargas.dtsi"
+
+/ {
+	model = "PHYTEC phyBOARD-Sargas STM32MP157C with eMMC";
+	compatible = "phytec,stm32mp157c-phyboard-sargas-rdk-emmc",
+		     "phytec,stm32mp157c-phycore-som", "st,stm32mp157";
+
+	memory@c0000000 {
+		reg = <0xc0000000 0x40000000>;
+	};
+
+	reserved-memory {
+		gpu_reserved: gpu@f6000000 {
+			reg = <0xf6000000 0x8000000>;
+			no-map;
+		};
+	};
+};
+
+&dts {
+	status = "okay";
+};
+
+&gpu {
+	status = "okay";
+	contiguous-area = <&gpu_reserved>;
+};
+
+&i2c4_rtc {
+	status = "okay";
+};
+
+&i2c4_eeprom {
+	status = "okay";
+};
+
+&qspi {
+	status = "okay";
+};
+
+&fmc {
+	status = "disabled";
+};
+
+&sdmmc2 {
+	status = "okay";
+};
+
+&cryp1 {
+	status = "okay";
+};
diff --git a/arch/arm/boot/dts/st/stm32mp157c-phycore-scmi.dtsi b/arch/arm/boot/dts/st/stm32mp157c-phycore-scmi.dtsi
new file mode 100644
index 000000000000..ed74bad3843f
--- /dev/null
+++ b/arch/arm/boot/dts/st/stm32mp157c-phycore-scmi.dtsi
@@ -0,0 +1,25 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)
+/*
+ * Copyright (C) 2025 PHYTEC Messtechnik GmbH
+ * Authors: Christophe Parant <c.parant@phytec.fr>
+ */
+
+#include "stm32mp15xx-phycore-scmi.dtsi"
+
+/ {
+	reserved-memory {
+		optee@de000000 {
+			reg = <0xfe000000 0x2000000>;
+			no-map;
+		};
+	};
+};
+
+&cryp1 {
+	clocks = <&scmi_clk CK_SCMI_CRYP1>;
+	resets = <&scmi_reset RST_SCMI_CRYP1>;
+};
+
+&dsi {
+	clocks = <&rcc DSI>, <&scmi_clk CK_SCMI_HSE>, <&rcc DSI_PX>;
+};
diff --git a/arch/arm/boot/dts/st/stm32mp157c-phycore-stm32mp1-3.dts b/arch/arm/boot/dts/st/stm32mp157c-phycore-stm32mp1-3.dts
deleted file mode 100644
index 28d7203264ce..000000000000
--- a/arch/arm/boot/dts/st/stm32mp157c-phycore-stm32mp1-3.dts
+++ /dev/null
@@ -1,60 +0,0 @@
-// SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)
-/*
- * Copyright (C) Phytec GmbH 2019-2020 - All Rights Reserved
- * Author: Dom VOVARD <dom.vovard@linrt.com>.
- */
-
-/dts-v1/;
-
-#include <dt-bindings/pinctrl/stm32-pinfunc.h>
-#include "stm32mp157.dtsi"
-#include "stm32mp15xc.dtsi"
-#include "stm32mp15xxac-pinctrl.dtsi"
-#include "stm32mp157c-phycore-stm32mp15-som.dtsi"
-
-/ {
-	model = "PHYTEC phyCORE-STM32MP1-3 Dev Board";
-	compatible = "phytec,phycore-stm32mp1-3",
-		     "phytec,phycore-stm32mp157c-som", "st,stm32mp157";
-
-	aliases {
-		mmc0 = &sdmmc1;
-		mmc1 = &sdmmc2;
-		mmc2 = &sdmmc3;
-		serial0 = &uart4;
-		serial1 = &usart3;
-		serial2 = &usart1;
-	};
-};
-
-&cryp1 {
-	status = "okay";
-};
-
-&dts {
-	status = "okay";
-};
-
-&fmc {
-	status = "disabled";
-};
-
-&gpu {
-	status = "okay";
-};
-
-&i2c4_eeprom {
-	status = "okay";
-};
-
-&i2c4_rtc {
-	status = "okay";
-};
-
-&qspi {
-	status = "okay";
-};
-
-&sdmmc2 {
-	status = "okay";
-};
diff --git a/arch/arm/boot/dts/st/stm32mp157c-phycore-stm32mp15-som.dtsi b/arch/arm/boot/dts/st/stm32mp157c-phycore-stm32mp15-som.dtsi
deleted file mode 100644
index 4e8b2d2b30c7..000000000000
--- a/arch/arm/boot/dts/st/stm32mp157c-phycore-stm32mp15-som.dtsi
+++ /dev/null
@@ -1,577 +0,0 @@
-// SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)
-/*
- * Copyright (C) 2022-2023 Steffen Trumtrar <kernel@pengutronix.de>
- * Copyright (C) Phytec GmbH 2019-2020 - All Rights Reserved
- * Author: Dom VOVARD <dom.vovard@linrt.com>.
- */
-
-#include <dt-bindings/gpio/gpio.h>
-#include <dt-bindings/input/input.h>
-#include <dt-bindings/interrupt-controller/arm-gic.h>
-#include <dt-bindings/interrupt-controller/irq.h>
-#include <dt-bindings/leds/common.h>
-#include <dt-bindings/leds/leds-pca9532.h>
-#include <dt-bindings/mfd/st,stpmic1.h>
-#include <dt-bindings/net/ti-dp83867.h>
-#include "stm32mp15-pinctrl.dtsi"
-
-/ {
-	model = "PHYTEC phyCORE-STM32MP15 SOM";
-	compatible = "phytec,phycore-stm32mp157c-som", "st,stm32mp157";
-
-	aliases {
-		ethernet0 = &ethernet0;
-		rtc0 = &i2c4_rtc;
-		rtc1 = &rtc;
-	};
-
-	chosen {
-		stdout-path = "serial0:115200n8";
-	};
-
-	gpio-keys {
-		compatible = "gpio-keys";
-
-		key-home {
-			label = "Home";
-			gpios = <&gpioa 13 GPIO_ACTIVE_LOW>;
-			linux,code = <KEY_HOME>;
-		};
-
-		key-enter {
-			label = "Enter";
-			gpios = <&gpioa 14 GPIO_ACTIVE_LOW>;
-			linux,code = <KEY_ENTER>;
-		};
-	};
-
-	reserved-memory {
-		#address-cells = <1>;
-		#size-cells = <1>;
-		ranges;
-
-		retram: retram@38000000 {
-			compatible = "shared-dma-pool";
-			reg = <0x38000000 0x10000>;
-			no-map;
-		};
-
-		mcuram: mcuram@30000000 {
-			compatible = "shared-dma-pool";
-			reg = <0x30000000 0x40000>;
-			no-map;
-		};
-
-		mcuram2: mcuram2@10000000 {
-			compatible = "shared-dma-pool";
-			reg = <0x10000000 0x40000>;
-			no-map;
-		};
-
-		vdev0vring0: vdev0vring0@10040000 {
-			compatible = "shared-dma-pool";
-			reg = <0x10040000 0x1000>;
-			no-map;
-		};
-
-		vdev0vring1: vdev0vring1@10041000 {
-			compatible = "shared-dma-pool";
-			reg = <0x10041000 0x1000>;
-			no-map;
-		};
-
-		vdev0buffer: vdev0buffer@10042000 {
-			compatible = "shared-dma-pool";
-			reg = <0x10042000 0x4000>;
-			no-map;
-		};
-	};
-
-	sound {
-		compatible = "audio-graph-card";
-		label = "STM32MP1-PHYCORE";
-		routing =
-			"Playback", "MCLK", /* Set a route between "MCLK" and "playback" widgets */
-			"Capture", "MCLK";
-		dais = <&sai2b_port>,
-		       <&sai2a_port>;
-	};
-
-	regulator_vin: regulator {
-		compatible = "regulator-fixed";
-		regulator-name = "vin";
-		regulator-min-microvolt = <5000000>;
-		regulator-max-microvolt = <5000000>;
-		regulator-always-on;
-	};
-};
-
-&ethernet0 {
-	pinctrl-0 = <&ethernet0_rgmii_pins_d>;
-	pinctrl-1 = <&ethernet0_rgmii_sleep_pins_d>;
-	pinctrl-names = "default", "sleep";
-	phy-mode = "rgmii-id";
-	max-speed = <1000>;
-	phy-handle = <&phy0>;
-	st,eth-clk-sel;
-	status = "okay";
-
-	mdio {
-		#address-cells = <1>;
-		#size-cells = <0>;
-		compatible = "snps,dwmac-mdio";
-
-		phy0: ethernet-phy@1 {
-			compatible = "ethernet-phy-ieee802.3-c22";
-			reg = <1>;
-			interrupt-parent = <&gpiog>;
-			interrupts = <12 IRQ_TYPE_EDGE_FALLING>;
-			ti,rx-internal-delay = <DP83867_RGMIIDCTL_2_00_NS>;
-			ti,tx-internal-delay = <DP83867_RGMIIDCTL_2_00_NS>;
-			ti,fifo-depth = <DP83867_PHYCR_FIFO_DEPTH_4_B_NIB>;
-			ti,min-output-impedance;
-			enet-phy-lane-no-swap;
-			ti,clk-output-sel = <DP83867_CLK_O_SEL_OFF>;
-		};
-	};
-};
-
-&i2c1 {
-	pinctrl-names = "default", "sleep";
-	pinctrl-0 = <&i2c1_pins_b>;
-	pinctrl-1 = <&i2c1_sleep_pins_b>;
-	i2c-scl-rising-time-ns = <100>;
-	i2c-scl-falling-time-ns = <7>;
-	status = "okay";
-
-	codec@18 {
-		compatible = "ti,tlv320aic3007";
-		reg = <0x18>;
-		#sound-dai-cells = <0>;
-
-		ai3x-micbias-vg = <2>;
-
-		AVDD-supply = <&v3v3>;
-		IOVDD-supply = <&v3v3>;
-		DRVDD-supply = <&v3v3>;
-		DVDD-supply = <&v1v8_audio>;
-
-		clocks = <&sai2b>;
-
-		port {
-			#address-cells = <1>;
-			#size-cells = <0>;
-
-			tlv320_tx_endpoint: endpoint@0 {
-				reg = <0>;
-				remote-endpoint = <&sai2b_endpoint>;
-				frame-master;
-				bitclock-master;
-			};
-
-			tlv320_rx_endpoint: endpoint@1 {
-				reg = <1>;
-				remote-endpoint = <&sai2a_endpoint>;
-				frame-master;
-				bitclock-master;
-			};
-		};
-	};
-
-	touch@44 {
-		compatible = "st,stmpe811";
-		reg = <0x44>;
-		interrupts = <3 IRQ_TYPE_EDGE_FALLING>;
-		interrupt-parent = <&gpioi>;
-		vio-supply = <&v3v3>;
-		vcc-supply = <&v3v3>;
-
-		touchscreen {
-			compatible = "st,stmpe-ts";
-			st,sample-time = <4>;
-			st,mod-12b = <1>;
-			st,ref-sel = <0>;
-			st,adc-freq = <1>;
-			st,ave-ctrl = <1>;
-			st,touch-det-delay = <2>;
-			st,settling = <2>;
-			st,fraction-z = <7>;
-			st,i-drive = <1>;
-		};
-	};
-
-	leds@62 {
-		compatible = "nxp,pca9533";
-		reg = <0x62>;
-
-		led-0 {
-			color = <LED_COLOR_ID_RED>;
-			function = LED_FUNCTION_POWER;
-			type = <PCA9532_TYPE_LED>;
-		};
-
-		led-1 {
-			color = <LED_COLOR_ID_GREEN>;
-			function = LED_FUNCTION_POWER;
-			type = <PCA9532_TYPE_LED>;
-		};
-
-		led-2 {
-			color = <LED_COLOR_ID_BLUE>;
-			function = LED_FUNCTION_HEARTBEAT;
-			type = <PCA9532_TYPE_LED>;
-			linux,default-trigger = "heartbeat";
-		};
-	};
-};
-
-&i2c4 {
-	pinctrl-names = "default", "sleep";
-	pinctrl-0 = <&i2c4_pins_a>;
-	pinctrl-1 = <&i2c4_sleep_pins_a>;
-	i2c-scl-rising-time-ns = <185>;
-	i2c-scl-falling-time-ns = <20>;
-	status = "okay";
-
-	pmic@33 {
-		compatible = "st,stpmic1";
-		reg = <0x33>;
-		interrupts-extended = <&gpioa 0 IRQ_TYPE_EDGE_FALLING>;
-		interrupt-controller;
-		#interrupt-cells = <2>;
-
-		regulators {
-			compatible = "st,stpmic1-regulators";
-			buck1-supply = <&regulator_vin>;
-			buck2-supply = <&regulator_vin>;
-			buck3-supply = <&regulator_vin>;
-			buck4-supply = <&regulator_vin>;
-			ldo1-supply = <&v3v3>;
-			ldo2-supply = <&v3v3>;
-			ldo3-supply = <&vdd_ddr>;
-			ldo4-supply = <&regulator_vin>;
-			ldo5-supply = <&v3v3>;
-			ldo6-supply = <&v3v3>;
-			boost-supply = <&regulator_vin>;
-			pwr_sw1-supply = <&bst_out>;
-			pwr_sw2-supply = <&bst_out>;
-
-			vddcore: buck1 {
-				regulator-name = "vddcore";
-				regulator-min-microvolt = <1200000>;
-				regulator-max-microvolt = <1350000>;
-				regulator-always-on;
-				regulator-initial-mode = <0>;
-			};
-
-			vdd_ddr: buck2 {
-				regulator-name = "vdd_ddr";
-				regulator-min-microvolt = <1350000>;
-				regulator-max-microvolt = <1350000>;
-				regulator-always-on;
-				regulator-initial-mode = <0>;
-			};
-
-			vdd: buck3 {
-				regulator-name = "vdd";
-				regulator-min-microvolt = <3300000>;
-				regulator-max-microvolt = <3300000>;
-				regulator-always-on;
-				st,mask-reset;
-				regulator-initial-mode = <0>;
-			};
-
-			v3v3: buck4 {
-				regulator-name = "v3v3";
-				regulator-min-microvolt = <3300000>;
-				regulator-max-microvolt = <3300000>;
-				regulator-always-on;
-				regulator-initial-mode = <0>;
-			};
-
-			v1v8_audio: ldo1 {
-				regulator-name = "v1v8_audio";
-				regulator-min-microvolt = <1800000>;
-				regulator-max-microvolt = <1800000>;
-				regulator-always-on;
-				interrupts = <IT_CURLIM_LDO1 0>;
-
-			};
-
-			vdd_eth_2v5: ldo2 {
-				regulator-name = "dd_eth_2v5";
-				regulator-min-microvolt = <2500000>;
-				regulator-max-microvolt = <2500000>;
-				regulator-always-on;
-				interrupts = <IT_CURLIM_LDO2 0>;
-
-			};
-
-			vtt_ddr: ldo3 {
-				regulator-name = "vtt_ddr";
-				regulator-min-microvolt = <500000>;
-				regulator-max-microvolt = <750000>;
-				regulator-always-on;
-				regulator-over-current-protection;
-			};
-
-			vdd_usb: ldo4 {
-				regulator-name = "vdd_usb";
-				interrupts = <IT_CURLIM_LDO4 0>;
-			};
-
-			vdda: ldo5 {
-				regulator-name = "vdda";
-				regulator-min-microvolt = <2900000>;
-				regulator-max-microvolt = <2900000>;
-				interrupts = <IT_CURLIM_LDO5 0>;
-				regulator-boot-on;
-			};
-
-			vdd_eth_1v0: ldo6 {
-				regulator-name = "vdd_eth_1v0";
-				regulator-min-microvolt = <1000000>;
-				regulator-max-microvolt = <1000000>;
-				regulator-always-on;
-				interrupts = <IT_CURLIM_LDO6 0>;
-
-			};
-
-			vref_ddr: vref_ddr {
-				regulator-name = "vref_ddr";
-				regulator-always-on;
-			};
-
-			bst_out: boost {
-				regulator-name = "bst_out";
-				interrupts = <IT_OCP_BOOST 0>;
-			};
-
-			vbus_otg: pwr_sw1 {
-				regulator-name = "vbus_otg";
-				interrupts = <IT_OCP_OTG 0>;
-				regulator-active-discharge = <1>;
-			};
-
-			vbus_sw: pwr_sw2 {
-				regulator-name = "vbus_sw";
-				interrupts = <IT_OCP_SWOUT 0>;
-				regulator-active-discharge = <1>;
-			};
-		};
-
-		onkey {
-			compatible = "st,stpmic1-onkey";
-			interrupts = <IT_PONKEY_F 0>,
-				     <IT_PONKEY_R 0>;
-			interrupt-names = "onkey-falling",
-					  "onkey-rising";
-			power-off-time-sec = <10>;
-		};
-
-		watchdog {
-			compatible = "st,stpmic1-wdt";
-		};
-	};
-
-	i2c4_eeprom: eeprom@50 {
-		compatible = "microchip,24c32",
-			     "atmel,24c32";
-		reg = <0x50>;
-	};
-
-	i2c4_rtc: rtc@52 {
-		compatible = "microcrystal,rv3028";
-		reg = <0x52>;
-	};
-};
-
-&ipcc {
-	status = "okay";
-};
-
-&iwdg2 {
-	timeout-sec = <32>;
-	status = "okay";
-};
-
-&m_can2 {
-	pinctrl-names = "default", "sleep";
-	pinctrl-0 = <&m_can2_pins_a>;
-	pinctrl-1 = <&m_can2_sleep_pins_a>;
-	status = "okay";
-};
-
-&m4_rproc {
-	memory-region = <&retram>, <&mcuram>, <&mcuram2>, <&vdev0vring0>,
-			<&vdev0vring1>, <&vdev0buffer>;
-	mboxes = <&ipcc 0>, <&ipcc 1>, <&ipcc 2>, <&ipcc 3>;
-	mbox-names = "vq0", "vq1", "shutdown", "detach";
-	interrupt-parent = <&exti>;
-	interrupts = <68 1>;
-	status = "okay";
-};
-
-&pwr_regulators {
-	vdd-supply = <&vdd>;
-	vdd_3v3_usbfs-supply = <&vdd_usb>;
-};
-
-&qspi {
-	pinctrl-names = "default", "sleep";
-	pinctrl-0 = <&qspi_clk_pins_a &qspi_bk1_pins_a>;
-	pinctrl-1 = <&qspi_clk_sleep_pins_a &qspi_bk1_sleep_pins_a>;
-	status = "okay";
-
-	flash0: flash@0 {
-		compatible = "winbond,w25q128", "jedec,spi-nor";
-		reg = <0>;
-		spi-rx-bus-width = <4>;
-		spi-max-frequency = <50000000>;
-		m25p,fast-read;
-		#address-cells = <1>;
-		#size-cells = <1>;
-	};
-};
-
-&rng1 {
-	status = "okay";
-};
-
-&rtc {
-	status = "okay";
-};
-
-&sai2 {
-	clocks = <&rcc SAI2>, <&rcc PLL3_Q>, <&rcc PLL3_R>;
-	clock-names = "pclk", "x8k", "x11k";
-	pinctrl-names = "default", "sleep";
-	pinctrl-0 = <&sai2a_pins_b>, <&sai2b_pins_d>;
-	pinctrl-1 = <&sai2a_sleep_pins_b>, <&sai2b_sleep_pins_d>;
-	status = "okay";
-};
-
-&sai2a {
-	dma-names = "rx";
-	st,sync = <&sai2b 2>;
-	clocks = <&rcc SAI2_K>, <&sai2b>;
-	clock-names = "sai_ck", "MCLK";
-	#clock-cells = <0>;
-
-	sai2a_port: port {
-		sai2a_endpoint: endpoint {
-			remote-endpoint = <&tlv320_rx_endpoint>;
-			mclk-fs = <256>;
-			dai-tdm-slot-num = <2>;
-			dai-tdm-slot-width = <16>;
-		};
-	};
-};
-
-&sai2b {
-	dma-names = "tx";
-	#clock-cells = <0>;
-
-	sai2b_port: port {
-		sai2b_endpoint: endpoint {
-			remote-endpoint = <&tlv320_tx_endpoint>;
-			mclk-fs = <256>;
-			dai-tdm-slot-num = <2>;
-			dai-tdm-slot-width = <16>;
-		};
-	};
-};
-
-&sdmmc1 {
-	pinctrl-names = "default", "opendrain", "sleep";
-	pinctrl-0 = <&sdmmc1_b4_pins_b>;
-	pinctrl-1 = <&sdmmc1_b4_od_pins_b>;
-	pinctrl-2 = <&sdmmc1_b4_sleep_pins_b>;
-	cd-gpios = <&gpiof 3 GPIO_ACTIVE_LOW>;
-	disable-wp;
-	st,neg-edge;
-	bus-width = <4>;
-	vmmc-supply = <&v3v3>;
-	status = "okay";
-};
-
-&sdmmc2 {
-	pinctrl-names = "default", "opendrain", "sleep";
-	pinctrl-0 = <&sdmmc2_b4_pins_a &sdmmc2_d47_pins_e>;
-	pinctrl-1 = <&sdmmc2_b4_od_pins_a &sdmmc2_d47_pins_e>;
-	pinctrl-2 = <&sdmmc2_b4_sleep_pins_a &sdmmc2_d47_sleep_pins_e>;
-	non-removable;
-	no-sd;
-	no-sdio;
-	st,neg-edge;
-	bus-width = <8>;
-	vmmc-supply = <&v3v3>;
-	vqmmc-supply = <&v3v3>;
-	mmc-ddr-3_3v;
-};
-
-&spi1 {
-	pinctrl-names = "default", "sleep";
-	pinctrl-0 = <&spi1_pins_a>;
-	pinctrl-1 = <&spi1_sleep_pins_a>;
-	cs-gpios = <&gpioz 3 0>;
-	status = "okay";
-};
-
-&uart4 {
-	pinctrl-names = "default", "sleep", "idle";
-	pinctrl-0 = <&uart4_pins_a>;
-	pinctrl-1 = <&uart4_sleep_pins_a>;
-	pinctrl-2 = <&uart4_idle_pins_a>;
-	pinctrl-3 = <&uart4_pins_a>;
-	/delete-property/dmas;
-	/delete-property/dma-names;
-	status = "okay";
-};
-
-&usart1 {
-	pinctrl-names = "default", "sleep", "idle";
-	pinctrl-0 = <&usart1_pins_b &usart1_pins_a>;
-	pinctrl-1 = <&usart1_sleep_pins_b &usart1_sleep_pins_a>;
-	pinctrl-2 = <&usart1_idle_pins_b &usart1_idle_pins_a>;
-	uart-has-rtscts;
-	status = "okay";
-};
-
-&usart3 {
-	pinctrl-names = "default", "sleep", "idle";
-	pinctrl-0 = <&usart3_pins_a>;
-	pinctrl-1 = <&usart3_sleep_pins_a>;
-	pinctrl-2 = <&usart3_idle_pins_a>;
-	status = "okay";
-};
-
-&usbh_ehci {
-	phys = <&usbphyc_port0>;
-	phy-names = "usb";
-	status = "okay";
-};
-
-&usbh_ohci {
-	phys = <&usbphyc_port0>;
-	phy-names = "usb";
-	status = "okay";
-};
-
-&usbotg_hs {
-	phys = <&usbphyc_port1 0>;
-	phy-names = "usb2-phy";
-	status = "okay";
-};
-
-&usbphyc {
-	status = "okay";
-};
-
-&usbphyc_port0 {
-	phy-supply = <&vdd_usb>;
-};
-
-&usbphyc_port1 {
-	phy-supply = <&vdd_usb>;
-};
diff --git a/arch/arm/boot/dts/st/stm32mp157f-phyboard-sargas-rdk-a7-examples.dts b/arch/arm/boot/dts/st/stm32mp157f-phyboard-sargas-rdk-a7-examples.dts
new file mode 100644
index 000000000000..b419981e9070
--- /dev/null
+++ b/arch/arm/boot/dts/st/stm32mp157f-phyboard-sargas-rdk-a7-examples.dts
@@ -0,0 +1,27 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)
+/*
+ * Copyright (C) 2020 PHYTEC Messtechnik GmbH
+ * Authors: Dom Vovard <dom.vovard@linrt.com>
+ *	    Christophe Parant <c.parant@phytec.fr>
+ */
+
+/dts-v1/;
+
+#include "stm32mp157f-phyboard-sargas-rdk.dts"
+
+/ {
+	model = "PHYTEC phyBOARD-Sargas STM32MP157F with eMMC configured to run Linux A7 examples";
+	compatible = "stm32mp157f-phyboard-sargas-rdk-emmc-a7-examples",
+		     "phytec,stm32mp157f-phyboard-sargas-rdk-emmc",
+		     "phytec,stm32mp157f-phycore-som", "st,stm32mp157";
+};
+
+/* device tree specificities to run Linux-A7-examples */
+&gpio_keys {
+	enter {
+		status = "disabled"; //disable PA14 (key enter) as input event
+	};
+	home {
+		status = "disabled"; //disable PA13 (key home) as input event
+	};
+};
diff --git a/arch/arm/boot/dts/st/stm32mp157f-phyboard-sargas-rdk-m4-examples.dts b/arch/arm/boot/dts/st/stm32mp157f-phyboard-sargas-rdk-m4-examples.dts
new file mode 100644
index 000000000000..abc91a8d16a0
--- /dev/null
+++ b/arch/arm/boot/dts/st/stm32mp157f-phyboard-sargas-rdk-m4-examples.dts
@@ -0,0 +1,176 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)
+/*
+ * Copyright (C) 2020 PHYTEC Messtechnik GmbH
+ * Authors: Dom Vovard <dom.vovard@linrt.com>
+ *	    Christophe Parant <c.parant@phytec.fr>
+ */
+
+/dts-v1/;
+
+#include "stm32mp157f-phyboard-sargas-rdk.dts"
+
+/ {
+	model = "PHYTEC phyBOARD-Sargas STM32MP157F with eMMC configured to run Cube M4 examples";
+	compatible = "stm32mp157f-phyboard-sargas-rdk-emmc-m4-examples",
+		     "phytec,stm32mp157f-phycore-som", "st,stm32mp157";
+};
+
+&adc {
+	status = "disabled";
+};
+
+&dac {
+	status = "disabled";
+};
+
+&dma2 {
+	status = "disabled";
+};
+
+&dmamux1 {
+	dma-masters = <&dma1>;
+	dma-channels = <8>;
+};
+
+&spi1 {
+	status = "disabled";
+};
+
+&i2c1 {
+	status = "disabled";
+};
+
+&timers1 {
+	status = "disabled";
+};
+
+&usart3 {
+	status = "disabled";
+};
+
+&gpio_keys {
+	home {
+		status = "disabled"; //disable PA13 (key home) as Linux input event
+	};
+	enter {
+		status = "disabled"; //disable PA14 (key enter) as Linux input event
+	};
+};
+
+&vrefbuf {
+	status = "okay";
+};
+
+&m4_adc {
+	vref-supply = <&vrefbuf>;
+	status = "okay";
+};
+
+&m4_dac {
+	vref-supply = <&vrefbuf>;
+	status = "okay";
+};
+
+&m4_dma2 {
+	status = "okay";
+};
+
+&m4_crc2 {
+	status = "okay";
+};
+
+&m4_cryp2 {
+	status = "okay";
+};
+
+&m4_hash2 {
+	status = "okay";
+};
+
+&m4_i2c1 {
+	pinctrl-names = "rproc_default";
+	pinctrl-0 = <&m4_i2c1_pins_a>;
+	status = "okay";
+};
+
+&m4_rng2 {
+	status = "okay";
+};
+
+&m4_rproc {
+	m4_system_resources {
+		status = "okay";
+
+		button {
+			compatible = "rproc-srm-dev";
+			interrupt-parent = <&gpioa>;
+			interrupts = <14 2>;
+			interrupt-names = "irq";
+			status = "okay";
+		};
+
+		m4_led: m4-led {
+			compatible = "rproc-srm-dev";
+			pinctrl-names = "default";
+			pinctrl-0 = <&m4_led_red_pin>;
+			status = "okay";
+		};
+	};
+};
+
+&m4_spi1 {
+	pinctrl-names = "rproc_default";
+	pinctrl-0 = <&m4_spi1_pins_a>;
+	status = "okay";
+};
+
+
+&m4_timers1 {
+	pinctrl-names = "rproc_default";
+	pinctrl-0 = <&m4_tim1_pwm_pins>;
+	status = "okay";
+};
+
+&m4_usart3 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&m4_usart3_pins_a>;
+	status = "okay";
+};
+
+&pinctrl {
+	m4_tim1_pwm_pins: m4-tim1-pwm-0 {
+		pins {
+			pinmux = <STM32_PINMUX('E', 14, RSVD)>; /* TIM1_CH4 */
+		};
+	};
+
+	m4_i2c1_pins_a: m4-i2c1-0 {
+		pins {
+			pinmux = <STM32_PINMUX('F', 14, RSVD)>, /* I2C1_SCL */
+				 <STM32_PINMUX('F', 15, RSVD)>; /* I2C1_SDA */
+		};
+	};
+
+	m4_led_red_pin: m4-led-red-0 {
+		pins {
+			pinmux = <STM32_PINMUX('A', 13, RSVD)>;
+		};
+	};
+
+	m4_usart3_pins_a: m4-usart3-0 {
+		pins {
+			pinmux = <STM32_PINMUX('B', 12, RSVD)>, /* USART3_RX */
+				 <STM32_PINMUX('B', 10, RSVD)>; /* USART3_TX */
+		};
+	};
+};
+
+&pinctrl_z {
+	m4_spi1_pins_a: m4-spi1-0 {
+		pins {
+			pinmux = <STM32_PINMUX('Z', 0, RSVD)>, /* SPI1_SCK */
+				 <STM32_PINMUX('Z', 1, RSVD)>, /* SPI1_MISO */
+				 <STM32_PINMUX('Z', 2, RSVD)>; /* SPI1_MOSI */
+		};
+	};
+};
diff --git a/arch/arm/boot/dts/st/stm32mp157f-phyboard-sargas-rdk.dts b/arch/arm/boot/dts/st/stm32mp157f-phyboard-sargas-rdk.dts
new file mode 100644
index 000000000000..857d29dd5018
--- /dev/null
+++ b/arch/arm/boot/dts/st/stm32mp157f-phyboard-sargas-rdk.dts
@@ -0,0 +1,64 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)
+/*
+ * Copyright (C) 2020 PHYTEC Messtechnik GmbH
+ * Authors: Dom Vovard <dom.vovard@linrt.com>
+ *	    Christophe Parant <c.parant@phytec.fr>
+ */
+
+/dts-v1/;
+
+#include "stm32mp157.dtsi"
+#include "stm32mp15xf.dtsi"
+#include "stm32mp157c-phycore-scmi.dtsi"
+#include "stm32mp15xx-phycore-som.dtsi"
+#include "stm32mp15xx-phyboard-sargas.dtsi"
+
+/ {
+	model = "PHYTEC phyBOARD-Sargas STM32MP157F with eMMC";
+	compatible = "phytec,stm32mp157f-phyboard-sargas-rdk-emmc",
+		     "phytec,stm32mp157f-phycore-som", "st,stm32mp157";
+
+	memory@c0000000 {
+		reg = <0xc0000000 0x40000000>;
+	};
+
+	reserved-memory {
+		gpu_reserved: gpu@f6000000 {
+			reg = <0xf6000000 0x8000000>;
+			no-map;
+		};
+	};
+};
+
+&dts {
+	status = "okay";
+};
+
+&gpu {
+	status = "okay";
+	contiguous-area = <&gpu_reserved>;
+};
+
+&i2c4_rtc {
+	status = "okay";
+};
+
+&i2c4_eeprom {
+	status = "okay";
+};
+
+&qspi {
+	status = "okay";
+};
+
+&fmc {
+	status = "disabled";
+};
+
+&sdmmc2 {
+	status = "okay";
+};
+
+&cryp1 {
+	status = "okay";
+};
diff --git a/arch/arm/boot/dts/st/stm32mp15xx-phyboard-sargas-pinctrl.dtsi b/arch/arm/boot/dts/st/stm32mp15xx-phyboard-sargas-pinctrl.dtsi
new file mode 100644
index 000000000000..2fb0d9993790
--- /dev/null
+++ b/arch/arm/boot/dts/st/stm32mp15xx-phyboard-sargas-pinctrl.dtsi
@@ -0,0 +1,509 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)
+/*
+ * Copyright (C) 2020 PHYTEC Messtechnik GmbH
+ * Authors: Dom Vovard <dom.vovard@linrt.com>
+ *	    Christophe Parant <c.parant@phytec.fr>
+ */
+
+#include <dt-bindings/pinctrl/stm32-pinfunc.h>
+
+&pinctrl {
+
+			dac_ch1_pins_a: dac-ch1 {
+				pins {
+					pinmux = <STM32_PINMUX('A', 4, ANALOG)>;
+				};
+			};
+
+			dac_ch2_pins_a: dac-ch2 {
+				pins {
+					pinmux = <STM32_PINMUX('A', 5, ANALOG)>;
+				};
+			};
+
+			dcmi_pins_a: dcmi-0 {
+				pins {
+					pinmux = <STM32_PINMUX('H', 8,  AF13)>,/* DCMI_HSYNC */
+						 <STM32_PINMUX('B', 7,  AF13)>,/* DCMI_VSYNC */
+						 <STM32_PINMUX('A', 6,  AF13)>,/* DCMI_PIXCLK */
+						 <STM32_PINMUX('H', 9,  AF13)>,/* DCMI_D0 */
+						 <STM32_PINMUX('C', 7,  AF13)>,/* DCMI_D1 */
+						 <STM32_PINMUX('E', 0,  AF13)>,/* DCMI_D2 */
+						 <STM32_PINMUX('E', 1,  AF13)>,/* DCMI_D3 */
+						 <STM32_PINMUX('H', 14, AF13)>,/* DCMI_D4 */
+						 <STM32_PINMUX('I', 4,  AF13)>,/* DCMI_D5 */
+						 <STM32_PINMUX('E', 5,  AF13)>,/* DCMI_D6 */
+						 <STM32_PINMUX('I', 7,  AF13)>,/* DCMI_D7 */
+						 <STM32_PINMUX('I', 1,  AF13)>,/* DCMI_D8 */
+						 <STM32_PINMUX('H', 7,  AF13)>;/* DCMI_D9 */
+					bias-disable;
+				};
+			};
+
+			dcmi_sleep_pins_a: dcmi-sleep-0 {
+				pins {
+					pinmux = <STM32_PINMUX('H', 8,  ANALOG)>,/* DCMI_HSYNC */
+						 <STM32_PINMUX('B', 7,  ANALOG)>,/* DCMI_VSYNC */
+						 <STM32_PINMUX('A', 6,  ANALOG)>,/* DCMI_PIXCLK */
+						 <STM32_PINMUX('H', 9,  ANALOG)>,/* DCMI_D0 */
+						 <STM32_PINMUX('C', 7,  ANALOG)>,/* DCMI_D1 */
+						 <STM32_PINMUX('E', 0,  ANALOG)>,/* DCMI_D2 */
+						 <STM32_PINMUX('E', 1,  ANALOG)>,/* DCMI_D3 */
+						 <STM32_PINMUX('H', 14, ANALOG)>,/* DCMI_D4 */
+						 <STM32_PINMUX('I', 4,  ANALOG)>,/* DCMI_D5 */
+						 <STM32_PINMUX('E', 5,  ANALOG)>,/* DCMI_D6 */
+						 <STM32_PINMUX('I', 7,  ANALOG)>,/* DCMI_D7 */
+						 <STM32_PINMUX('I', 1,  ANALOG)>,/* DCMI_D8 */
+						 <STM32_PINMUX('H', 7,  ANALOG)>;/* DCMI_D9 */
+				};
+			};
+
+
+			i2c1_pins_a: i2c1-0 {
+				pins {
+					pinmux = <STM32_PINMUX('F', 14, AF5)>, /* I2C1_SCL */
+						 <STM32_PINMUX('F', 15, AF5)>; /* I2C1_SDA */
+					bias-disable;
+					drive-open-drain;
+					slew-rate = <0>;
+				};
+			};
+
+			i2c1_pins_sleep_a: i2c1-1 {
+				pins {
+					pinmux = <STM32_PINMUX('F', 14, ANALOG)>, /* I2C1_SCL */
+						 <STM32_PINMUX('F', 15, ANALOG)>; /* I2C1_SDA */
+				};
+			};
+
+
+			ltdc_pins_a: ltdc-a-0 {
+				pins {
+					pinmux = <STM32_PINMUX('G', 7,  AF14)>, /* LCD_CLK */
+						 <STM32_PINMUX('I', 10, AF14)>, /* LCD_HSYNC */
+						 <STM32_PINMUX('I', 9,  AF14)>, /* LCD_VSYNC */
+						 <STM32_PINMUX('E', 13, AF14)>, /* LCD_DE */
+						 <STM32_PINMUX('C', 10, AF14)>, /* LCD_R2 */
+						 <STM32_PINMUX('B', 0,   AF9)>, /* LCD_R3 */
+						 <STM32_PINMUX('H', 10, AF14)>, /* LCD_R4 */
+						 <STM32_PINMUX('H', 11, AF14)>, /* LCD_R5 */
+						 <STM32_PINMUX('H', 12, AF14)>, /* LCD_R6 */
+						 <STM32_PINMUX('E', 15, AF14)>, /* LCD_R7 */
+						 <STM32_PINMUX('H', 13, AF14)>, /* LCD_G2 */
+						 <STM32_PINMUX('E', 11, AF14)>, /* LCD_G3 */
+						 <STM32_PINMUX('H', 15, AF14)>, /* LCD_G4 */
+						 <STM32_PINMUX('H', 4,   AF9)>, /* LCD_G5 */
+						 <STM32_PINMUX('I', 11,  AF9)>, /* LCD_G6 */
+						 <STM32_PINMUX('I', 2,  AF14)>, /* LCD_G7 */
+						 <STM32_PINMUX('G', 10, AF14)>, /* LCD_B2 */
+						 <STM32_PINMUX('G', 11, AF14)>, /* LCD_B3 */
+						 <STM32_PINMUX('E', 12, AF14)>, /* LCD_B4 */
+						 <STM32_PINMUX('I', 5,  AF14)>, /* LCD_B5 */
+						 <STM32_PINMUX('B', 8,  AF14)>, /* LCD_B6 */
+						 <STM32_PINMUX('D', 8,  AF14)>; /* LCD_B7 */
+					bias-disable;
+					drive-push-pull;
+					slew-rate = <1>;
+				};
+			};
+
+			ltdc_pins_sleep_a: ltdc-a-1 {
+				pins {
+					pinmux = <STM32_PINMUX('G', 7,  ANALOG)>, /* LCD_CLK */
+						 <STM32_PINMUX('I', 10, ANALOG)>, /* LCD_HSYNC */
+						 <STM32_PINMUX('I', 9,  ANALOG)>, /* LCD_VSYNC */
+						 <STM32_PINMUX('E', 13, ANALOG)>, /* LCD_DE */
+						 <STM32_PINMUX('C', 10, ANALOG)>, /* LCD_R2 */
+						 <STM32_PINMUX('B', 0,  ANALOG)>, /* LCD_R3 */
+						 <STM32_PINMUX('H', 10, ANALOG)>, /* LCD_R4 */
+						 <STM32_PINMUX('H', 11, ANALOG)>, /* LCD_R5 */
+						 <STM32_PINMUX('H', 12, ANALOG)>, /* LCD_R6 */
+						 <STM32_PINMUX('E', 15, ANALOG)>, /* LCD_R7 */
+						 <STM32_PINMUX('H', 13, ANALOG)>, /* LCD_G2 */
+						 <STM32_PINMUX('E', 11, ANALOG)>, /* LCD_G3 */
+						 <STM32_PINMUX('H', 15, ANALOG)>, /* LCD_G4 */
+						 <STM32_PINMUX('H', 4,  ANALOG)>, /* LCD_G5 */
+						 <STM32_PINMUX('I', 11, ANALOG)>, /* LCD_G6 */
+						 <STM32_PINMUX('I', 2,  ANALOG)>, /* LCD_G7 */
+						 <STM32_PINMUX('G', 10, ANALOG)>, /* LCD_B2 */
+						 <STM32_PINMUX('G', 11, ANALOG)>, /* LCD_B3 */
+						 <STM32_PINMUX('E', 12, ANALOG)>, /* LCD_B4 */
+						 <STM32_PINMUX('I', 5,  ANALOG)>, /* LCD_B5 */
+						 <STM32_PINMUX('B', 8,  ANALOG)>, /* LCD_B6 */
+						 <STM32_PINMUX('D', 8,  ANALOG)>; /* LCD_B7 */
+				};
+			};
+
+
+			m_can2_pins_a: m-can1-0 {
+				pins1 {
+					pinmux = <STM32_PINMUX('B', 13, AF9)>; /* CAN2_TX */
+					slew-rate = <0>;
+					drive-push-pull;
+					bias-disable;
+				};
+				pins2 {
+					pinmux = <STM32_PINMUX('B', 5, AF9)>; /* CAN2_RX */
+					bias-disable;
+				};
+			};
+
+			m_can2_sleep_pins_a: m-can2-sleep@0 {
+				pins {
+					pinmux = <STM32_PINMUX('B', 13, ANALOG)>, /* CAN2_TX */
+						 <STM32_PINMUX('B', 5, ANALOG)>; /* CAN2_RX */
+				};
+			};
+
+
+			pwm5_pins_a: pwm5-0 {
+				pins {
+					pinmux = <STM32_PINMUX('I', 0, AF2)>; /* TIM5_CH4 */
+					bias-pull-down;
+					drive-push-pull;
+					slew-rate = <0>;
+				};
+			};
+
+			pwm5_sleep_pins_a: pwm5-sleep-0 {
+				pins {
+					pinmux = <STM32_PINMUX('I', 0, ANALOG)>; /* TIM5_CH4 */
+				};
+			};
+
+
+			sai2a_pins_b: sai2a-2 {
+				pins {
+					pinmux = <STM32_PINMUX('I', 6, AF10)>; /* SAI2_SD_A */
+					bias-disable;
+				};
+			};
+
+			sai2a_sleep_pins_b: sai2a-3 {
+				pins {
+					pinmux = <STM32_PINMUX('I', 6, ANALOG)>; /* SAI2_SD_A */
+				};
+			};
+
+			sai2b_pins_a: sai2b-0 {
+				pins1 {
+					pinmux = <STM32_PINMUX('H', 2, AF10)>, /* SAI2_SCK_B */
+						 <STM32_PINMUX('C', 0, AF8)>, /* SAI2_FS_B */
+						 <STM32_PINMUX('H', 3, AF10)>; /* SAI2_MCLK_B */
+					slew-rate = <0>;
+					drive-push-pull;
+					bias-disable;
+				};
+				pins2 {
+					pinmux = <STM32_PINMUX('F', 11, AF10)>; /* SAI2_SD_B */
+					bias-disable;
+				};
+			};
+
+			sai2b_sleep_pins_a: sai2b-1 {
+				pins {
+					pinmux = <STM32_PINMUX('F', 11, ANALOG)>, /* SAI2_SD_B */
+						 <STM32_PINMUX('H', 2, ANALOG)>, /* SAI2_SCK_B */
+						 <STM32_PINMUX('C', 0, ANALOG)>, /* SAI2_FS_B */
+						 <STM32_PINMUX('H', 3, ANALOG)>; /* SAI2_MCLK_B */
+				};
+			};
+
+			sai2b_pins_b: sai2b-2 {
+				pins {
+					pinmux = <STM32_PINMUX('F', 11, AF10)>; /* SAI2_SD_B */
+					bias-disable;
+				};
+			};
+
+			sai2b_sleep_pins_b: sai2b-3 {
+				pins {
+					pinmux = <STM32_PINMUX('F', 11, ANALOG)>; /* SAI2_SD_B */
+				};
+			};
+
+
+			sdmmc1_b4_pins_a: sdmmc1-b4-0 {
+				pins1 {
+					pinmux = <STM32_PINMUX('C', 8, AF12)>, /* SDMMC1_D0 */
+						 <STM32_PINMUX('C', 9, AF12)>, /* SDMMC1_D1 */
+						 <STM32_PINMUX('E', 6, AF8)>, /* SDMMC1_D2 */
+						 <STM32_PINMUX('C', 11, AF12)>, /* SDMMC1_D3 */
+						 <STM32_PINMUX('D', 2, AF12)>; /* SDMMC1_CMD */
+					slew-rate = <1>;
+					drive-push-pull;
+					bias-disable;
+				};
+				pins2 {
+					pinmux = <STM32_PINMUX('C', 12, AF12)>; /* SDMMC1_CK */
+					slew-rate = <2>;
+					drive-push-pull;
+					bias-disable;
+				};
+			};
+
+			sdmmc1_b4_od_pins_a: sdmmc1-b4-od-0 {
+				pins1 {
+					pinmux = <STM32_PINMUX('C', 8, AF12)>, /* SDMMC1_D0 */
+						 <STM32_PINMUX('C', 9, AF12)>, /* SDMMC1_D1 */
+						 <STM32_PINMUX('E', 6, AF8)>, /* SDMMC1_D2 */
+						 <STM32_PINMUX('C', 11, AF12)>; /* SDMMC1_D3 */
+					slew-rate = <1>;
+					drive-push-pull;
+					bias-disable;
+				};
+				pins2 {
+					pinmux = <STM32_PINMUX('C', 12, AF12)>; /* SDMMC1_CK */
+					slew-rate = <2>;
+					drive-push-pull;
+					bias-disable;
+				};
+				pins3 {
+					pinmux = <STM32_PINMUX('D', 2, AF12)>; /* SDMMC1_CMD */
+					slew-rate = <1>;
+					drive-open-drain;
+					bias-disable;
+				};
+			};
+
+			sdmmc1_b4_sleep_pins_a: sdmmc1-b4-sleep-0 {
+				pins {
+					pinmux = <STM32_PINMUX('C', 8, ANALOG)>, /* SDMMC1_D0 */
+						 <STM32_PINMUX('C', 9, ANALOG)>, /* SDMMC1_D1 */
+						 <STM32_PINMUX('E', 6, ANALOG)>, /* SDMMC1_D2 */
+						 <STM32_PINMUX('C', 11, ANALOG)>, /* SDMMC1_D3 */
+						 <STM32_PINMUX('C', 12, ANALOG)>, /* SDMMC1_CK */
+						 <STM32_PINMUX('D', 2, ANALOG)>; /* SDMMC1_CMD */
+				};
+			};
+
+			sdmmc3_b4_pins_a: sdmmc3-b4-0 {
+				pins1 {
+					pinmux = <STM32_PINMUX('F', 0, AF9)>, /* SDMMC3_D0 */
+						 <STM32_PINMUX('F', 4, AF9)>, /* SDMMC3_D1 */
+						 <STM32_PINMUX('F', 5, AF9)>, /* SDMMC3_D2 */
+						 <STM32_PINMUX('D', 7, AF10)>, /* SDMMC3_D3 */
+						 <STM32_PINMUX('F', 1, AF9)>; /* SDMMC3_CMD */
+					slew-rate = <1>;
+					drive-push-pull;
+					bias-pull-up;
+				};
+				pins2 {
+					pinmux = <STM32_PINMUX('G', 15, AF10)>; /* SDMMC3_CK */
+					slew-rate = <2>;
+					drive-push-pull;
+					bias-pull-up;
+				};
+			};
+
+			sdmmc3_b4_od_pins_a: sdmmc3-b4-od-0 {
+				pins1 {
+					pinmux = <STM32_PINMUX('F', 0, AF9)>, /* SDMMC3_D0 */
+						 <STM32_PINMUX('F', 4, AF9)>, /* SDMMC3_D1 */
+						 <STM32_PINMUX('F', 5, AF9)>, /* SDMMC3_D2 */
+						 <STM32_PINMUX('D', 7, AF10)>; /* SDMMC3_D3 */
+					slew-rate = <1>;
+					drive-push-pull;
+					bias-pull-up;
+				};
+				pins2 {
+					pinmux = <STM32_PINMUX('G', 15, AF10)>; /* SDMMC3_CK */
+					slew-rate = <2>;
+					drive-push-pull;
+					bias-pull-up;
+				};
+				pins3 {
+					pinmux = <STM32_PINMUX('F', 1, AF9)>; /* SDMMC2_CMD */
+					slew-rate = <1>;
+					drive-open-drain;
+					bias-pull-up;
+				};
+			};
+
+			sdmmc3_b4_sleep_pins_a: sdmmc3-b4-sleep-0 {
+				pins {
+					pinmux = <STM32_PINMUX('F', 0, ANALOG)>, /* SDMMC3_D0 */
+						 <STM32_PINMUX('F', 4, ANALOG)>, /* SDMMC3_D1 */
+						 <STM32_PINMUX('F', 5, ANALOG)>, /* SDMMC3_D2 */
+						 <STM32_PINMUX('D', 7, ANALOG)>, /* SDMMC3_D3 */
+						 <STM32_PINMUX('G', 15, ANALOG)>, /* SDMMC3_CK */
+						 <STM32_PINMUX('F', 1, ANALOG)>; /* SDMMC3_CMD */
+				};
+			};
+
+
+			uart4_pins_a: uart4-0 {
+				pins1 {
+					pinmux = <STM32_PINMUX('B', 9, AF8)>; /* UART4_TX */
+					bias-disable;
+					drive-push-pull;
+					slew-rate = <0>;
+				};
+				pins2 {
+					pinmux = <STM32_PINMUX('B', 2, AF8)>; /* UART4_RX */
+					bias-disable;
+				};
+			};
+
+			uart4_idle_pins_a: uart4-idle-0 {
+				pins1 {
+					pinmux = <STM32_PINMUX('B', 9, ANALOG)>; /* UART4_TX */
+				};
+				pins2 {
+					pinmux = <STM32_PINMUX('B', 2, AF8)>; /* UART4_RX */
+					bias-disable;
+				};
+			};
+
+			uart4_sleep_pins_a: uart4-sleep-0 {
+				pins {
+					pinmux = <STM32_PINMUX('B', 9, ANALOG)>, /* UART4_TX */
+						 <STM32_PINMUX('B', 2, ANALOG)>; /* UART4_RX */
+				};
+			};
+
+			usart1_pins_b: usart1-1 {
+				pins1 {
+					pinmux = <STM32_PINMUX('A', 12, AF7)>; /* USART1_RTS */
+					bias-disable;
+					drive-push-pull;
+					slew-rate = <0>;
+				};
+				pins2 {
+					pinmux = <STM32_PINMUX('A', 11, AF7)>; /* USART1_CTS_NSS */
+					bias-disable;
+				};
+			};
+
+			usart1_idle_pins_b: usart1-idle-1 {
+				pins1 {
+					pinmux = <STM32_PINMUX('A', 12, ANALOG)>, /* USART1_RTS */
+						<STM32_PINMUX('A', 11, AF7)>; /* USART1_CTS_NSS */
+				};
+			};
+
+			usart1_sleep_pins_b: usart1-sleep-1 {
+				pins {
+					pinmux = <STM32_PINMUX('A', 12, ANALOG)>, /* USART1_RTS */
+						<STM32_PINMUX('A', 11, ANALOG)>; /* USART1_CTS_NSS */
+				};
+			};
+
+			usart3_pins_a: usart3-0 {
+				pins1 {
+					pinmux = <STM32_PINMUX('B', 10, AF7)>; /* USART3_TX */
+					bias-disable;
+					drive-push-pull;
+					slew-rate = <0>;
+				};
+				pins2 {
+					pinmux = <STM32_PINMUX('B', 12, AF8)>; /* USART3_RX */
+					bias-disable;
+				};
+			};
+
+			usart3_idle_pins_a: usart3-idle-0 {
+				pins1 {
+					pinmux = <STM32_PINMUX('B', 10, ANALOG)>; /* USART3_TX */
+				};
+				pins2 {
+					pinmux = <STM32_PINMUX('B', 12, AF8)>; /* USART3_RX */
+					bias-disable;
+				};
+			};
+
+			usart3_sleep_pins_a: usart3-sleep-0 {
+				pins {
+					pinmux = <STM32_PINMUX('B', 10, ANALOG)>, /* USART3_TX */
+						 <STM32_PINMUX('B', 12, ANALOG)>; /* USART3_RX */
+				};
+			};
+
+			usart3_pins_b: usart3-1 {
+				pins1 {
+					pinmux = <STM32_PINMUX('G', 8, AF8)>; /* USART3_RTS */
+					bias-disable;
+					drive-push-pull;
+					slew-rate = <0>;
+				};
+				pins2 {
+					pinmux = <STM32_PINMUX('B', 13, AF7)>; /* USART3_CTS_NSS */
+					bias-disable;
+				};
+			};
+
+			usart3_idle_pins_b: usart3-idle-1 {
+				pins1 {
+					pinmux = <STM32_PINMUX('G', 8, ANALOG)>, /* USART3_RTS */
+						<STM32_PINMUX('B', 13, AF7)>; /* USART3_CTS_NSS */
+				};
+			};
+
+			usart3_sleep_pins_b: usart3-sleep-1 {
+				pins {
+					pinmux = <STM32_PINMUX('G', 8, ANALOG)>, /* USART3_RTS */
+						<STM32_PINMUX('B', 13, ANALOG)>; /* USART3_CTS_NSS */
+				};
+			};
+
+			usbotg_hs_pins_a: usbotg-hs-0 {
+				pins {
+					pinmux = <STM32_PINMUX('A', 10, ANALOG)>; /* OTG_ID */
+				};
+			};
+};
+
+&pinctrl_z {
+
+	usart1_pins_a: usart1-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('Z', 7, AF7)>; /* USART1_TX */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <0>;
+		};
+		pins2 {
+			pinmux = <STM32_PINMUX('Z', 6, AF7)>; /* USART1_RX */
+			bias-disable;
+		};
+	};
+
+	usart1_idle_pins_a: usart1-idle-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('Z', 7, ANALOG)>; /* USART1_TX */
+		};
+		pins2 {
+			pinmux = <STM32_PINMUX('Z', 6, AF7)>; /* USART1_RX */
+			bias-disable;
+		};
+	};
+
+	usart1_sleep_pins_a: usart1-sleep-0 {
+		pins {
+			pinmux = <STM32_PINMUX('Z', 7, ANALOG)>, /* USART1_TX */
+				 <STM32_PINMUX('Z', 6, ANALOG)>; /* USART1_RX */
+		};
+	};
+
+	spi1_pins_a: spi1-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('Z', 0, AF5)>, /* SPI1_SCK */
+				 <STM32_PINMUX('Z', 2, AF5)>; /* SPI1_MOSI */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <1>;
+		};
+		pins2 {
+			pinmux = <STM32_PINMUX('Z', 1, AF5)>; /* SPI1_MISO */
+			bias-disable;
+		};
+	};
+
+	spi1_sleep_pins_a: spi1-sleep-0 {
+		pins {
+			pinmux = <STM32_PINMUX('Z', 0, ANALOG)>, /* SPI1_SCK */
+				 <STM32_PINMUX('Z', 1, ANALOG)>, /* SPI1_MISO */
+				 <STM32_PINMUX('Z', 2, ANALOG)>; /* SPI1_MOSI */
+		};
+	};
+};
diff --git a/arch/arm/boot/dts/st/stm32mp15xx-phyboard-sargas.dtsi b/arch/arm/boot/dts/st/stm32mp15xx-phyboard-sargas.dtsi
new file mode 100644
index 000000000000..92065b3a8404
--- /dev/null
+++ b/arch/arm/boot/dts/st/stm32mp15xx-phyboard-sargas.dtsi
@@ -0,0 +1,359 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)
+/*
+ * Copyright (C) 2020 PHYTEC Messtechnik GmbH
+ * Authors: Dom Vovard <dom.vovard@linrt.com>
+ *          Christophe Parant <c.parant@phytec.fr>
+ */
+
+#include "stm32mp15xx-phyboard-sargas-pinctrl.dtsi"
+#include <dt-bindings/leds/leds-pca9532.h>
+
+/ {
+	aliases {
+		ethernet0 = &ethernet0;
+		rtc0 = &i2c4_rtc;
+		rtc1 = &rtc;
+		serial0 = &uart4;
+		serial1 = &usart3;
+		serial2 = &usart1;
+	};
+
+	chosen {
+		stdout-path = "serial0:115200n8";
+	};
+
+	clocks {
+		clk_ext_camera: clk-ext-camera {
+			#clock-cells = <0>;
+			compatible = "fixed-clock";
+			clock-frequency = <27000000>;
+			status = "disabled";
+		};
+	};
+
+	sound {
+		compatible = "audio-graph-card";
+		label = "STM32MP1-PHYCORE";
+		routing =
+			"Playback", "MCLK", /* Set a route between "MCLK" and "playback" widgets */
+			"Capture", "MCLK";
+		dais = <&sai2b_port &sai2a_port>;
+		status = "okay";
+	};
+
+	gpio_keys: gpio-keys {
+		compatible = "gpio-keys";
+		status = "okay";
+
+		home {
+			label = "Home";
+			gpios = <&gpioa 13 GPIO_ACTIVE_LOW>;
+			linux,code = <KEY_HOME>;
+		};
+
+		enter {
+			label = "Enter";
+			gpios = <&gpioa 14 GPIO_ACTIVE_LOW>;
+			linux,code = <KEY_ENTER>;
+		};
+	};
+
+	usb_phy_tuning: usb-phy-tuning {
+		st,hs-dc-level = <2>;
+		st,fs-rftime-tuning;
+		st,hs-rftime-reduction;
+		st,hs-current-trim = <15>;
+		st,hs-impedance-trim = <1>;
+		st,squelch-level = <3>;
+		st,hs-rx-offset = <2>;
+		st,no-lsfs-sc;
+	};
+
+	reg_m_can: regulator-mcan {
+		compatible = "regulator-fixed";
+		regulator-name = "mcan-reg";
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+		gpio = <&gpiog 1 GPIO_ACTIVE_HIGH>;
+		regulator-always-on;
+		status = "okay";
+	};
+
+	reg_vcc_cam: regulator-cam {
+		compatible = "regulator-fixed";
+		regulator-name = "vcc_cam";
+		regulator-min-microvolt = <2800000>;
+		regulator-max-microvolt = <2800000>;
+		status = "disabled";
+	};
+};
+
+&m_can2 {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&m_can2_pins_a>;
+	pinctrl-1 = <&m_can2_sleep_pins_a>;
+	status = "okay";
+};
+
+&i2c1 {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&i2c1_pins_a>;
+	pinctrl-1 = <&i2c1_pins_sleep_a>;
+	i2c-scl-rising-time-ns = <100>;
+	i2c-scl-falling-time-ns = <7>;
+	status = "okay";
+	/delete-property/dmas;
+	/delete-property/dma-names;
+
+	codec: tlv320@18 {
+		compatible = "ti,tlv320aic3007";
+		#sound-dai-cells = <0>;
+		reg = <0x18>;
+		status = "okay";
+
+		ai3x-micbias-vg = <2>;
+
+		/* gpio-reset = <&gpio5 8 GPIO_ACTIVE_LOW>; */
+		AVDD-supply = <&v3v3>;
+		IOVDD-supply = <&v3v3>;
+		DRVDD-supply = <&v3v3>;
+		DVDD-supply = <&v1v8_audio>;
+
+		clocks = <&sai2b>;
+		clock-names = "MCLK";
+
+
+
+		tlv320_port: port {
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			tlv320_tx_endpoint: endpoint@0 {
+				reg = <0>;
+				remote-endpoint = <&sai2b_endpoint>;
+				frame-master;
+				bitclock-master;
+			};
+
+			tlv320_rx_endpoint: endpoint@1 {
+				reg = <1>;
+				remote-endpoint = <&sai2a_endpoint>;
+				frame-master;
+				bitclock-master;
+			};
+		};
+	};
+
+	stmpe_touch: stmpe811@44 {
+		compatible = "st,stmpe811";
+		reg = <0x44>;
+		interrupts = <3 2>;
+		interrupt-parent = <&gpioi>;
+		vio-supply = <&v3v3>;
+		vcc-supply = <&v3v3>;
+		status = "disabled";
+
+		stmpe_touchscreen {
+			compatible = "st,stmpe-ts";
+			st,sample-time = <4>;
+			st,mod-12b = <1>;
+			st,ref-sel = <0>;
+			st,adc-freq = <1>;
+			st,ave-ctrl = <1>;
+			st,touch-det-delay = <2>;
+			st,settling = <2>;
+			st,fraction-z = <7>;
+			st,i-drive = <1>;
+		};
+	};
+
+	leds: pca9533@62 {
+		compatible = "nxp,pca9533";
+		reg = <0x62>;
+		status = "okay";
+
+		red-power {
+			label = "pca:red:power";
+			type = <PCA9532_TYPE_LED>;
+		};
+
+		green-power {
+			label = "pca:green:power";
+			type = <PCA9532_TYPE_LED>;
+		};
+
+		blue-power {
+			type = <PCA9532_TYPE_LED>;
+			linux,default-trigger = "heartbeat";
+		};
+	};
+};
+
+&i2c2 {
+	status = "disabled";
+};
+
+
+&sai2 {
+	clocks = <&rcc SAI2>, <&rcc PLL3_Q>, <&rcc PLL3_R>;
+	clock-names = "pclk", "x8k", "x11k";
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&sai2a_pins_b>, <&sai2b_pins_a>;
+	pinctrl-1 = <&sai2a_sleep_pins_b>, <&sai2b_sleep_pins_a>;
+	status = "okay";
+
+	sai2a: audio-controller@4400b004 {
+		dma-names = "rx";
+		st,sync = <&sai2b 2>;
+		status = "okay";
+		clocks = <&rcc SAI2_K>, <&sai2b>;
+		clock-names = "sai_ck", "MCLK";
+
+		sai2a_port: port {
+			sai2a_endpoint: endpoint {
+				remote-endpoint = <&tlv320_rx_endpoint>;
+				format = "i2s";
+				mclk-fs = <256>;
+				dai-tdm-slot-num = <2>;
+				dai-tdm-slot-width = <16>;
+			};
+		};
+	};
+
+	sai2b: audio-controller@4400b024 {
+		#clock-cells = <0>;
+		dma-names = "tx";
+		status = "okay";
+
+		sai2b_port: port {
+			sai2b_endpoint: endpoint {
+				remote-endpoint = <&tlv320_tx_endpoint>;
+				format = "i2s";
+				mclk-fs = <256>;
+				dai-tdm-slot-num = <2>;
+				dai-tdm-slot-width = <16>;
+			};
+		};
+	};
+};
+
+&dcmi {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&dcmi_pins_a>;
+	pinctrl-1 = <&dcmi_sleep_pins_a>;
+	status = "disabled";
+	/*
+	 * Enable DMA-MDMA chaining by adding a SRAM pool and
+	 * a MDMA channel
+	 */
+	sram = <&dcmi_pool>;
+
+	dmas = <&dmamux1 75 0x400 0x01>, <&mdma1 0 0x3 0x1200000a 0 0>;
+	dma-names = "tx", "mdma_tx";
+};
+
+
+&sram4 {
+	dcmi_pool: dcmi-pool@0 {
+		reg = <0x0 0x8000>;
+		pool;
+	};
+};
+
+&sdmmc1 {
+	pinctrl-names = "default", "opendrain", "sleep";
+	pinctrl-0 = <&sdmmc1_b4_pins_a>;
+	pinctrl-1 = <&sdmmc1_b4_od_pins_a>;
+	pinctrl-2 = <&sdmmc1_b4_sleep_pins_a>;
+	cd-gpios = <&gpiof 3 GPIO_ACTIVE_LOW>;
+	st,neg-edge;
+	bus-width = <4>;
+	vmmc-supply = <&v3v3>;
+	status = "okay";
+};
+
+
+&spi1 {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&spi1_pins_a>;
+	pinctrl-1 = <&spi1_sleep_pins_a>;
+	cs-gpios = <&gpioz 3 0>;
+	status = "okay";
+	spi@0 {
+		compatible = "linux,spidev";
+		spi-max-frequency = <10000000>;
+		reg = <0>;
+	};
+};
+
+
+&uart4 {
+	pinctrl-names = "default", "sleep", "idle";
+	pinctrl-0 = <&uart4_pins_a>;
+	pinctrl-1 = <&uart4_sleep_pins_a>;
+	pinctrl-2 = <&uart4_idle_pins_a>;
+	pinctrl-3 = <&uart4_pins_a>;
+	/delete-property/dmas;
+	/delete-property/dma-names;
+	status = "okay";
+};
+
+&usart1 {
+	pinctrl-names = "default", "sleep", "idle";
+	pinctrl-0 = <&usart1_pins_a &usart1_pins_b>;
+	pinctrl-1 = <&usart1_sleep_pins_a &usart1_sleep_pins_b>;
+	pinctrl-2 = <&usart1_idle_pins_a &usart1_idle_pins_b>;
+	uart-has-rtscts;
+	/*linux,rs485-enabled-at-boot-time;*/
+	status = "okay";
+};
+
+&usart3 {
+	pinctrl-names = "default", "sleep", "idle";
+	pinctrl-0 = <&usart3_pins_a>;
+	pinctrl-1 = <&usart3_sleep_pins_a>;
+	pinctrl-2 = <&usart3_idle_pins_a>;
+	status = "okay";
+};
+
+&usbh_ehci {
+	phys = <&usbphyc_port0>;
+	phy-names = "usb";
+	status = "okay";
+};
+
+&usbh_ohci {
+	phys = <&usbphyc_port0>;
+	phy-names = "usb";
+	status = "okay";
+};
+
+&usbotg_hs {
+	phys = <&usbphyc_port1 0>;
+	phy-names = "usb2-phy";
+	vbus-supply = <&vbus_otg>;
+	status = "okay";
+};
+
+&usbphyc {
+	vdd3v3-supply = <&vdd_usb>;
+	status = "okay";
+};
+
+&usbphyc_port0 {
+	phy-supply = <&vdd_usb>;
+	vbus-supply = <&vbus_sw>;
+	st,phy-tuning = <&usb_phy_tuning>;
+};
+
+&usbphyc_port1 {
+	phy-supply = <&vdd_usb>;
+	st,phy-tuning = <&usb_phy_tuning>;
+};
+
+&vrefbuf {
+	regulator-min-microvolt = <2500000>;
+	regulator-max-microvolt = <2500000>;
+	vdda-supply = <&vdd>;
+	status = "disabled";
+};
diff --git a/arch/arm/boot/dts/st/stm32mp15xx-phycore-scmi.dtsi b/arch/arm/boot/dts/st/stm32mp15xx-phycore-scmi.dtsi
new file mode 100644
index 000000000000..c6a798343d51
--- /dev/null
+++ b/arch/arm/boot/dts/st/stm32mp15xx-phycore-scmi.dtsi
@@ -0,0 +1,89 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)
+/*
+ * Copyright (C) 2025 PHYTEC Messtechnik GmbH
+ * Authors: Christophe Parant <c.parant@phytec.fr>
+ */
+
+#include "stm32mp15-scmi.dtsi"
+
+&cpu0 {
+	clocks = <&scmi_clk CK_SCMI_MPU>;
+};
+
+&cpu1 {
+	clocks = <&scmi_clk CK_SCMI_MPU>;
+};
+
+&gpioz {
+	clocks = <&scmi_clk CK_SCMI_GPIOZ>;
+};
+
+&hash1 {
+	clocks = <&scmi_clk CK_SCMI_HASH1>;
+	resets = <&scmi_reset RST_SCMI_HASH1>;
+};
+
+&i2c4 {
+	clocks = <&scmi_clk CK_SCMI_I2C4>;
+	resets = <&scmi_reset RST_SCMI_I2C4>;
+};
+
+&i2c6 {
+	clocks = <&scmi_clk CK_SCMI_I2C6>;
+	resets = <&scmi_reset RST_SCMI_I2C6>;
+};
+
+&iwdg2 {
+	clocks = <&rcc IWDG2>, <&scmi_clk CK_SCMI_LSI>;
+};
+
+&m4_rproc {
+	resets = <&scmi_reset RST_SCMI_MCU>,
+		 <&scmi_reset RST_SCMI_MCU_HOLD_BOOT>;
+	reset-names = "mcu_rst", "hold_boot";
+	/delete-property/ st,syscfg-holdboot;
+};
+
+&m_can1 {
+        clocks = <&scmi_clk CK_SCMI_HSE>, <&rcc FDCAN_K>;
+};
+
+&m_can2 {
+	clocks = <&scmi_clk CK_SCMI_HSE>, <&rcc FDCAN_K>;
+};
+
+&mdma1 {
+	resets = <&scmi_reset RST_SCMI_MDMA>;
+};
+
+&mlahb {
+	resets = <&scmi_reset RST_SCMI_MCU>;
+};
+
+&rcc {
+	compatible = "st,stm32mp1-rcc-secure", "syscon";
+	clock-names = "hse", "hsi", "csi", "lse", "lsi";
+	clocks = <&scmi_clk CK_SCMI_HSE>,
+		 <&scmi_clk CK_SCMI_HSI>,
+		 <&scmi_clk CK_SCMI_CSI>,
+		 <&scmi_clk CK_SCMI_LSE>,
+		 <&scmi_clk CK_SCMI_LSI>;
+};
+
+&rng1 {
+	clocks = <&scmi_clk CK_SCMI_RNG1>;
+	resets = <&scmi_reset RST_SCMI_RNG1>;
+};
+
+&rtc {
+	clocks = <&scmi_clk CK_SCMI_RTCAPB>, <&scmi_clk CK_SCMI_RTC>;
+};
+
+&spi6 {
+	clocks = <&scmi_clk CK_SCMI_SPI6>;
+	resets = <&scmi_reset RST_SCMI_SPI6>;
+};
+
+&usart1 {
+	clocks = <&scmi_clk CK_SCMI_USART1>;
+};
diff --git a/arch/arm/boot/dts/st/stm32mp15xx-phycore-som-pinctrl.dtsi b/arch/arm/boot/dts/st/stm32mp15xx-phycore-som-pinctrl.dtsi
new file mode 100644
index 000000000000..eb51ce9c72ba
--- /dev/null
+++ b/arch/arm/boot/dts/st/stm32mp15xx-phycore-som-pinctrl.dtsi
@@ -0,0 +1,237 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)
+/*
+ * Copyright (C) 2020 PHYTEC Messtechnik GmbH
+ * Authors: Dom Vovard <dom.vovard@linrt.com>
+ *	    Christophe Parant <c.parant@phytec.fr>
+ */
+
+#include <dt-bindings/pinctrl/stm32-pinfunc.h>
+
+&pinctrl {
+	ethernet0_rgmii_pins_a: rgmii-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('G', 5, AF11)>, /* ETH_RGMII_CLK125 */
+				 <STM32_PINMUX('G', 4, AF11)>, /* ETH_RGMII_GTX_CLK */
+				 <STM32_PINMUX('G', 13, AF11)>, /* ETH_RGMII_TXD0 */
+				 <STM32_PINMUX('G', 14, AF11)>, /* ETH_RGMII_TXD1 */
+				 <STM32_PINMUX('C', 2, AF11)>, /* ETH_RGMII_TXD2 */
+				 <STM32_PINMUX('E', 2, AF11)>, /* ETH_RGMII_TXD3 */
+				 <STM32_PINMUX('B', 11, AF11)>, /* ETH_RGMII_TX_CTL */
+				 <STM32_PINMUX('A', 2, AF11)>, /* ETH_MDIO */
+				 <STM32_PINMUX('C', 1, AF11)>; /* ETH_MDC */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <2>;
+		};
+		pins2 {
+			pinmux = <STM32_PINMUX('C', 4, AF11)>, /* ETH_RGMII_RXD0 */
+				 <STM32_PINMUX('C', 5, AF11)>, /* ETH_RGMII_RXD1 */
+				 <STM32_PINMUX('H', 6, AF11)>, /* ETH_RGMII_RXD2 */
+				 <STM32_PINMUX('B', 1, AF11)>, /* ETH_RGMII_RXD3 */
+				 <STM32_PINMUX('A', 1, AF11)>, /* ETH_RGMII_RX_CLK */
+				 <STM32_PINMUX('A', 7, AF11)>; /* ETH_RGMII_RX_CTL */
+			bias-disable;
+		};
+	};
+
+	ethernet0_rgmii_pins_sleep_a: rgmii-sleep-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('G', 5, ANALOG)>, /* ETH_RGMII_CLK125 */
+				 <STM32_PINMUX('G', 4, ANALOG)>, /* ETH_RGMII_GTX_CLK */
+				 <STM32_PINMUX('G', 13, ANALOG)>, /* ETH_RGMII_TXD0 */
+				 <STM32_PINMUX('G', 14, ANALOG)>, /* ETH_RGMII_TXD1 */
+				 <STM32_PINMUX('C', 2, ANALOG)>, /* ETH_RGMII_TXD2 */
+				 <STM32_PINMUX('E', 2, ANALOG)>, /* ETH_RGMII_TXD3 */
+				 <STM32_PINMUX('B', 11, ANALOG)>, /* ETH_RGMII_TX_CTL */
+				 <STM32_PINMUX('A', 2, ANALOG)>, /* ETH_MDIO */
+				 <STM32_PINMUX('C', 1, ANALOG)>, /* ETH_MDC */
+				 <STM32_PINMUX('C', 4, ANALOG)>, /* ETH_RGMII_RXD0 */
+				 <STM32_PINMUX('C', 5, ANALOG)>, /* ETH_RGMII_RXD1 */
+				 <STM32_PINMUX('H', 6, ANALOG)>, /* ETH_RGMII_RXD2 */
+				 <STM32_PINMUX('B', 1, ANALOG)>, /* ETH_RGMII_RXD3 */
+				 <STM32_PINMUX('A', 1, ANALOG)>, /* ETH_RGMII_RX_CLK */
+				 <STM32_PINMUX('A', 7, ANALOG)>; /* ETH_RGMII_RX_CTL */
+		};
+	};
+
+	fmc_pins_a: fmc-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('D', 4, AF12)>, /* FMC_NOE */
+				 <STM32_PINMUX('D', 5, AF12)>, /* FMC_NWE */
+				 <STM32_PINMUX('D', 11, AF12)>, /* FMC_A16_FMC_CLE */
+				 <STM32_PINMUX('D', 12, AF12)>, /* FMC_A17_FMC_ALE */
+				 <STM32_PINMUX('D', 14, AF12)>, /* FMC_D0 */
+				 <STM32_PINMUX('D', 15, AF12)>, /* FMC_D1 */
+				 <STM32_PINMUX('D', 0, AF12)>, /* FMC_D2 */
+				 <STM32_PINMUX('D', 1, AF12)>, /* FMC_D3 */
+				 <STM32_PINMUX('E', 7, AF12)>, /* FMC_D4 */
+				 <STM32_PINMUX('E', 8, AF12)>, /* FMC_D5 */
+				 <STM32_PINMUX('E', 9, AF12)>, /* FMC_D6 */
+				 <STM32_PINMUX('E', 10, AF12)>, /* FMC_D7 */
+				 <STM32_PINMUX('G', 9, AF12)>; /* FMC_NE2_FMC_NCE */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <1>;
+		};
+		pins2 {
+			pinmux = <STM32_PINMUX('D', 6, AF12)>; /* FMC_NWAIT */
+			bias-pull-up;
+		};
+	};
+
+	fmc_sleep_pins_a: fmc-sleep-0 {
+		pins {
+			pinmux = <STM32_PINMUX('D', 4, ANALOG)>, /* FMC_NOE */
+				 <STM32_PINMUX('D', 5, ANALOG)>, /* FMC_NWE */
+				 <STM32_PINMUX('D', 11, ANALOG)>, /* FMC_A16_FMC_CLE */
+				 <STM32_PINMUX('D', 12, ANALOG)>, /* FMC_A17_FMC_ALE */
+				 <STM32_PINMUX('D', 14, ANALOG)>, /* FMC_D0 */
+				 <STM32_PINMUX('D', 15, ANALOG)>, /* FMC_D1 */
+				 <STM32_PINMUX('D', 0, ANALOG)>, /* FMC_D2 */
+				 <STM32_PINMUX('D', 1, ANALOG)>, /* FMC_D3 */
+				 <STM32_PINMUX('E', 7, ANALOG)>, /* FMC_D4 */
+				 <STM32_PINMUX('E', 8, ANALOG)>, /* FMC_D5 */
+				 <STM32_PINMUX('E', 9, ANALOG)>, /* FMC_D6 */
+				 <STM32_PINMUX('E', 10, ANALOG)>, /* FMC_D7 */
+				 <STM32_PINMUX('D', 6, ANALOG)>, /* FMC_NWAIT */
+				 <STM32_PINMUX('G', 9, ANALOG)>; /* FMC_NE2_FMC_NCE */
+		};
+	};
+
+	qspi_bk1_pins_a: qspi-bk1-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('F', 8, AF10)>, /* QSPI_BK1_IO0 */
+				 <STM32_PINMUX('F', 9, AF10)>, /* QSPI_BK1_IO1 */
+				 <STM32_PINMUX('F', 7, AF9)>, /* QSPI_BK1_IO2 */
+				 <STM32_PINMUX('F', 6, AF9)>; /* QSPI_BK1_IO3 */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <1>;
+		};
+		pins2 {
+			pinmux = <STM32_PINMUX('B', 6, AF10)>; /* QSPI_BK1_NCS */
+			bias-pull-up;
+			drive-push-pull;
+			slew-rate = <1>;
+		};
+	};
+
+	qspi_bk1_sleep_pins_a: qspi-bk1-sleep-0 {
+		pins {
+			pinmux = <STM32_PINMUX('F', 8, ANALOG)>, /* QSPI_BK1_IO0 */
+				 <STM32_PINMUX('F', 9, ANALOG)>, /* QSPI_BK1_IO1 */
+				 <STM32_PINMUX('F', 7, ANALOG)>, /* QSPI_BK1_IO2 */
+				 <STM32_PINMUX('F', 6, ANALOG)>, /* QSPI_BK1_IO3 */
+				 <STM32_PINMUX('B', 6, ANALOG)>; /* QSPI_BK1_NCS */
+		};
+	};
+
+	qspi_clk_pins_a: qspi-clk-0 {
+		pins {
+			pinmux = <STM32_PINMUX('F', 10, AF9)>; /* QSPI_CLK */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <3>;
+		};
+	};
+
+	qspi_clk_sleep_pins_a: qspi-clk-sleep-0 {
+		pins {
+			pinmux = <STM32_PINMUX('F', 10, ANALOG)>; /* QSPI_CLK */
+		};
+	};
+
+	sdmmc2_b4_pins_a: sdmmc2-b4-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('B', 14, AF9)>, /* SDMMC2_D0 */
+				 <STM32_PINMUX('B', 15, AF9)>, /* SDMMC2_D1 */
+				 <STM32_PINMUX('B', 3, AF9)>, /* SDMMC2_D2 */
+				 <STM32_PINMUX('B', 4, AF9)>, /* SDMMC2_D3 */
+				 <STM32_PINMUX('G', 6, AF10)>; /* SDMMC2_CMD */
+			slew-rate = <1>;
+			drive-push-pull;
+			bias-pull-up;
+		};
+		pins2 {
+			pinmux = <STM32_PINMUX('E', 3, AF9)>; /* SDMMC2_CK */
+			slew-rate = <2>;
+			drive-push-pull;
+			bias-pull-up;
+		};
+	};
+
+	sdmmc2_b4_od_pins_a: sdmmc2-b4-od-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('B', 14, AF9)>, /* SDMMC2_D0 */
+				 <STM32_PINMUX('B', 15, AF9)>, /* SDMMC2_D1 */
+				 <STM32_PINMUX('B', 3, AF9)>, /* SDMMC2_D2 */
+				 <STM32_PINMUX('B', 4, AF9)>; /* SDMMC2_D3 */
+			slew-rate = <1>;
+			drive-push-pull;
+			bias-pull-up;
+		};
+		pins2 {
+			pinmux = <STM32_PINMUX('E', 3, AF9)>; /* SDMMC2_CK */
+			slew-rate = <2>;
+			drive-push-pull;
+			bias-pull-up;
+		};
+		pins3 {
+			pinmux = <STM32_PINMUX('G', 6, AF10)>; /* SDMMC2_CMD */
+			slew-rate = <1>;
+			drive-open-drain;
+			bias-pull-up;
+		};
+	};
+
+	sdmmc2_b4_sleep_pins_a: sdmmc2-b4-sleep-0 {
+		pins {
+			pinmux = <STM32_PINMUX('B', 14, ANALOG)>, /* SDMMC2_D0 */
+				 <STM32_PINMUX('B', 15, ANALOG)>, /* SDMMC2_D1 */
+				 <STM32_PINMUX('B', 3, ANALOG)>, /* SDMMC2_D2 */
+				 <STM32_PINMUX('B', 4, ANALOG)>, /* SDMMC2_D3 */
+				 <STM32_PINMUX('E', 3, ANALOG)>, /* SDMMC2_CK */
+				 <STM32_PINMUX('G', 6, ANALOG)>; /* SDMMC2_CMD */
+		};
+	};
+
+	sdmmc2_d47_pins_a: sdmmc2-d47-0 {
+		pins {
+			pinmux = <STM32_PINMUX('A', 8, AF9)>, /* SDMMC2_D4 */
+				 <STM32_PINMUX('A', 9, AF10)>, /* SDMMC2_D5 */
+				 <STM32_PINMUX('C', 6, AF10)>, /* SDMMC2_D6 */
+				 <STM32_PINMUX('D', 3, AF9)>; /* SDMMC2_D7 */
+			slew-rate = <1>;
+			drive-push-pull;
+			bias-pull-up;
+		};
+	};
+
+	sdmmc2_d47_sleep_pins_a: sdmmc2-d47-sleep-0 {
+		pins {
+			pinmux = <STM32_PINMUX('A', 8, ANALOG)>, /* SDMMC2_D4 */
+				 <STM32_PINMUX('A', 9, ANALOG)>, /* SDMMC2_D5 */
+				 <STM32_PINMUX('C', 6, ANALOG)>, /* SDMMC2_D6 */
+				 <STM32_PINMUX('D', 3, ANALOG)>; /* SDMMC2_D7 */
+		};
+	};
+};
+
+&pinctrl_z {
+	i2c4_pins_a: i2c4-0 {
+		pins {
+			pinmux = <STM32_PINMUX('Z', 4, AF6)>, /* I2C4_SCL */
+				 <STM32_PINMUX('Z', 5, AF6)>; /* I2C4_SDA */
+			bias-disable;
+			drive-open-drain;
+			slew-rate = <0>;
+		};
+	};
+
+	i2c4_pins_sleep_a: i2c4-1 {
+		pins {
+			pinmux = <STM32_PINMUX('Z', 4, ANALOG)>, /* I2C4_SCL */
+				 <STM32_PINMUX('Z', 5, ANALOG)>; /* I2C4_SDA */
+		};
+	};
+};
diff --git a/arch/arm/boot/dts/st/stm32mp15xx-phycore-som.dtsi b/arch/arm/boot/dts/st/stm32mp15xx-phycore-som.dtsi
new file mode 100644
index 000000000000..2a87e97fa3e2
--- /dev/null
+++ b/arch/arm/boot/dts/st/stm32mp15xx-phycore-som.dtsi
@@ -0,0 +1,390 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)
+/*
+ * Copyright (C) 2020 PHYTEC Messtechnik GmbH
+ * Authors: Dom Vovard <dom.vovard@linrt.com>
+ *	    Christophe Parant <c.parant@phytec.fr>
+ */
+
+#include "stm32mp15xx-phycore-som-pinctrl.dtsi"
+#include "stm32mp15xxac-pinctrl.dtsi"
+#include "stm32mp15-m4-srm.dtsi"
+#include <dt-bindings/gpio/gpio.h>
+#include <dt-bindings/input/input.h>
+#include <dt-bindings/mfd/st,stpmic1.h>
+#include <dt-bindings/net/ti-dp83867.h>
+#include <dt-bindings/rtc/rtc-stm32.h>
+
+/ {
+	aliases {
+		mmc0 = &sdmmc1;
+		mmc1 = &sdmmc2;
+		mmc2 = &sdmmc3;
+	};
+
+	reserved-memory {
+		#address-cells = <1>;
+		#size-cells = <1>;
+		ranges;
+
+		retram: retram@0x38000000 {
+			compatible = "shared-dma-pool";
+			reg = <0x38000000 0x10000>;
+			no-map;
+		};
+
+		mcuram: mcuram@0x30000000 {
+			compatible = "shared-dma-pool";
+			reg = <0x30000000 0x40000>;
+			no-map;
+		};
+
+		mcuram2: mcuram2@0x10000000 {
+			compatible = "shared-dma-pool";
+			reg = <0x10000000 0x40000>;
+			no-map;
+		};
+
+		mcu_rsc_table: mcu-rsc-table@10048000 {
+			compatible = "shared-dma-pool";
+			reg = <0x10048000 0x8000>;
+			no-map;
+		};
+
+		vdev0vring0: vdev0vring0@10040000 {
+			compatible = "shared-dma-pool";
+			reg = <0x10040000 0x2000>;
+			no-map;
+		};
+
+		vdev0vring1: vdev0vring1@10042000 {
+			compatible = "shared-dma-pool";
+			reg = <0x10042000 0x2000>;
+			no-map;
+		};
+
+		vdev0buffer: vdev0buffer@10044000 {
+			compatible = "shared-dma-pool";
+			reg = <0x10044000 0x4000>;
+			no-map;
+		};
+	};
+
+	vin: vin {
+		compatible = "regulator-fixed";
+		regulator-name = "vin";
+		regulator-min-microvolt = <5000000>;
+		regulator-max-microvolt = <5000000>;
+		regulator-always-on;
+	};
+
+};
+
+&cpu0{
+	cpu-supply = <&vddcore>;
+};
+
+&cpu1{
+	cpu-supply = <&vddcore>;
+};
+
+&dts {
+	status = "okay";
+};
+
+&hash1 {
+	status = "okay";
+};
+
+&crc1 {
+	status = "okay";
+};
+
+&i2c4 {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&i2c4_pins_a>;
+	pinctrl-1 = <&i2c4_pins_sleep_a>;
+	i2c-scl-rising-time-ns = <185>;
+	i2c-scl-falling-time-ns = <20>;
+	status = "okay";
+	/* spare dmas for other usage */
+	/delete-property/dmas;
+	/delete-property/dma-names;
+
+	pmic: stpmic@33 {
+		compatible = "st,stpmic1";
+		reg = <0x33>;
+		interrupts-extended = <&exti 55 IRQ_TYPE_EDGE_FALLING>;
+		interrupt-controller;
+		#interrupt-cells = <2>;
+		status = "okay";
+		wakeup-source;
+
+		regulators {
+			compatible = "st,stpmic1-regulators";
+			buck1-supply = <&vin>;
+			buck2-supply = <&vin>;
+			buck3-supply = <&vin>;
+			buck4-supply = <&vin>;
+			ldo1-supply = <&v3v3>;
+			ldo2-supply = <&v3v3>;
+			ldo3-supply = <&vdd_ddr>;
+			ldo4-supply = <&vin>;
+			ldo5-supply = <&v3v3>;
+			ldo6-supply = <&v3v3>;
+			vref_ddr-supply = <&vin>;
+			boost-supply = <&vin>;
+			pwr_sw1-supply = <&bst_out>;
+			pwr_sw2-supply = <&bst_out>;
+
+			vddcore: buck1 {
+				regulator-name = "vddcore";
+				regulator-min-microvolt = <1200000>;
+				regulator-max-microvolt = <1350000>;
+				regulator-always-on;
+				regulator-initial-mode = <0>;
+				regulator-over-current-protection;
+			};
+
+			vdd_ddr: buck2 {
+				regulator-name = "vdd_ddr";
+				regulator-min-microvolt = <1350000>;
+				regulator-max-microvolt = <1350000>;
+				regulator-always-on;
+				regulator-initial-mode = <0>;
+				regulator-over-current-protection;
+			};
+
+			vdd: buck3 {
+				regulator-name = "vdd";
+				regulator-min-microvolt = <3300000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-always-on;
+				st,mask-reset;
+				regulator-initial-mode = <0>;
+				regulator-over-current-protection;
+			};
+
+			v3v3: buck4 {
+				regulator-name = "v3v3";
+				regulator-min-microvolt = <3300000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-always-on;
+				regulator-over-current-protection;
+				regulator-initial-mode = <0>;
+			};
+
+			v1v8_audio: ldo1 {
+				regulator-name = "v1v8_audio";
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <1800000>;
+				regulator-always-on;
+				interrupts = <IT_CURLIM_LDO1 0>;
+			};
+
+			vdd_eth_2v5: ldo2 {
+				regulator-name = "dd_eth_2v5";
+				regulator-min-microvolt = <2500000>;
+				regulator-max-microvolt = <2500000>;
+				regulator-always-on;
+				interrupts = <IT_CURLIM_LDO2 0>;
+			};
+
+			vtt_ddr: ldo3 {
+				regulator-name = "vtt_ddr";
+				regulator-min-microvolt = <500000>;
+				regulator-max-microvolt = <750000>;
+				regulator-always-on;
+				regulator-over-current-protection;
+			};
+
+			vdd_usb: ldo4 {
+				regulator-name = "vdd_usb";
+				regulator-min-microvolt = <3300000>;
+				regulator-max-microvolt = <3300000>;
+				interrupts = <IT_CURLIM_LDO4 0>;
+			};
+
+			vdda: ldo5 {
+				regulator-name = "vdda";
+				regulator-min-microvolt = <2900000>;
+				regulator-max-microvolt = <2900000>;
+				interrupts = <IT_CURLIM_LDO5 0>;
+				regulator-boot-on;
+			};
+
+			vdd_eth_1v0: ldo6 {
+				regulator-name = "vdd_eth_1v0";
+				regulator-min-microvolt = <1000000>;
+				regulator-max-microvolt = <1000000>;
+				regulator-always-on;
+				interrupts = <IT_CURLIM_LDO6 0>;
+			};
+
+			vref_ddr: vref-ddr {
+				regulator-name = "vref_ddr";
+				regulator-always-on;
+				regulator-over-current-protection;
+			};
+
+			bst_out: boost {
+				regulator-name = "bst_out";
+				interrupts = <IT_OCP_BOOST 0>;
+			};
+
+			vbus_otg: pwr-sw1 {
+				regulator-name = "vbus_otg";
+				interrupts = <IT_OCP_OTG 0>;
+				regulator-active-discharge;
+			};
+
+			vbus_sw: pwr-sw2 {
+				regulator-name = "vbus_sw";
+				interrupts = <IT_OCP_SWOUT 0>;
+				regulator-active-discharge;
+			};
+		};
+
+		onkey {
+			compatible = "st,stpmic1-onkey";
+			interrupts = <IT_PONKEY_F 0>, <IT_PONKEY_R 0>;
+			interrupt-names = "onkey-falling", "onkey-rising";
+			power-off-time-sec = <10>;
+			status = "okay";
+		};
+
+		watchdog {
+			compatible = "st,stpmic1-wdt";
+			status = "disabled";
+		};
+	};
+
+	i2c4_eeprom: eeprom@50 {
+		compatible = "microchip,24c32", "atmel,24c32";
+		reg = <0x50>;
+		status = "disabled";
+	};
+
+	i2c4_rtc: rtc@52 {
+		compatible = "microcrystal,rv3028";
+		reg = <0x52>;
+		enable-level-switching-mode;
+		status = "disabled";
+	};
+};
+
+&ethernet0 {
+	status = "okay";
+	pinctrl-0 = <&ethernet0_rgmii_pins_a>;
+	pinctrl-1 = <&ethernet0_rgmii_pins_sleep_a>;
+	pinctrl-names = "default", "sleep";
+	phy-mode = "rgmii-id";
+	max-speed = <1000>;
+	phy-handle = <&phy0>;
+	nvmem-cells = <&ethernet_mac_address>;
+	nvmem-cell-names = "mac-address";
+
+	mdio0 {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		compatible = "snps,dwmac-mdio";
+
+		phy0: ethernet-phy@1 {
+			compatible = "ethernet-phy-ieee802.3-c22";
+			reg = <1>;
+			interrupt-parent = <&gpiog>;
+			interrupts = <12 IRQ_TYPE_EDGE_FALLING>;
+			ti,rx-internal-delay = <DP83867_RGMIIDCTL_2_00_NS>;
+			ti,tx-internal-delay = <DP83867_RGMIIDCTL_2_00_NS>;
+			ti,fifo-depth = <DP83867_PHYCR_FIFO_DEPTH_4_B_NIB>;
+			ti,min-output-impedance;
+			enet-phy-lane-no-swap;
+			ti,clk-output-sel = <DP83867_CLK_O_SEL_CHN_A_RCLK>;
+		};
+	};
+};
+
+&m4_rproc {
+	memory-region = <&retram>, <&mcuram>, <&mcuram2>, <&vdev0vring0>,
+			<&vdev0vring1>, <&vdev0buffer>, <&mcu_rsc_table>;
+	mboxes = <&ipcc 0>, <&ipcc 1>, <&ipcc 2>;
+	mbox-names = "vq0", "vq1", "shutdown";
+	interrupt-parent = <&exti>;
+	interrupts = <68 1>;
+	wakeup-source;
+	status = "okay";
+};
+
+&ipcc {
+	status = "okay";
+};
+
+&arm_wdt {
+	timeout-sec = <32>;
+	status = "okay";
+};
+
+&pwr_regulators {
+	vdd-supply = <&vdd>;
+	vdd_3v3_usbfs-supply = <&vdd_usb>;
+};
+
+&rtc {
+	status = "okay";
+};
+
+&qspi {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&qspi_clk_pins_a &qspi_bk1_pins_a>;
+	pinctrl-1 = <&qspi_clk_sleep_pins_a &qspi_bk1_sleep_pins_a>;
+	reg = <0x58003000 0x1000>, <0x70000000 0x4000000>;
+	#address-cells = <1>;
+	#size-cells = <0>;
+	status = "disabled";
+
+	flash0: w25q128@0 {
+		compatible = "winbond,w25q128", "jedec,spi-nor", "spi-flash";
+		reg = <0>;
+		spi-rx-bus-width = <4>;
+		spi-max-frequency = <50000000>;
+		m25p,fast-read;
+		#address-cells = <1>;
+		#size-cells = <1>;
+	};
+};
+
+&fmc {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&fmc_pins_a>;
+	pinctrl-1 = <&fmc_sleep_pins_a>;
+	status = "disabled";
+
+	nand-controller@4,0 {
+		status = "okay";
+
+		nand: nand@0 {
+			reg = <0>;
+			nand-on-flash-bbt;
+			nand-ecc-strength = <4>;
+			nand-ecc-step-size = <512>;
+			#address-cells = <1>;
+			#size-cells = <1>;
+		};
+	};
+};
+
+&sdmmc2 {
+	pinctrl-names = "default", "opendrain", "sleep";
+	pinctrl-0 = <&sdmmc2_b4_pins_a &sdmmc2_d47_pins_a>;
+	pinctrl-1 = <&sdmmc2_b4_od_pins_a &sdmmc2_d47_pins_a>;
+	pinctrl-2 = <&sdmmc2_b4_sleep_pins_a &sdmmc2_d47_sleep_pins_a>;
+	non-removable;
+	no-sd;
+	no-sdio;
+	st,neg-edge;
+	bus-width = <8>;
+	vmmc-supply = <&v3v3>;
+	vqmmc-supply = <&v3v3>;
+	mmc-ddr-3_3v;
+	status = "disabled";
+};
+
diff --git a/drivers/gpu/drm/panel/panel-raspberrypi-touchscreen.c b/drivers/gpu/drm/panel/panel-raspberrypi-touchscreen.c
index 4618c892cdd6..cb15037ebbec 100644
--- a/drivers/gpu/drm/panel/panel-raspberrypi-touchscreen.c
+++ b/drivers/gpu/drm/panel/panel-raspberrypi-touchscreen.c
@@ -195,6 +195,42 @@ struct rpi_touchscreen {
 };
 
 static const struct drm_display_mode rpi_touchscreen_modes[] = {
+	{
+		/* Modeline for 25862069 clock */
+		.clock = 25862069 / 1000,
+		.hdisplay = 800,
+		.hsync_start = 800 + 1,
+		.hsync_end = 800 + 1 + 2,
+		.htotal = 800 + 1 + 2 + 45,
+		.vdisplay = 480,
+		.vsync_start = 480 + 7,
+		.vsync_end = 480 + 7 + 2,
+		.vtotal = 480 + 7 + 2 + 20,
+	},
+	{
+		/* (800 + 200) * (480 + 20) * 50 = 25000000 */
+		.clock = 25000000 / 1000,
+		.hdisplay = 800,
+		.hsync_start = 800 + 154,
+		.hsync_end = 800 + 154 + 2,
+		.htotal = 800 + 154 + 2 + 42,
+		.vdisplay = 480,
+		.vsync_start = 480 + 1,
+		.vsync_end = 480 + 1 + 2,
+		.vtotal = 480 + 1 + 2 + 17,
+	},
+	{
+		/* (800 + 100) * (480 + 70) * 50 = 24750000 */
+		.clock = 24750000 / 1000,
+		.hdisplay = 800,
+		.hsync_start = 800 + 54,
+		.hsync_end = 800 + 54 + 2,
+		.htotal = 800 + 54 + 2 + 44,
+		.vdisplay = 480,
+		.vsync_start = 480 + 49,
+		.vsync_end = 480 + 49 + 2,
+		.vtotal = 480 + 49 + 2 + 19,
+	},
 	{
 		/* Modeline comes from the Raspberry Pi firmware, with HFP=1
 		 * plugged in and clock re-computed from that.
@@ -267,12 +303,13 @@ static int rpi_touchscreen_noop(struct drm_panel *panel)
 static int rpi_touchscreen_prepare(struct drm_panel *panel)
 {
 	struct rpi_touchscreen *ts = panel_to_ts(panel);
-	int i;
+	int i, val;
 
 	rpi_touchscreen_i2c_write(ts, REG_POWERON, 1);
 	/* Wait for nPWRDWN to go low to indicate poweron is done. */
 	for (i = 0; i < 100; i++) {
-		if (rpi_touchscreen_i2c_read(ts, REG_PORTB) & 1)
+		val = rpi_touchscreen_i2c_read(ts, REG_PORTB);
+		if (val >= 0 && (val & 1))
 			break;
 	}
 
@@ -382,6 +419,8 @@ static int rpi_touchscreen_probe(struct i2c_client *i2c)
 	ts->i2c = i2c;
 
 	ver = rpi_touchscreen_i2c_read(ts, REG_ID);
+	if (ver < 0)
+		ver = rpi_touchscreen_i2c_read(ts, REG_ID);
 	if (ver < 0) {
 		dev_err(dev, "Atmel I2C read failed: %d\n", ver);
 		return -ENODEV;
diff --git a/drivers/media/i2c/Kconfig b/drivers/media/i2c/Kconfig
index 03dd3e0ab166..1a394a163cf5 100644
--- a/drivers/media/i2c/Kconfig
+++ b/drivers/media/i2c/Kconfig
@@ -214,6 +214,16 @@ config VIDEO_IMX415
 config VIDEO_MAX9271_LIB
 	tristate
 
+config VIDEO_AR0144
+	tristate "ON Semiconductor AR0144 sensor support"
+	help
+	  This driver supports AR0144 cameras from Onsemiconductor, monochrome
+	  and colour models are supported as well as MIPI and parallel
+	  interface.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called ar0144.
+
 config VIDEO_MT9M001
 	tristate "mt9m001 support"
 	help
diff --git a/drivers/media/i2c/Makefile b/drivers/media/i2c/Makefile
index e74eded89428..b75d71940e36 100644
--- a/drivers/media/i2c/Makefile
+++ b/drivers/media/i2c/Makefile
@@ -19,6 +19,7 @@ obj-$(CONFIG_VIDEO_AK7375) += ak7375.o
 obj-$(CONFIG_VIDEO_AK881X) += ak881x.o
 obj-$(CONFIG_VIDEO_APTINA_PLL) += aptina-pll.o
 obj-$(CONFIG_VIDEO_AR0521) += ar0521.o
+obj-$(CONFIG_VIDEO_AR0144) += ar0144.o
 obj-$(CONFIG_VIDEO_BT819) += bt819.o
 obj-$(CONFIG_VIDEO_BT856) += bt856.o
 obj-$(CONFIG_VIDEO_BT866) += bt866.o
diff --git a/drivers/media/i2c/ar0144.c b/drivers/media/i2c/ar0144.c
new file mode 100644
index 000000000000..80a15753d72c
--- /dev/null
+++ b/drivers/media/i2c/ar0144.c
@@ -0,0 +1,4138 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Copyright (C) 2018 Enrico Scholz <enrico.scholz@sigma-chemnitz.de>
+ * Copyright (C) 2020 PHYTEC Messtechnik GmbH
+ * Author: Enrico Scholz <enrico.scholz@sigma-chemnitz.de>
+ * Author: Stefan Riedmueller <s.riedmueller@phytec.de>
+ */
+
+#include <linux/module.h>
+#include <linux/errno.h>
+#include <linux/i2c.h>
+#include <linux/clk.h>
+#include <linux/device.h>
+#include <linux/of.h>
+#include <linux/regulator/consumer.h>
+#include <linux/gpio/consumer.h>
+#include <linux/delay.h>
+
+#include <linux/of_graph.h>
+
+#include <linux/v4l2-mediabus.h>
+#include <media/mipi-csi2.h>
+#include <media/v4l2-async.h>
+#include <media/v4l2-device.h>
+#include <media/v4l2-subdev.h>
+#include <media/v4l2-fwnode.h>
+#include <media/v4l2-ctrls.h>
+
+#include "vvsensor.h"
+
+#define AR0144_MODEL_ID					0x3000
+#define AR0144_Y_ADDR_START				0x3002
+#define AR0144_X_ADDR_START				0x3004
+#define AR0144_Y_ADRR_END				0x3006
+#define AR0144_X_ADRR_END				0x3008
+#define AR0144_FRAME_LENGTH_LINES			0x300a
+#define AR0144_LINE_LENGTH_PCK				0x300c
+#define AR0144_REVISION					0x300e
+#define	AR0144_COARSE_INT_TIME				0x3012
+#define	AR0144_FINE_INT_TIME				0x3014
+#define AR0144_RESET_REGISTER				0x301a
+#define		BIT_GROUPED_PARAM_HOLD			BIT(15)
+#define		BIT_SMIA_SER_DIS			BIT(12)
+#define		BIT_FORCED_PLL_ON			BIT(11)
+#define		BIT_RESTART_BAD				BIT(10)
+#define		BIT_MASK_BAD				BIT(9)
+#define		BIT_GPI_EN				BIT(8)
+#define		BIT_PARALLEL_EN				BIT(7)
+#define		BIT_DRIVE_PINS				BIT(6)
+#define		BIT_LOCK_REG				BIT(3)
+#define		BIT_STREAM				BIT(2)
+#define		BIT_RESTART				BIT(1)
+#define		BIT_RESET				BIT(0)
+#define	AR0144_DATA_PEDESTAL				0x301e
+#define	AR0144_VT_PIX_CLK_DIV				0x302a
+#define	AR0144_VT_SYS_CLK_DIV				0x302c
+#define AR0144_PRE_PLL_CLK_DIV				0x302e
+#define AR0144_PLL_MUL					0x3030
+#define	AR0144_OP_PIX_CLK_DIV				0x3036
+#define	AR0144_OP_SYS_CLK_DIV				0x3038
+#define AR0144_FRAME_COUNT				0x303a
+#define AR0144_FRAME_STATUS				0x303c
+#define		BIT_PLL_LOCKED				BIT(3)
+#define		BIT_FRAME_START_DURING_GPH		BIT(2)
+#define		BIT_STANDBY_STATUS			BIT(1)
+#define		BIT_FRAMESYNC				BIT(0)
+#define	AR0144_READ_MODE				0x3040
+#define		BIT_VERT_FLIP				BIT(15)
+#define		BIT_HORIZ_MIRROR			BIT(14)
+#define		BIT_RM_COL_BIN				BIT(13)
+#define		BIT_RM_ROW_BIN				BIT(12)
+#define		BIT_RM_COL_SF_BIN			BIT(9)
+#define		BIT_RM_COL_SF_BIN_MONO			BIT(7)
+#define		BIT_RM_COL_SUM				BIT(5)
+#define	AR0144_GREENR_GAIN				0x3056
+#define	AR0144_BLUE_GAIN				0x3058
+#define	AR0144_RED_GAIN					0x305a
+#define	AR0144_GREENB_GAIN				0x305c
+#define	AR0144_GLOBAL_GAIN				0x305e
+#define	AR0144_ANALOG_GAIN				0x3060
+#define		BIT_COARSE_GAIN(n)			((n) << 4)
+#define		BIT_COARSE_GAIN_MASK			GENMASK(6, 4)
+#define		BIT_FINE_GAIN(n)			(n)
+#define		BIT_FINE_GAIN_MASK			0xf
+#define AR0144_SMIA_TEST				0x3064
+#define		BIT_EMBEDDED_DATA			BIT(8)
+#define		BIT_EMBEDDED_STATS_EN			BIT(7)
+#define	AR0144_DATAPATH_SEL				0x306e
+#define		BIT_SLEW_RATE_DAT(n)			((n) << 13)
+#define		BIT_SLEW_RATE_DAT_MASK			GENMASK(15, 13)
+#define		BIT_SLEW_RATE_CLK(n)			((n) << 10)
+#define		BIT_SLEW_RATE_CLK_MASK			GENMASK(12, 10)
+#define	AR0144_TEST_PATTERN				0x3070
+#define	AR0144_TEST_DATA_RED				0x3072
+#define	AR0144_TEST_DATA_GREENR				0x3074
+#define	AR0144_TEST_DATA_BLUE				0x3076
+#define	AR0144_TEST_DATA_GREENB				0x3078
+#define	AR0144_X_ODD_INC				0x30a2
+#define	AR0144_Y_ODD_INC				0x30a6
+#define	AR0144_DIGITAL_TEST				0x30b0
+#define		BIT_PLL_BYPASS				BIT(14)
+#define		BIT_PIXCLK_ON				BIT(8)
+#define		BIT_MONOCHROME_OP			BIT(7)
+#define AR0144_TEMPSENS_DATA				0x30b2
+#define AR0144_TEMPSENS_CTRL				0x30b4
+#define		BIT_RETRIG_THRESHOLD(n)			((n) << 6)
+#define		BIT_RETRIG_THRESHOLD_MASK		GENMASK(15, 6)
+#define		BIT_TEMP_CLEAR				BIT(5)
+#define		BIT_TEMP_START_CONV			BIT(4)
+#define		BIT_TEMPSENS_PWRON			BIT(0)
+#define AR0144_TEMPSENS_CALIB1				0x30c6
+#define AR0144_TEMPSENS_CALIB2				0x30c8
+
+#define AR0144_AECTRL					0x3100
+#define		BIT_MIN_ANA_GAIN(n)			((n) << 5)
+#define		BIT_MIN_ANA_GAIN_MASK			GENMASK(6, 5)
+#define		BIT_AUTO_DG_EN				BIT(4)
+#define		BIT_AUTO_AG_EN				BIT(1)
+#define		BIT_AE_EN				BIT(0)
+#define	AR0144_AE_LUMA_TGT				0x3102
+#define AR0144_AE_MAX_EXPOSURE				0x311c
+#define	AR0144_AE_MIN_EXPOSURE				0x311e
+#define	AR0144_AE_COARSE_INT_TIME			0x3164
+#define	AR0144_DELTA_DK_CTRL				0x3180
+#define		BIT_DK_SUB_EN				BIT(15)
+#define		BIT_DK_EVERY_FRAME			BIT(14)
+#define		BIT_DK_RECALC				BIT(13)
+#define	AR0144_DATA_FORMAT_BITS				0x31ac
+#define		BIT_DATA_FMT_IN(n)			((n) << 8)
+#define		BIT_DATA_FMT_OUT(n)			(n)
+#define	AR0144_SERIAL_FORMAT				0x31ae
+#define		BIT_QUAD_LANE				BIT(2)
+#define		BIT_DUAL_LANE				BIT(1)
+#define		BIT_SINGLE_LANE				BIT(0)
+#define AR0144_MIPI_TIMING_0				0x31b4
+#define AR0144_MIPI_TIMING_1				0x31b6
+#define AR0144_MIPI_TIMING_2				0x31b8
+#define AR0144_MIPI_TIMING_3				0x31ba
+#define AR0144_MIPI_TIMING_4				0x31bc
+#define AR0144_SER_CTRL_STAT				0x31c6
+#define		BIT_FRAMER_TEST_MODE			BIT(7)
+#define	AR0144_COMPANDING				0x31d0
+#define		BIT_COMPAND_EN				BIT(0)
+#define AR0144_SERIAL_TEST				0x31d8
+#define	AR0144_PIX_DEF_ID				0x31e0
+#define		BIT_PIX_DEF_1D_DDC_EN			BIT(3)
+#define AR0144_CUSTOMER_REV				0x31fe
+#define		BIT_COLOR				BIT(4)
+
+#define	AR0144_FLASH_CTRL				0x3270
+#define		BIT_LED_FLASH_EN			BIT(8)
+#define		BIT_LED_DELAY(n)			(n)
+#define		BIT_LED_DELAY_MASK			0xff
+
+#define AR0144_MIPI_CNTRL				0x3354
+
+#define	AR0144_TP_NO_TESTPATTERN	0
+#define	AR0144_TP_SOLIDCOLOR		1
+#define	AR0144_TP_FULL_COLOR_BAR	2
+#define	AR0144_TP_FADE_TO_GRAY		3
+#define	AR0144_TP_WALKING_ONES		256
+
+#define	AR0144_TEST_LANE_0		(0x1 << 8)
+#define	AR0144_TEST_LANE_1		(0x2 << 8)
+#define	AR0144_TEST_MODE_LP11		(0x1 << 4)
+
+#define	AR0144_CSI2_DATA_RAW8		0x2a
+#define	AR0144_CSI2_DATA_RAW10		0x2b
+#define	AR0144_CSI2_DATA_RAW12		0x2c
+
+#define AR0144_NO_SLEW_RATE		(~0u)
+
+#define AR0144_CHIP_VERSION		0x0356
+#define AR0234_CHIP_VERSION		0x0a56
+#define AR0144_DEFAULT_RESET_DELAY	0
+
+
+enum {
+	V4L2_CID_USER_BASE_AR0144		= V4L2_CID_USER_BASE + 0x2500,
+	V4L2_CID_X_EXPOSURE_FINE,
+	V4L2_CID_X_AUTO_EXPOSURE_MIN,
+	V4L2_CID_X_AUTO_EXPOSURE_MAX,
+	V4L2_CID_X_AUTO_EXPOSURE_TGT,
+	V4L2_CID_X_AUTO_EXPOSURE_CUR,
+
+	V4L2_CID_X_AUTOGAIN_ANALOGUE,
+	V4L2_CID_X_AUTOGAIN_DIGITAL,
+
+	V4L2_CID_X_AUTOGAIN_ANALOGUE_MIN,
+
+	V4L2_CID_X_BINNING_ROW,
+	V4L2_CID_X_BINNING_COL,
+	V4L2_CID_X_COMPANDING,
+
+	V4L2_CID_X_DIGITAL_GAIN_RED,
+	V4L2_CID_X_DIGITAL_GAIN_GREENR,
+	V4L2_CID_X_DIGITAL_GAIN_BLUE,
+	V4L2_CID_X_DIGITAL_GAIN_GREENB,
+
+	V4L2_CID_X_EMBEDDED_DATA,
+	V4L2_CID_X_BLACK_LEVEL_AUTO,
+	V4L2_CID_X_FLASH_DELAY,
+	V4L2_CID_X_DYNAMIC_PIXEL_CORRECTION,
+	V4L2_CID_X_TRIGGER_MODE,
+};
+
+enum {
+	V4L2_X_EMBEDDED_OFF,
+	V4L2_X_EMBEDDED_STAT,
+	V4L2_X_EMBEDDED_DATA,
+	V4L2_X_EMBEDDED_BOTH,
+};
+
+enum ar0144_chip {
+	AR0144,
+	AR0234,
+};
+
+enum ar0144_color {
+	AR0144_MODEL_UNKNOWN,
+	AR0144_MODEL_COLOR,
+	AR0144_MODEL_MONOCHROME,
+};
+
+struct limit_range {
+	unsigned long min;
+	unsigned long max;
+};
+
+struct ar0144_sensor_limits {
+	struct limit_range x;
+	struct limit_range y;
+	struct limit_range hlen;
+	struct limit_range vlen;
+	struct limit_range hblank;
+	struct limit_range vblank;
+	struct limit_range ext_clk;
+
+	struct limit_range div_lim;
+	struct limit_range mul_lim;
+	struct limit_range vt_div_lim;
+	struct limit_range word_clk_lim;
+	struct limit_range vco_lim;
+};
+
+struct ar0144_mipi_timing {
+	const char name[32];
+	u16 value;
+	u16 max;
+	u16 shift;
+};
+
+struct ar0144_model_data {
+	unsigned int max_lanes;
+	unsigned int multiplier;
+	unsigned long max_parallel_link_freq;
+	unsigned long max_mipi_link_freq;
+	unsigned int max_parallel_again;
+	unsigned int max_mipi_again;
+	unsigned int max_tp_color;
+	unsigned int aec_min_exposure;
+	unsigned int def_width;
+	unsigned int def_height;
+	unsigned int def_offset_x;
+	unsigned int def_offset_y;
+
+	struct ar0144_mipi_timing *timing0;
+	unsigned int size_timing0;
+	struct ar0144_mipi_timing *timing1;
+	unsigned int size_timing1;
+	struct ar0144_mipi_timing *timing2;
+	unsigned int size_timing2;
+	struct ar0144_mipi_timing *timing3;
+	unsigned int size_timing3;
+	struct ar0144_mipi_timing *timing4;
+	unsigned int size_timing4;
+
+	const struct ar0144_sensor_limits *limits;
+};
+
+struct ar0144_model {
+	enum ar0144_chip chip;
+	enum ar0144_color color;
+	unsigned int chip_version;
+	struct ar0144_model_data *data;
+};
+
+struct ar0144_register {
+	u16 reg;
+	u16 val;
+};
+
+struct ar0144_format {
+	unsigned int code;
+	unsigned int bpp;
+};
+
+struct ar0144_businfo {
+	enum v4l2_mbus_type bus_type;
+	union {
+		struct v4l2_mbus_config_parallel parallel;
+		struct v4l2_mbus_config_mipi_csi2 mipi;
+	} bus;
+	unsigned long target_link_frequency;
+	const s64 *link_freqs;
+
+	unsigned int slew_rate_dat;
+	unsigned int slew_rate_clk;
+
+	unsigned int num_lanes;
+};
+
+struct ar0144_pll_config {
+	unsigned int pre_pll_div;
+	unsigned int pre_pll_mul;
+	unsigned int vt_sys_div;
+	unsigned int vt_pix_div;
+	unsigned int op_sys_div;
+	unsigned int op_pix_div;
+	unsigned long vco_freq;
+	unsigned long pix_freq;
+	unsigned long ser_freq;
+};
+
+struct ar0144_gains {
+	struct v4l2_ctrl *dig_ctrl;
+	struct v4l2_ctrl *ana_ctrl;
+	struct v4l2_ctrl *red_ctrl;
+	struct v4l2_ctrl *greenb_ctrl;
+	struct v4l2_ctrl *greenr_ctrl;
+	struct v4l2_ctrl *blue_ctrl;
+	unsigned int red;
+	unsigned int greenb;
+	unsigned int greenr;
+	unsigned int blue;
+	unsigned int min_ref;
+	unsigned int max_again;
+};
+
+struct ar0144 {
+	struct v4l2_subdev subdev;
+	struct device *dev;
+	struct v4l2_ctrl_handler ctrls;
+	struct media_pad pad;
+
+	struct v4l2_mbus_framefmt fmt;
+	struct v4l2_rect crop;
+	unsigned int bpp;
+	unsigned int w_skip;
+	unsigned int h_skip;
+	unsigned int hlen;
+	unsigned int vlen;
+	bool embedded_data;
+	bool embedded_stat;
+
+	struct ar0144_model *model;
+	enum ar0144_color color;
+	struct ar0144_businfo info;
+	struct ar0144_pll_config *pll;
+
+	const struct ar0144_format *formats;
+	unsigned int num_fmts;
+
+	struct v4l2_ctrl *exp_ctrl;
+	struct v4l2_ctrl *vblank_ctrl;
+	struct v4l2_ctrl *hblank_ctrl;
+	struct ar0144_gains gains;
+
+	struct vvcam_mode_info_s vvcam_mode;
+	unsigned int vvcam_cur_mode_index;
+
+	struct clk *extclk;
+	struct gpio_desc *reset_gpio;
+
+	struct mutex lock;
+
+	unsigned int reset_delay_ms;
+	int power_user;
+	bool is_streaming;
+	bool trigger;
+};
+
+static const struct ar0144_format ar0144_mono_formats[] = {
+	{
+		.code	= MEDIA_BUS_FMT_Y8_1X8,
+		.bpp	= 8,
+	}, {
+		.code	= MEDIA_BUS_FMT_Y10_1X10,
+		.bpp	= 10,
+	}, {
+		.code	= MEDIA_BUS_FMT_Y12_1X12,
+		.bpp	= 12,
+	},
+};
+
+static const struct ar0144_format ar0144_col_formats[] = {
+	{
+		.code	= MEDIA_BUS_FMT_SGRBG8_1X8,
+		.bpp	= 8,
+	}, {
+		.code	= MEDIA_BUS_FMT_SGRBG10_1X10,
+		.bpp	= 10,
+	}, {
+		.code	= MEDIA_BUS_FMT_SGRBG12_1X12,
+		.bpp	= 12,
+	},
+};
+
+static const struct ar0144_format ar0234_mono_formats[] = {
+	{
+		.code	= MEDIA_BUS_FMT_Y8_1X8,
+		.bpp	= 8,
+	}, {
+		.code	= MEDIA_BUS_FMT_Y10_1X10,
+		.bpp	= 10,
+	},
+};
+
+static const struct ar0144_format ar0234_col_formats[] = {
+	{
+		.code	= MEDIA_BUS_FMT_SGRBG8_1X8,
+		.bpp	= 8,
+	}, {
+		.code	= MEDIA_BUS_FMT_SGRBG10_1X10,
+		.bpp	= 10,
+	},
+};
+
+static struct vvcam_mode_info_s ar0144_modes[] = {
+	{
+		.index = 0,
+		.size = {
+			.bounds_width	= 1280,
+			.bounds_height	= 720,
+			.top		= 0,
+			.left		= 0,
+			.width		= 1280,
+			.height		= 720,
+		},
+		.hdr_mode = SENSOR_MODE_LINEAR,
+		.bit_width = 12,
+		.data_compress = {
+			.enable = 0,
+		},
+		.bayer_pattern = BAYER_GRBG,
+		.ae_info = {
+			.def_frm_len_lines     = 742,
+			.curr_frm_len_lines    = 742,
+			.one_line_exp_time_ns  = 20040,
+
+			.max_integration_line  = 65535,
+			.min_integration_line  = 1,
+
+			.max_again             = 16 * 1024,
+			.min_again             = 1.684 * 1024,
+			.max_dgain             = 15.9 * 1024,
+			.min_dgain             = 1 * 1024,
+			.gain_step             = 1,
+			.start_exposure        = 2 * 800 * 1024,
+			.cur_fps               = 60 * 1024,
+			.max_fps               = 66 * 1024,
+			.min_fps               = 5 * 1024,
+			.min_afps              = 30 * 1024,
+			.int_update_delay_frm  = 1,
+			.gain_update_delay_frm = 1,
+		},
+		.mipi_info = {
+			.mipi_lane = 2,
+		},
+		.preg_data = NULL,
+		.reg_data_count = 0,
+	},
+	{
+		.index = 1,
+		.size = {
+			.bounds_width	= 1280,
+			.bounds_height	= 800,
+			.top		= 0,
+			.left		= 0,
+			.width		= 1280,
+			.height		= 800,
+		},
+		.hdr_mode = SENSOR_MODE_LINEAR,
+		.bit_width = 12,
+		.data_compress = {
+			.enable = 0,
+		},
+		.bayer_pattern = BAYER_GRBG,
+		.ae_info = {
+			.def_frm_len_lines     = 822,
+			.curr_frm_len_lines    = 822,
+			.one_line_exp_time_ns  = 20040,
+
+			.max_integration_line  = 65535,
+			.min_integration_line  = 1,
+
+			.max_again             = 16 * 1024,
+			.min_again             = 1.684 * 1024,
+			.max_dgain             = 15.9 * 1024,
+			.min_dgain             = 1 * 1024,
+			.gain_step             = 1,
+			.start_exposure        = 2 * 800 * 1024,
+			.cur_fps               = 60 * 1024,
+			.max_fps               = 60 * 1024,
+			.min_fps               = 5 * 1024,
+			.min_afps              = 30 * 1024,
+			.int_update_delay_frm  = 1,
+			.gain_update_delay_frm = 1,
+		},
+		.mipi_info = {
+			.mipi_lane = 2,
+		},
+		.preg_data = NULL,
+		.reg_data_count = 0,
+	},
+};
+
+static struct vvcam_mode_info_s ar0234_modes[] = {
+	{
+		.index = 0,
+		.size = {
+			.bounds_width	= 1280,
+			.bounds_height	= 720,
+			.top		= 0,
+			.left		= 0,
+			.width		= 1280,
+			.height		= 720,
+		},
+		.hdr_mode = SENSOR_MODE_LINEAR,
+		.bit_width = 10,
+		.data_compress = {
+			.enable = 0,
+		},
+		.bayer_pattern = BAYER_GRBG,
+		.ae_info = {
+			.def_frm_len_lines	= 736,
+			.curr_frm_len_lines	= 736,
+			.one_line_exp_time_ns	= 6800,
+
+			.max_integration_line	= 65535,
+			.min_integration_line	= 1,
+
+			.max_again		= 16 * 1024,
+			.min_again		= 1.684 * 1024,
+			.max_dgain		= 15.9 * 1024,
+			.min_dgain		= 1 * 1024,
+			.gain_step		= 1,
+			.start_exposure		= 2 * 1200 * 1024,
+			.cur_fps		= 60 * 1024,
+			.max_fps		= 198 * 1024,
+			.min_fps		= 5 * 1024,
+			.min_afps		= 30 * 1024,
+			.int_update_delay_frm	= 1,
+			.gain_update_delay_frm	= 1,
+		},
+		.mipi_info = {
+			.mipi_lane = 4,
+		},
+		.preg_data = NULL,
+		.reg_data_count = 0,
+	},
+	{
+		.index = 1,
+		.size = {
+			.bounds_width	= 1920,
+			.bounds_height	= 1080,
+			.top		= 0,
+			.left		= 0,
+			.width		= 1920,
+			.height		= 1080,
+		},
+		.hdr_mode = SENSOR_MODE_LINEAR,
+		.bit_width = 10,
+		.data_compress = {
+			.enable = 0,
+		},
+		.bayer_pattern = BAYER_GRBG,
+		.ae_info = {
+			.def_frm_len_lines	= 1096,
+			.curr_frm_len_lines	= 1096,
+			.one_line_exp_time_ns	= 6800,
+
+			.max_integration_line	= 65535,
+			.min_integration_line	= 1,
+
+			.max_again		= 16 * 1024,
+			.min_again		= 1.684 * 1024,
+			.max_dgain		= 15.9 * 1024,
+			.min_dgain		= 1 * 1024,
+			.gain_step		= 1,
+			.start_exposure		= 2 * 1200 * 1024,
+			.cur_fps		= 60 * 1024,
+			.max_fps		= 133 * 1024,
+			.min_fps		= 5 * 1024,
+			.min_afps		= 30 * 1024,
+			.int_update_delay_frm	= 1,
+			.gain_update_delay_frm	= 1,
+		},
+		.mipi_info = {
+			.mipi_lane = 4,
+		},
+		.preg_data = NULL,
+		.reg_data_count = 0,
+	},
+	{
+		.index = 2,
+		.size = {
+			.bounds_width	= 1920,
+			.bounds_height	= 1200,
+			.top		= 0,
+			.left		= 0,
+			.width		= 1920,
+			.height		= 1200,
+		},
+		.hdr_mode = SENSOR_MODE_LINEAR,
+		.bit_width = 10,
+		.data_compress = {
+			.enable = 0,
+		},
+		.bayer_pattern = BAYER_GRBG,
+		.ae_info = {
+			.def_frm_len_lines	= 1216,
+			.curr_frm_len_lines	= 1216,
+			.one_line_exp_time_ns	= 6800,
+
+			.max_integration_line	= 65535,
+			.min_integration_line	= 1,
+
+			.max_again		= 16 * 1024,
+			.min_again		= 1.684 * 1024,
+			.max_dgain		= 15.9 * 1024,
+			.min_dgain		= 1 * 1024,
+			.gain_step		= 1,
+			.start_exposure		= 2 * 1200 * 1024,
+			.cur_fps		= 60 * 1024,
+			.max_fps		= 120 * 1024,
+			.min_fps		= 5 * 1024,
+			.min_afps		= 30 * 1024,
+			.int_update_delay_frm	= 1,
+			.gain_update_delay_frm	= 1,
+		},
+		.mipi_info = {
+			.mipi_lane = 4,
+		},
+		.preg_data = NULL,
+		.reg_data_count = 0,
+	},
+};
+
+struct priv_ioctl {
+	u32 idx;
+	const char * const name;
+};
+
+struct priv_ioctl priv_ioctls[] = {
+	{ VVSENSORIOC_RESET, "VVSENSORIOC_RESET" },
+	{ VVSENSORIOC_S_POWER, "VVSENSORIOC_S_POWER" },
+	{ VVSENSORIOC_G_POWER, "VVSENSORIOC_G_POWER" },
+	{ VVSENSORIOC_S_CLK, "VVSENSORIOC_S_CLK" },
+	{ VVSENSORIOC_G_CLK, "VVSENSORIOC_G_CLK" },
+	{ VVSENSORIOC_QUERY, "VVSENSORIOC_QUERY" },
+	{ VVSENSORIOC_S_SENSOR_MODE, "VVSENSORIOC_S_SENSOR_MODE" },
+	{ VVSENSORIOC_G_SENSOR_MODE, "VVSENSORIOC_G_SENSOR_MODE" },
+	{ VVSENSORIOC_READ_REG, "VVSENSORIOC_READ_REG" },
+	{ VVSENSORIOC_WRITE_REG, "VVSENSORIOC_WRITE_REG" },
+	{ VVSENSORIOC_READ_ARRAY, "VVSENSORIOC_READ_ARRAY" },
+	{ VVSENSORIOC_WRITE_ARRAY, "VVSENSORIOC_WRITE_ARRAY" },
+	{ VVSENSORIOC_G_NAME, "VVSENSORIOC_G_NAME" },
+	{ VVSENSORIOC_G_RESERVE_ID, "VVSENSORIOC_G_RESERVE_ID" },
+	{ VVSENSORIOC_G_CHIP_ID, "VVSENSORIOC_G_CHIP_ID" },
+	{ VVSENSORIOC_S_INIT, "VVSENSORIOC_S_INIT" },
+	{ VVSENSORIOC_S_STREAM, "VVSENSORIOC_S_STREAM" },
+	{ VVSENSORIOC_S_LONG_EXP, "VVSENSORIOC_S_LONG_EXP" },
+	{ VVSENSORIOC_S_EXP, "VVSENSORIOC_S_EXP" },
+	{ VVSENSORIOC_S_VSEXP, "VVSENSORIOC_S_VSEXP" },
+	{ VVSENSORIOC_S_LONG_GAIN, "VVSENSORIOC_S_LONG_GAIN" },
+	{ VVSENSORIOC_S_GAIN, "VVSENSORIOC_S_GAIN" },
+	{ VVSENSORIOC_S_VSGAIN, "VVSENSORIOC_S_VSGAIN" },
+	{ VVSENSORIOC_S_FPS, "VVSENSORIOC_S_FPS" },
+	{ VVSENSORIOC_G_FPS, "VVSENSORIOC_G_FPS" },
+	{ VVSENSORIOC_S_HDR_RADIO, "VVSENSORIOC_S_HDR_RADIO" },
+	{ VVSENSORIOC_S_WB, "VVSENSORIOC_S_WB" },
+	{ VVSENSORIOC_S_BLC, "VVSENSORIOC_S_BLC" },
+	{ VVSENSORIOC_G_EXPAND_CURVE, "VVSENSORIOC_G_EXPAND_CURVE" },
+	{ VVSENSORIOC_S_TEST_PATTERN, "VVSENSORIOC_S_TEST_PATTERN" },
+	{ VVSENSORIOC_MAX, "VVSENSORIOC_MAX" },
+};
+
+static inline struct ar0144 *to_ar0144(struct v4l2_subdev *sd);
+static inline int bpp_to_index(struct ar0144 *sensor, unsigned int bpp);
+static int ar0144_read(struct ar0144 *sensor, u16 reg, u16 *val);
+static int ar0144_write(struct ar0144 *sensor, u16 reg, u16 val);
+static int ar0144_s_stream(struct v4l2_subdev *sd, int enable);
+static int ar0144_set_selection(struct v4l2_subdev *sd,
+				struct v4l2_subdev_state *state,
+				struct v4l2_subdev_selection *sel);
+static int ar0144_set_fmt(struct v4l2_subdev *sd,
+			  struct v4l2_subdev_state *state,
+			  struct v4l2_subdev_format *format);
+
+
+static void ar0144_vv_querycap(struct ar0144 *sensor, void *args)
+{
+	struct device *dev = sensor->subdev.dev;
+	struct v4l2_capability *cap = (struct v4l2_capability *) args;
+	struct i2c_client *i2c = v4l2_get_subdevdata(&sensor->subdev);
+	const char *csi_id;
+	int ret;
+
+	dev_dbg(dev, "%s\n", __func__);
+
+	ret = of_property_read_string(dev->of_node, "isp-bus-info", &csi_id);
+	if (!ret) {
+		strscpy((char *)cap->bus_info, csi_id, sizeof(cap->bus_info));
+	} else {
+		dev_warn(dev, "%s: No isp-bus-info found\n", __func__);
+		strscpy((char *)cap->bus_info, "csi0", sizeof(cap->bus_info));
+	}
+
+	strscpy((char *)cap->driver, "phycam", sizeof(cap->driver));
+	if (i2c->adapter)
+		cap->bus_info[VVCAM_CAP_BUS_INFO_I2C_ADAPTER_NR_POS] =
+			(__u8)i2c->adapter->nr;
+	else
+		cap->bus_info[VVCAM_CAP_BUS_INFO_I2C_ADAPTER_NR_POS] = 0xFF;
+}
+
+static int ar0144_vv_querymode(struct ar0144 *sensor, void *args)
+{
+	struct device *dev = sensor->subdev.dev;
+	struct vvcam_mode_info_s *modes;
+	struct vvcam_mode_info_array_s *array =
+		(struct vvcam_mode_info_array_s *) args;
+	uint32_t count;
+	int ret;
+
+	dev_dbg(dev, "%s\n", __func__);
+
+	switch (sensor->model->chip) {
+	case AR0144:
+		modes = ar0144_modes;
+		count = ARRAY_SIZE(ar0144_modes);
+		break;
+	case AR0234:
+		modes = ar0234_modes;
+		count = ARRAY_SIZE(ar0234_modes);
+		break;
+	}
+
+	ret = copy_to_user(&array->count, &count, sizeof(count));
+	if (ret)
+		return -EIO;
+
+	ret = copy_to_user(&array->modes, modes, sizeof(*modes) * count);
+	if (ret)
+		ret = -EIO;
+
+	return ret;
+}
+
+static int ar0144_vv_get_sensormode(struct ar0144 *sensor, void *args)
+{
+	struct device *dev = sensor->subdev.dev;
+	struct vvcam_mode_info_s *mode = (struct vvcam_mode_info_s *) args;
+	struct vvcam_ae_info_s *ae_info = &sensor->vvcam_mode.ae_info;
+	const struct ar0144_sensor_limits *limits = sensor->model->data->limits;
+	unsigned long pix_freq;
+	unsigned int pixclk_mhz;
+	unsigned int max_vlen_allowed, min_fps_allowed;
+	uint32_t int_lines, exposure_ms, gain;
+	int index;
+	int ret;
+
+	dev_dbg(dev, "%s\n", __func__);
+	dev_dbg(dev, "%s index: %u\n", __func__, sensor->vvcam_cur_mode_index);
+
+	ret = copy_from_user(&min_fps_allowed, &mode->ae_info.min_fps,
+			     sizeof(min_fps_allowed));
+
+	mutex_lock(&sensor->lock);
+
+	index = bpp_to_index(sensor, sensor->bpp);
+	pix_freq = sensor->pll[index].pix_freq;
+	pixclk_mhz = pix_freq / 1000000;
+
+	ae_info->curr_frm_len_lines = sensor->vlen;
+	ae_info->one_line_exp_time_ns = sensor->hlen * 1000 / pixclk_mhz;
+	ae_info->cur_fps = div_u64(pix_freq * 1024ULL,
+				   sensor->vlen * sensor->hlen);
+
+	ae_info->max_fps = div_u64(pix_freq * 1024ULL,
+				   sensor->fmt.height +
+				   limits->vblank.min *
+				   sensor->hlen);
+	ae_info->min_fps = div_u64(pix_freq * 1024ULL,
+				   sensor->fmt.height +
+				   limits->vblank.max *
+				   sensor->hlen);
+
+	if (min_fps_allowed)
+		max_vlen_allowed = pix_freq / (min_fps_allowed * sensor->hlen);
+	else
+		max_vlen_allowed = sensor->vlen;
+
+	ae_info->max_integration_line = max_vlen_allowed;
+	ae_info->max_again = sensor->gains.max_again * 1024 / 1000;
+
+	int_lines = sensor->exp_ctrl->cur.val;
+	exposure_ms = int_lines * sensor->hlen / pixclk_mhz;
+	gain = sensor->gains.ana_ctrl->cur.val *
+	       sensor->gains.dig_ctrl->cur.val / 1000;
+
+	ae_info->start_exposure = (gain * exposure_ms / 1000) * 1024;
+
+	ret = copy_to_user(args, &sensor->vvcam_mode,
+			   sizeof(struct vvcam_mode_info_s));
+	if (ret)
+		ret = -EIO;
+
+	mutex_unlock(&sensor->lock);
+
+	return ret;
+}
+
+static int ar0144_vv_set_sensormode(struct ar0144 *sensor, void *args)
+{
+	struct device *dev = sensor->subdev.dev;
+	struct v4l2_subdev *sd = &sensor->subdev;
+	struct v4l2_subdev_state state;
+	struct v4l2_subdev_selection sel;
+	struct v4l2_subdev_format format;
+	struct v4l2_rect ar0144_frames[] = {
+		{.top = 44, .left = 0, .width = 1280, .height = 720},
+		{.top = 4, .left = 0, .width = 1280, .height = 800},
+	};
+	struct v4l2_rect ar0234_frames[] = {
+		{.top = 248, .left = 328, .width = 1280, .height = 720},
+		{.top = 68, .left = 8, .width = 1920, .height = 1080},
+		{.top = 8, .left = 8, .width = 1920, .height = 1200},
+	};
+	struct v4l2_rect *frame;
+	struct vvcam_mode_info_s *modes;
+	struct vvcam_mode_info_s mode;
+	uint32_t index;
+	int bpp;
+	int ret;
+
+	dev_dbg(dev, "%s\n", __func__);
+
+	ret = copy_from_user(&mode, args, sizeof(struct vvcam_mode_info_s));
+	index = mode.index;
+
+	sel.which = V4L2_SUBDEV_FORMAT_ACTIVE;
+	sel.pad = 0;
+	sel.target = V4L2_SEL_TGT_CROP;
+
+	switch (sensor->model->chip) {
+	case AR0144:
+		if (index > ARRAY_SIZE(ar0144_modes) - 1)
+			index = 0;
+
+		modes = ar0144_modes;
+		frame = &ar0144_frames[index];
+		break;
+	case AR0234:
+		if (index > ARRAY_SIZE(ar0234_modes) - 1)
+			index = 0;
+
+		modes = ar0234_modes;
+		frame = &ar0234_frames[index];
+		break;
+	}
+
+	sel.r = *frame;
+	format.which = V4L2_SUBDEV_FORMAT_ACTIVE;
+	format.pad = 0;
+
+	bpp = modes[index].bit_width;
+	format.format.width = modes[index].size.bounds_width;
+	format.format.height = modes[index].size.bounds_height;
+	format.format.code = sensor->formats[bpp_to_index(sensor, bpp)].code;
+
+	ret = ar0144_set_selection(sd, &state, &sel);
+	if (ret)
+		return ret;
+
+	ret = ar0144_set_fmt(sd, &state, &format);
+	if (ret)
+		return ret;
+
+	memcpy(&sensor->vvcam_mode, &modes[index],
+	       sizeof(struct vvcam_mode_info_s));
+	sensor->vvcam_cur_mode_index = index;
+
+	return 0;
+}
+
+static int ar0144_vv_s_stream(struct ar0144 *sensor, void *args)
+{
+	unsigned int enable = 0;
+	int ret;
+
+	ret = copy_from_user(&enable, args, sizeof(enable));
+	if (ret)
+		return -EIO;
+
+	return ar0144_s_stream(&sensor->subdev, enable);
+}
+
+static int ar0144_vv_set_exposure(struct ar0144 *sensor, void *args)
+{
+	struct device *dev = sensor->subdev.dev;
+	unsigned int pixclk_mhz;
+	uint32_t new_exp = 0;
+	uint32_t int_time;
+	int index;
+	int ret;
+
+	ret = copy_from_user(&new_exp, args, sizeof(new_exp));
+	if (ret)
+		return -EIO;
+
+	mutex_lock(&sensor->lock);
+
+	index = bpp_to_index(sensor, sensor->bpp);
+	pixclk_mhz = sensor->pll[index].pix_freq / 1000000;
+
+	new_exp = new_exp / 1024;
+	int_time = new_exp * pixclk_mhz / sensor->hlen;
+
+	__v4l2_ctrl_s_ctrl(sensor->exp_ctrl, int_time);
+
+	mutex_unlock(&sensor->lock);
+
+	dev_dbg(dev, "%s: %u --> %u\n", __func__, new_exp, int_time);
+
+	return 0;
+}
+
+static int ar0144_vv_set_gain(struct ar0144 *sensor, void *args)
+{
+	struct device *dev = sensor->subdev.dev;
+	uint32_t new_gain = 0;
+	uint32_t d_gain, a_gain;
+	int ret;
+
+	ret = copy_from_user(&new_gain, args, sizeof(new_gain));
+	if (ret)
+		return -EIO;
+
+	new_gain = new_gain * 1000 / 1024;
+
+	dev_dbg(dev, "%s: %u\n", __func__, new_gain);
+
+	if (new_gain > sensor->gains.max_again) {
+		a_gain = sensor->gains.max_again;
+		d_gain = new_gain * 1000 / a_gain;
+		v4l2_ctrl_s_ctrl(sensor->gains.ana_ctrl, a_gain);
+		v4l2_ctrl_s_ctrl(sensor->gains.dig_ctrl, d_gain);
+	} else {
+		v4l2_ctrl_s_ctrl(sensor->gains.ana_ctrl, new_gain);
+		v4l2_ctrl_s_ctrl(sensor->gains.dig_ctrl, 1000);
+	}
+
+	return 0;
+}
+
+static int ar0144_vv_set_wb(struct ar0144 *sensor, void *args)
+{
+	struct device *dev = sensor->subdev.dev;
+	sensor_white_balance_t wb;
+	s32 new_gain;
+	int ret;
+
+	ret = copy_from_user(&wb, args, sizeof(wb));
+	if (ret)
+		return -EIO;
+
+	new_gain = (wb.r_gain >> 8) * 1000 +
+		   (wb.r_gain & 0xff) * 1000 / 256;
+	v4l2_ctrl_s_ctrl(sensor->gains.red_ctrl, new_gain);
+	dev_dbg(dev, "r_gain: %u --> %u\n", wb.r_gain, new_gain);
+
+	new_gain = (wb.gr_gain >> 8) * 1000 +
+		   (wb.gr_gain & 0xff) * 1000 / 256;
+	v4l2_ctrl_s_ctrl(sensor->gains.greenr_ctrl, new_gain);
+	dev_dbg(dev, "gr_gain: %u --> %u\n", wb.gr_gain, new_gain);
+
+	new_gain = (wb.gb_gain >> 8) * 1000 +
+		   (wb.gb_gain & 0xff) * 1000 / 256;
+	v4l2_ctrl_s_ctrl(sensor->gains.greenb_ctrl, new_gain);
+	dev_dbg(dev, "gb_gain: %u --> %u\n", wb.gb_gain, new_gain);
+
+	new_gain = (wb.b_gain >> 8) * 1000 +
+		   (wb.b_gain & 0xff) * 1000 / 256;
+	v4l2_ctrl_s_ctrl(sensor->gains.blue_ctrl, new_gain);
+	dev_dbg(dev, "b_gain: %u --> %u\n", wb.b_gain, new_gain);
+
+	return 0;
+}
+
+static int ar0144_vv_get_fps(struct ar0144 *sensor, void *args)
+{
+	struct device *dev = sensor->subdev.dev;
+	uint32_t out_fps;
+	unsigned long pix_freq;
+	unsigned int fps;
+	int index;
+	int ret;
+
+	mutex_lock(&sensor->lock);
+
+	index = bpp_to_index(sensor, sensor->bpp);
+	pix_freq = sensor->pll[index].pix_freq;
+
+	fps = div_u64(pix_freq * 10ULL, sensor->vlen * sensor->hlen);
+
+	out_fps = fps * 1024 / 10;
+
+	mutex_unlock(&sensor->lock);
+
+	dev_dbg(dev, "%s: %u.%u\n", __func__, fps/10, fps%10);
+
+	ret = copy_to_user(args, &out_fps, sizeof(out_fps));
+	if (ret)
+		ret = -EIO;
+
+	return
+		ret;
+}
+
+static int ar0144_vv_set_fps(struct ar0144 *sensor, void *args)
+{
+	struct device *dev = sensor->subdev.dev;
+	const struct ar0144_sensor_limits *limits = sensor->model->data->limits;
+	uint32_t fps = 0;
+	unsigned long pix_freq;
+	unsigned int max_fps, min_fps;
+	unsigned int vlen, vblank;
+	int index;
+	int ret;
+
+	ret = copy_from_user(&fps, args, sizeof(fps));
+	if (ret)
+		return -EIO;
+
+	mutex_lock(&sensor->lock);
+
+	index = bpp_to_index(sensor, sensor->bpp);
+	pix_freq = sensor->pll[index].pix_freq;
+
+	max_fps = div_u64(pix_freq * 10ULL,
+			  sensor->fmt.height + limits->vblank.min *
+			  sensor->hlen);
+	min_fps = div_u64(pix_freq * 10ULL,
+			  sensor->fmt.height + limits->vblank.max *
+			  sensor->hlen);
+
+	fps = fps * 10 / 1024;
+
+	clamp_t(unsigned int, fps, min_fps, max_fps);
+
+	vlen = div_u64(pix_freq * 10ULL, fps * sensor->hlen);
+	vblank = vlen - sensor->fmt.height;
+
+	__v4l2_ctrl_s_ctrl(sensor->vblank_ctrl, vblank);
+
+	mutex_unlock(&sensor->lock);
+
+	dev_dbg(dev, "%s: %u.%u (vblank: %u)\n", __func__,
+		fps/10, fps%10, vblank);
+
+	return 0;
+}
+
+static int ar0144_vv_read_reg(struct ar0144 *sensor, void *args)
+{
+	struct device *dev = sensor->subdev.dev;
+	struct vvcam_sccb_data_s reg;
+	int ret;
+
+	dev_dbg(dev, "%s\n", __func__);
+
+	ret = copy_from_user(&reg, args, sizeof(struct vvcam_sccb_data_s));
+	if (ret)
+		return ret;
+
+	ret = ar0144_read(sensor, reg.addr, (u16 *)&reg.data);
+	if (ret)
+		return ret;
+
+	ret = copy_to_user(args, &reg, sizeof(struct vvcam_sccb_data_s));
+	if (ret)
+		return ret;
+
+	return 0;
+}
+
+static int ar0144_vv_write_reg(struct ar0144 *sensor, void *args)
+{
+	struct device *dev = sensor->subdev.dev;
+	struct vvcam_sccb_data_s reg;
+	int ret;
+
+	dev_dbg(dev, "%s\n", __func__);
+
+	ret = copy_from_user(&reg, args, sizeof(struct vvcam_sccb_data_s));
+	if (ret)
+		return ret;
+
+	ret = ar0144_write(sensor, reg.addr, (u16)reg.data);
+	if (ret)
+		return ret;
+
+	return 0;
+}
+
+static long ar0144_priv_ioctl(struct v4l2_subdev *sd, unsigned int cmd,
+			      void *arg)
+{
+	struct ar0144 *sensor = to_ar0144(sd);
+	int ret;
+	unsigned int idx;
+
+	if (cmd >= 0x100)
+		idx = cmd - 0x100;
+	else
+		idx = sizeof(priv_ioctls);
+
+	if (idx < sizeof(priv_ioctls))
+		dev_dbg(sd->dev, "%s: %s\n", __func__, priv_ioctls[idx].name);
+	else
+		dev_dbg(sd->dev, "%s: Unknown priv ioctl: 0x%08x\n",
+			__func__, cmd);
+
+	switch (cmd) {
+	case VIDIOC_QUERYCAP:
+		ar0144_vv_querycap(sensor, arg);
+		break;
+	case VVSENSORIOC_QUERY:
+		ret = ar0144_vv_querymode(sensor, arg);
+		if (ret)
+			return -EIO;
+		break;
+	case VVSENSORIOC_G_SENSOR_MODE:
+		ret = ar0144_vv_get_sensormode(sensor, arg);
+		if (ret)
+			return ret;
+		break;
+	case VVSENSORIOC_S_SENSOR_MODE:
+		ret = ar0144_vv_set_sensormode(sensor, arg);
+		if (ret)
+			return ret;
+		break;
+	case VVSENSORIOC_S_STREAM:
+		ret = ar0144_vv_s_stream(sensor, arg);
+		if (ret)
+			return ret;
+		break;
+	case VVSENSORIOC_S_EXP:
+		ret = ar0144_vv_set_exposure(sensor, arg);
+		if (ret)
+			return -EIO;
+		break;
+	case VVSENSORIOC_S_GAIN:
+		ret = ar0144_vv_set_gain(sensor, arg);
+		if (ret)
+			return -EIO;
+		break;
+	case VVSENSORIOC_S_WB:
+		ret = ar0144_vv_set_wb(sensor, arg);
+		break;
+	case VVSENSORIOC_G_FPS:
+		ret = ar0144_vv_get_fps(sensor, arg);
+		if (ret)
+			return ret;
+		break;
+	case VVSENSORIOC_S_FPS:
+		ret = ar0144_vv_set_fps(sensor, arg);
+		if (ret)
+			return ret;
+		break;
+	case VVSENSORIOC_READ_REG:
+		ret = ar0144_vv_read_reg(sensor, arg);
+		if (ret)
+			return ret;
+		break;
+	case VVSENSORIOC_WRITE_REG:
+		ret = ar0144_vv_write_reg(sensor, arg);
+		if (ret)
+			return ret;
+		break;
+	default:
+		return -ENOTTY;
+	};
+
+	return 0;
+}
+
+static inline struct ar0144 *to_ar0144(struct v4l2_subdev *sd)
+{
+	return container_of(sd, struct ar0144, subdev);
+}
+
+static inline unsigned int index_to_bpp(struct ar0144 *sensor, int index)
+{
+	if (index >= sensor->num_fmts)
+		index = sensor->num_fmts - 1;
+
+	return sensor->formats[index].bpp;
+}
+
+static inline int bpp_to_index(struct ar0144 *sensor, unsigned int bpp)
+{
+	int index;
+
+	for (index = 0; index < sensor->num_fmts; index++)
+		if (sensor->formats[index].bpp == bpp)
+			return index;
+
+	return sensor->num_fmts - 1;
+}
+
+static int ar0144_read(struct ar0144 *sensor, u16 reg, u16 *val)
+{
+	struct i2c_client *i2c = v4l2_get_subdevdata(&sensor->subdev);
+	unsigned char reg_buf[2], read_buf[2];
+	int ret;
+	u16 result;
+	struct i2c_msg xfer[] = {
+		[0] = {
+			.addr = i2c->addr,
+			.flags = 0,
+			.len = 2,
+			.buf = reg_buf,
+		},
+		[1] = {
+			.addr = i2c->addr,
+			.flags = I2C_M_RD,
+			.len = 2,
+			.buf = read_buf,
+		},
+	};
+
+	reg_buf[0] = (reg >> 8) & 0xff;
+	reg_buf[1] = reg & 0xff;
+
+	ret = i2c_transfer(i2c->adapter, xfer, ARRAY_SIZE(xfer));
+	if (ret >= 0 && ret != ARRAY_SIZE(xfer))
+		ret = -EIO;
+
+	if (ret < 0) {
+		dev_err(&i2c->dev, "Failed to read i2c message (%d)\n", ret);
+		return ret;
+	}
+
+	result = read_buf[0] << 8;
+	result |= read_buf[1];
+
+	*val = result;
+
+	return 0;
+}
+
+static int ar0144_write(struct ar0144 *sensor, u16 reg, u16 val)
+{
+	struct i2c_client *i2c = v4l2_get_subdevdata(&sensor->subdev);
+	unsigned char write_buf[4];
+	int ret;
+	struct i2c_msg xfer[] = {
+		[0] = {
+			.addr = i2c->addr,
+			.flags = 0,
+			.len = 4,
+			.buf = write_buf,
+		},
+	};
+
+	write_buf[0] = (reg >> 8) & 0xff;
+	write_buf[1] = reg & 0xff;
+
+	write_buf[2] = (val >> 8) & 0xff;
+	write_buf[3] = val & 0xff;
+
+	ret = i2c_transfer(i2c->adapter, xfer, ARRAY_SIZE(xfer));
+	if (ret >= 0 && ret != ARRAY_SIZE(xfer))
+		ret = -EIO;
+
+	if (ret < 0) {
+		dev_err(&i2c->dev, "Failed to write i2c message (%d)\n", ret);
+		return ret;
+	}
+
+	dev_dbg(&i2c->dev, "Wrote i2c message 0x%02x at 0x%02x\n", val, reg);
+
+	return 0;
+}
+
+static int ar0144_update_bits(struct ar0144 *sensor, u16 reg,
+			      u16 mask, u16 val)
+{
+	u16 orig, tmp;
+	int ret;
+
+	ret = ar0144_read(sensor, reg, &orig);
+	if (ret)
+		return ret;
+
+	tmp = orig & ~mask;
+	tmp |= val & mask;
+
+	if (tmp != orig)
+		ret = ar0144_write(sensor, reg, tmp);
+
+	return ret;
+}
+
+static int ar0144_set_bits(struct ar0144 *sensor, u16 reg, u16 val)
+{
+	return ar0144_update_bits(sensor, reg, val, val);
+}
+
+static int ar0144_clear_bits(struct ar0144 *sensor, u16 reg, u16 val)
+{
+	return ar0144_update_bits(sensor, reg, val, 0);
+}
+
+static const struct ar0144_format *ar0144_find_format(struct ar0144 *sensor,
+						      u32 code)
+{
+	int i;
+
+	for (i = 0; i < sensor->num_fmts; i++)
+		if (sensor->formats[i].code == code)
+			return &sensor->formats[i];
+
+	return &sensor->formats[sensor->num_fmts - 1];
+}
+
+static int ar0144_start_stream(struct ar0144 *sensor)
+{
+	return ar0144_update_bits(sensor, AR0144_RESET_REGISTER,
+				  BIT_STREAM | BIT_MASK_BAD |
+				  BIT_GPI_EN | BIT_FORCED_PLL_ON,
+				  BIT_STREAM | BIT_MASK_BAD);
+}
+
+static int ar0144_start_trigger(struct ar0144 *sensor)
+{
+	return ar0144_update_bits(sensor, AR0144_RESET_REGISTER,
+				  BIT_STREAM | BIT_MASK_BAD |
+				  BIT_GPI_EN | BIT_FORCED_PLL_ON,
+				  BIT_MASK_BAD |
+				  BIT_GPI_EN | BIT_FORCED_PLL_ON);
+}
+
+static int ar0144_enter_standby(struct ar0144 *sensor)
+{
+	unsigned int timeout = 1000;
+	int ret;
+	u16 val;
+
+	ret = ar0144_clear_bits(sensor, AR0144_RESET_REGISTER,
+				BIT_STREAM | BIT_GPI_EN | BIT_FORCED_PLL_ON);
+	if (ret)
+		return ret;
+
+	while (timeout) {
+		ar0144_read(sensor, AR0144_FRAME_STATUS, &val);
+
+		if (val & BIT_STANDBY_STATUS) {
+			dev_dbg(sensor->dev, "reached standby state\n");
+			break;
+		}
+
+		timeout--;
+
+		if (timeout == 0) {
+			dev_warn(sensor->dev,
+				  "timeout while trying to enter standby\n");
+			break;
+		}
+
+		usleep_range(2000, 3000);
+	}
+
+	ar0144_read(sensor, AR0144_RESET_REGISTER, &val);
+
+	if ((val & BIT_SMIA_SER_DIS) == 0) {
+		/* TODO: Calculate frametime and use it for this wait period */
+		msleep(100);
+		ret = ar0144_set_bits(sensor, AR0144_RESET_REGISTER,
+				      BIT_SMIA_SER_DIS);
+		if (ret)
+			return ret;
+	}
+
+	/* In MIPI mode the sensor might be in LP-11 test mode so make sure
+	 * to disable it.
+	 */
+	if (sensor->info.bus_type == V4L2_MBUS_CSI2_DPHY)
+		ret = ar0144_clear_bits(sensor, AR0144_SER_CTRL_STAT,
+					BIT_FRAMER_TEST_MODE);
+
+	return ret;
+}
+
+static int ar0144_mipi_enter_lp11(struct ar0144 *sensor)
+{
+	int ret;
+	u16 val;
+
+	val = AR0144_TEST_MODE_LP11 | AR0144_TEST_LANE_0;
+
+	if (sensor->info.num_lanes == 2)
+		val |= AR0144_TEST_LANE_1;
+
+	ret = ar0144_write(sensor, AR0144_SERIAL_TEST, val);
+	if (ret)
+		return ret;
+
+	ret = ar0144_set_bits(sensor, AR0144_SER_CTRL_STAT,
+			      BIT_FRAMER_TEST_MODE);
+	if (ret)
+		return ret;
+
+	ret = ar0144_update_bits(sensor, AR0144_RESET_REGISTER,
+				 BIT_STREAM | BIT_SMIA_SER_DIS,
+				 BIT_STREAM);
+	return ret;
+}
+
+static void ar0144_reset(struct ar0144 *sensor)
+{
+	unsigned long ext_freq = clk_get_rate(sensor->extclk);
+	unsigned long ext_freq_mhz = ext_freq / 1000000;
+	unsigned long wait_usecs;
+
+	if (sensor->reset_gpio) {
+		gpiod_set_value_cansleep(sensor->reset_gpio, 1);
+		usleep_range(1000, 1100);
+		gpiod_set_value_cansleep(sensor->reset_gpio, 0);
+	} else {
+		ar0144_set_bits(sensor, AR0144_RESET_REGISTER, BIT_RESET);
+	}
+
+	wait_usecs = 160000 / ext_freq_mhz;
+	usleep_range(wait_usecs, wait_usecs + 1000);
+	msleep(sensor->reset_delay_ms);
+}
+
+static int ar0144_power_on(struct ar0144 *sensor)
+{
+	/* TODO: Implement it as pm_runtime */
+	/* TODO: Enable power, clocks, etc... */
+	return 0;
+}
+
+static void ar0144_power_off(struct ar0144 *sensor)
+{
+	/* TODO: Disable power, clocks, etc... */
+}
+
+/* V4L2 subdev core ops */
+static int ar0144_s_power(struct v4l2_subdev *sd, int on)
+{
+	struct ar0144 *sensor = to_ar0144(sd);
+	int ret = 0;
+
+	dev_dbg(sd->dev, "%s on: %d\n", __func__, on);
+
+	mutex_lock(&sensor->lock);
+
+	if (on) {
+		if (sensor->power_user > 0) {
+			sensor->power_user++;
+			goto out;
+		}
+
+		ret = ar0144_power_on(sensor);
+		if (ret)
+			goto out;
+
+		/* Enable MIPI LP-11 test mode as required by e.g. i.MX 6 */
+		if (sensor->info.bus_type == V4L2_MBUS_CSI2_DPHY &&
+		    !sensor->is_streaming) {
+			ret = ar0144_mipi_enter_lp11(sensor);
+			if (ret) {
+				ar0144_power_off(sensor);
+				goto out;
+			}
+		}
+
+		sensor->power_user++;
+
+	} else {
+		sensor->power_user--;
+		if (sensor->power_user < 0) {
+			dev_err(sd->dev, "More s_power OFF than ON\n");
+			ret = -EINVAL;
+			goto out;
+		}
+
+		if (sensor->power_user == 0) {
+			ar0144_enter_standby(sensor);
+			ar0144_power_off(sensor);
+		}
+	}
+
+out:
+	mutex_unlock(&sensor->lock);
+	return ret;
+}
+
+#ifdef CONFIG_VIDEO_ADV_DEBUG
+static int ar0144_s_register(struct v4l2_subdev *sd,
+			     const struct v4l2_dbg_register *reg)
+{
+	struct ar0144 *sensor = to_ar0144(sd);
+
+	return ar0144_write(sensor, reg->reg, reg->val);
+}
+
+static int ar0144_g_register(struct v4l2_subdev *sd,
+			     struct v4l2_dbg_register *reg)
+{
+	struct ar0144 *sensor = to_ar0144(sd);
+
+	return ar0144_read(sensor, reg->reg, (u16 *)&reg->val);
+}
+#endif
+
+static int ar0144_config_pll(struct ar0144 *sensor)
+{
+	int index = bpp_to_index(sensor, sensor->bpp);
+	int ret;
+
+	ret = ar0144_write(sensor, AR0144_VT_PIX_CLK_DIV,
+			   sensor->pll[index].vt_pix_div);
+	if (ret)
+		return ret;
+
+	ret = ar0144_write(sensor, AR0144_VT_SYS_CLK_DIV,
+			   sensor->pll[index].vt_sys_div);
+	if (ret)
+		return ret;
+
+	ret = ar0144_write(sensor, AR0144_PRE_PLL_CLK_DIV,
+			   sensor->pll[index].pre_pll_div);
+	if (ret)
+		return ret;
+
+	ret = ar0144_write(sensor, AR0144_PLL_MUL,
+			   sensor->pll[index].pre_pll_mul);
+	if (ret)
+		return ret;
+
+	ret = ar0144_write(sensor, AR0144_OP_PIX_CLK_DIV,
+			   sensor->pll[index].op_pix_div);
+	if (ret)
+		return ret;
+
+	ret = ar0144_write(sensor, AR0144_OP_SYS_CLK_DIV,
+			   sensor->pll[index].op_sys_div);
+	if (ret)
+		return ret;
+
+	/* Wait for PLL to lock */
+	usleep_range(1000, 1500);
+
+	return 0;
+}
+
+static int ar0144_config_frame(struct ar0144 *sensor)
+{
+	unsigned int height = sensor->fmt.height * sensor->h_skip;
+	unsigned int width = sensor->fmt.width * sensor->w_skip;
+	int ret;
+	u16 x_end, y_end;
+
+	ret = ar0144_write(sensor, AR0144_Y_ADDR_START, sensor->crop.top);
+	if (ret)
+		return ret;
+
+	ret = ar0144_write(sensor, AR0144_X_ADDR_START, sensor->crop.left);
+	if (ret)
+		return ret;
+
+	y_end = sensor->crop.top + height - 1;
+
+	if (sensor->embedded_stat)
+		y_end -= 2;
+	if (sensor->embedded_data)
+		y_end -= 2;
+
+	ret = ar0144_write(sensor, AR0144_Y_ADRR_END, y_end);
+	if (ret)
+		return ret;
+
+	x_end = sensor->crop.left + width - 1;
+	ret = ar0144_write(sensor, AR0144_X_ADRR_END, x_end);
+	if (ret)
+		return ret;
+
+	ret = ar0144_write(sensor, AR0144_FRAME_LENGTH_LINES, sensor->vlen - 5);
+	if (ret)
+		return ret;
+
+	ret = ar0144_write(sensor, AR0144_LINE_LENGTH_PCK,
+			   sensor->hlen / sensor->model->data->multiplier);
+	if (ret)
+		return ret;
+
+	ret = ar0144_write(sensor, AR0144_X_ODD_INC,
+			   (sensor->w_skip << 1) - 1);
+	if (ret)
+		return ret;
+
+	ret = ar0144_write(sensor, AR0144_Y_ODD_INC,
+			   (sensor->h_skip << 1) - 1);
+	if (ret)
+		return ret;
+
+
+	/* Enable embedded statistics for Auto Exposure to work
+	 * Since it is embedded after the active frame there is no issue
+	 * enabling it all the time.
+	 */
+	ret = ar0144_set_bits(sensor, AR0144_SMIA_TEST, BIT_EMBEDDED_STATS_EN);
+
+	return ret;
+}
+
+static int ar0144_config_parallel(struct ar0144 *sensor)
+{
+	int ret;
+	unsigned int bpp;
+
+	bpp = sensor->bpp + sensor->info.bus.parallel.data_shift;
+
+	ret = ar0144_write(sensor, AR0144_DATA_FORMAT_BITS,
+			   BIT_DATA_FMT_IN(bpp) | BIT_DATA_FMT_OUT(bpp));
+	if (ret)
+		return ret;
+
+	ret = ar0144_set_bits(sensor, AR0144_RESET_REGISTER,
+			      BIT_SMIA_SER_DIS | BIT_PARALLEL_EN |
+			      BIT_DRIVE_PINS);
+	if (ret)
+		return ret;
+
+	if (sensor->trigger)
+		ret = ar0144_start_trigger(sensor);
+	else
+		ret = ar0144_start_stream(sensor);
+
+	return ret;
+}
+
+static int ar0144_config_mipi(struct ar0144 *sensor)
+{
+	int ret;
+	u16 val;
+
+	switch (sensor->bpp) {
+	case 8:
+		val = AR0144_CSI2_DATA_RAW8;
+		break;
+	case 10:
+		val = AR0144_CSI2_DATA_RAW10;
+		break;
+	case 12:
+		val = AR0144_CSI2_DATA_RAW12;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	ret = ar0144_write(sensor, AR0144_MIPI_CNTRL, val);
+	if (ret)
+		return ret;
+
+	ret = ar0144_write(sensor, AR0144_DATA_FORMAT_BITS,
+			   BIT_DATA_FMT_IN(sensor->bpp) |
+			   BIT_DATA_FMT_OUT(sensor->bpp));
+	if (ret)
+		return ret;
+
+	ret = ar0144_clear_bits(sensor, AR0144_RESET_REGISTER,
+				BIT_PARALLEL_EN | BIT_DRIVE_PINS);
+	if (ret)
+		return ret;
+
+	if (sensor->trigger)
+		ret = ar0144_start_trigger(sensor);
+	else
+		ret = ar0144_start_stream(sensor);
+	if (ret)
+		return ret;
+
+	ret = ar0144_clear_bits(sensor, AR0144_RESET_REGISTER,
+				BIT_SMIA_SER_DIS);
+
+	return ret;
+}
+
+static int ar0144_stream_on(struct ar0144 *sensor)
+{
+	u16 mono_op;
+	int ret;
+
+	/* If the MIPI bus is in use the data and clk lanes are in LP-11 state.
+	 * So we have to unset streaming and disable test mode before
+	 * configuring the sensor.
+	 */
+	if (sensor->info.bus_type == V4L2_MBUS_CSI2_DPHY) {
+		ret = ar0144_enter_standby(sensor);
+		if (ret)
+			return ret;
+	}
+
+	ret = ar0144_config_pll(sensor);
+	if (ret)
+		return ret;
+
+	ret = ar0144_config_frame(sensor);
+	if (ret)
+		return ret;
+
+	mono_op = sensor->color == AR0144_MODEL_MONOCHROME;
+
+	ret = ar0144_update_bits(sensor, AR0144_DIGITAL_TEST, BIT_MONOCHROME_OP,
+				 mono_op ? BIT_MONOCHROME_OP : 0);
+	if (ret)
+		return ret;
+
+	if (sensor->info.bus_type == V4L2_MBUS_PARALLEL)
+		ret = ar0144_config_parallel(sensor);
+	else
+		ret = ar0144_config_mipi(sensor);
+
+	if (ret)
+		return ret;
+
+	sensor->is_streaming = true;
+	return 0;
+}
+
+static int ar0144_stream_off(struct ar0144 *sensor)
+{
+	int ret;
+
+	ret = ar0144_enter_standby(sensor);
+	sensor->is_streaming = false;
+
+	return ret;
+}
+
+/* V4L2 subdev video ops */
+static int ar0144_s_stream(struct v4l2_subdev *sd, int enable)
+{
+	struct ar0144 *sensor = to_ar0144(sd);
+	int ret = 0;
+
+	dev_dbg(sd->dev, "%s enable: %d\n", __func__, enable);
+
+	mutex_lock(&sensor->lock);
+
+	if (enable && sensor->is_streaming) {
+		ret = -EBUSY;
+		goto out;
+	}
+
+	if (!enable && !sensor->is_streaming)
+		goto out;
+
+	if (enable)
+		ret = ar0144_stream_on(sensor);
+	else
+		ret = ar0144_stream_off(sensor);
+
+out:
+	mutex_unlock(&sensor->lock);
+	return ret;
+}
+
+static int ar0144_g_frame_interval(struct v4l2_subdev *sd,
+				   struct v4l2_subdev_frame_interval *interval)
+{
+	struct ar0144 *sensor = to_ar0144(sd);
+	unsigned long pix_freq;
+	int index;
+
+	mutex_lock(&sensor->lock);
+
+	index = bpp_to_index(sensor, sensor->bpp);
+	pix_freq = sensor->pll[index].pix_freq;
+
+	interval->interval.numerator = 10;
+	interval->interval.denominator = div_u64(pix_freq * 10ULL,
+						 sensor->vlen * sensor->hlen);
+
+	mutex_unlock(&sensor->lock);
+
+	return 0;
+}
+
+static struct v4l2_rect *ar0144_get_pad_crop(struct ar0144 *sensor,
+					     struct v4l2_subdev_state *state,
+					     unsigned int pad, u32 which)
+{
+	switch (which) {
+	case V4L2_SUBDEV_FORMAT_TRY:
+		return v4l2_subdev_get_try_crop(&sensor->subdev, state, pad);
+	case V4L2_SUBDEV_FORMAT_ACTIVE:
+		return &sensor->crop;
+	default:
+		return NULL;
+	}
+}
+
+static struct v4l2_mbus_framefmt *ar0144_get_pad_fmt(struct ar0144 *sensor,
+					    struct v4l2_subdev_state *state,
+					    unsigned int pad, u32 which)
+{
+	switch (which) {
+	case V4L2_SUBDEV_FORMAT_TRY:
+		return v4l2_subdev_get_try_format(&sensor->subdev, state, pad);
+	case V4L2_SUBDEV_FORMAT_ACTIVE:
+		return &sensor->fmt;
+	default:
+		return NULL;
+	}
+}
+
+static unsigned int ar0144_find_skipfactor(unsigned int input,
+					   unsigned int output)
+{
+	int i;
+
+	/*
+	 * We need to determine a matching supported power-of-two skip
+	 * factor. If no exact match is found. the next bigger matching
+	 * factor is returned.
+	 * Supported factors are:
+	 * No Skip
+	 * Skip 2
+	 * Skip 4
+	 * Skip 8
+	 * Skip 16
+	 */
+
+	for (i = 0; i < 4; i++)
+		if ((input >> i) <= output)
+			break;
+
+	return (1 << i);
+}
+
+/* V4L2 subdev pad ops */
+static int ar0144_enum_mbus_code(struct v4l2_subdev *sd,
+				 struct v4l2_subdev_state *state,
+				 struct v4l2_subdev_mbus_code_enum *code)
+{
+	struct ar0144 *sensor = to_ar0144(sd);
+
+	if (code->index < sensor->num_fmts) {
+		code->code = sensor->formats[code->index].code;
+		return 0;
+	} else {
+		return -EINVAL;
+	}
+}
+
+static int ar0144_enum_frame_size(struct v4l2_subdev *sd,
+				  struct v4l2_subdev_state *state,
+				  struct v4l2_subdev_frame_size_enum *fse)
+{
+	struct ar0144 *sensor = to_ar0144(sd);
+	struct v4l2_mbus_framefmt *fmt;
+	struct v4l2_rect *crop;
+	int ret = 0;
+
+	mutex_lock(&sensor->lock);
+
+	fmt = ar0144_get_pad_fmt(sensor, state, fse->pad, fse->which);
+	crop = ar0144_get_pad_crop(sensor, state, fse->pad, fse->which);
+
+	if (fse->index >= 4 || fse->code != fmt->code) {
+		ret = -EINVAL;
+		goto out;
+	}
+
+	fse->min_width = crop->width / (1u << fse->index);
+	fse->max_width = fse->min_width;
+	fse->min_height = crop->height / (1u << fse->index);
+	fse->max_height = fse->min_height;
+
+	if (fse->min_width <= 1 || fse->min_height <= 1)
+		ret = -EINVAL;
+out:
+	mutex_unlock(&sensor->lock);
+	return ret;
+}
+
+static void ar0144_update_blankings(struct ar0144 *sensor)
+{
+	const struct ar0144_sensor_limits *limits = sensor->model->data->limits;
+	unsigned int width = sensor->fmt.width;
+	unsigned int height = sensor->fmt.height;
+	unsigned int hblank_min, hblank_max;
+	unsigned int vblank_min, vblank_max;
+	unsigned int hblank_value, hblank_default;
+	unsigned int vblank_value, vblank_default;
+
+	hblank_min = limits->hblank.min;
+	if (width + limits->hblank.min < limits->hlen.min)
+		hblank_min = limits->hlen.min - width;
+
+	vblank_min = limits->vblank.min;
+	if (height + limits->vblank.min < limits->vlen.min)
+		vblank_min = limits->vlen.min - height;
+
+	hblank_max = limits->hlen.max - width;
+	vblank_max = limits->vlen.max - height;
+
+	hblank_value = sensor->hblank_ctrl->cur.val;
+	hblank_default = sensor->hblank_ctrl->default_value;
+
+	vblank_value = sensor->vblank_ctrl->cur.val;
+	vblank_default = sensor->vblank_ctrl->default_value;
+
+	if (hblank_value < hblank_min)
+		__v4l2_ctrl_s_ctrl(sensor->hblank_ctrl, hblank_min);
+
+	if (hblank_value > hblank_max)
+		__v4l2_ctrl_s_ctrl(sensor->hblank_ctrl, hblank_max);
+
+	if (vblank_value < vblank_min)
+		__v4l2_ctrl_s_ctrl(sensor->vblank_ctrl, vblank_min);
+
+	if (vblank_value > vblank_max)
+		__v4l2_ctrl_s_ctrl(sensor->vblank_ctrl, vblank_max);
+
+	__v4l2_ctrl_modify_range(sensor->hblank_ctrl, hblank_min, hblank_max,
+				 sensor->hblank_ctrl->step,
+				 hblank_min);
+
+	__v4l2_ctrl_modify_range(sensor->vblank_ctrl, vblank_min, vblank_max,
+				 sensor->vblank_ctrl->step,
+				 vblank_min);
+
+
+	/*
+	 * If the previous value was equal the previous default value, readjust
+	 * the updated value to the new default value as well.
+	 */
+	if (hblank_value == hblank_default)
+		__v4l2_ctrl_s_ctrl(sensor->hblank_ctrl, hblank_min);
+
+	if (vblank_value == vblank_default)
+		__v4l2_ctrl_s_ctrl(sensor->vblank_ctrl, vblank_min);
+}
+
+static int ar0144_set_fmt(struct v4l2_subdev *sd,
+			  struct v4l2_subdev_state *state,
+			  struct v4l2_subdev_format *format)
+{
+	struct ar0144 *sensor = to_ar0144(sd);
+	const struct ar0144_format *sensor_format;
+	struct v4l2_mbus_framefmt *fmt;
+	struct v4l2_rect *crop;
+	unsigned int width, height;
+	unsigned int w_skip, h_skip;
+
+	mutex_lock(&sensor->lock);
+
+	if (sensor->is_streaming &&
+	    format->which == V4L2_SUBDEV_FORMAT_ACTIVE) {
+		mutex_unlock(&sensor->lock);
+		return -EBUSY;
+	}
+
+	fmt = ar0144_get_pad_fmt(sensor, state, format->pad, format->which);
+	crop = ar0144_get_pad_crop(sensor, state, format->pad,
+				   V4L2_SUBDEV_FORMAT_ACTIVE);
+
+	if (sensor->color == AR0144_MODEL_COLOR)
+		fmt->colorspace = V4L2_COLORSPACE_RAW;
+	else
+		fmt->colorspace = V4L2_COLORSPACE_SRGB;
+
+	fmt->field = V4L2_FIELD_NONE;
+	fmt->xfer_func = V4L2_MAP_XFER_FUNC_DEFAULT(fmt->colorspace);
+	fmt->ycbcr_enc = V4L2_MAP_YCBCR_ENC_DEFAULT(fmt->colorspace);
+	fmt->quantization = V4L2_MAP_QUANTIZATION_DEFAULT(true,
+							  fmt->colorspace,
+							  fmt->ycbcr_enc);
+
+	sensor_format = ar0144_find_format(sensor, format->format.code);
+	fmt->code = sensor_format->code;
+
+	width = clamp_t(unsigned int, format->format.width,
+			1, crop->width);
+	height = clamp_t(unsigned int, format->format.height,
+			 1, crop->height);
+
+	w_skip = ar0144_find_skipfactor(crop->width, width);
+	h_skip = ar0144_find_skipfactor(crop->height, height);
+
+	fmt->width = crop->width / w_skip;
+	fmt->height = crop->height / h_skip;
+
+	if (format->which == V4L2_SUBDEV_FORMAT_ACTIVE) {
+		sensor->bpp = sensor_format->bpp;
+		sensor->w_skip = w_skip;
+		sensor->h_skip = h_skip;
+
+		ar0144_update_blankings(sensor);
+		sensor->hlen = fmt->width + sensor->hblank_ctrl->cur.val;
+		sensor->vlen = fmt->height + sensor->vblank_ctrl->cur.val;
+	}
+
+	format->format = *fmt;
+
+	mutex_unlock(&sensor->lock);
+	return 0;
+}
+
+static int ar0144_get_fmt(struct v4l2_subdev *sd,
+			  struct v4l2_subdev_state *state,
+			  struct v4l2_subdev_format *format)
+{
+	struct ar0144 *sensor = to_ar0144(sd);
+	struct v4l2_mbus_framefmt *fmt;
+
+	mutex_lock(&sensor->lock);
+
+	fmt = ar0144_get_pad_fmt(sensor, state, format->pad, format->which);
+	format->format = *fmt;
+
+	mutex_unlock(&sensor->lock);
+
+	return 0;
+}
+
+static int ar0144_group_param_hold(struct ar0144 *sensor)
+{
+	return ar0144_set_bits(sensor, AR0144_RESET_REGISTER,
+			       BIT_GROUPED_PARAM_HOLD);
+}
+
+static int ar0144_group_param_release(struct ar0144 *sensor)
+{
+	return ar0144_clear_bits(sensor, AR0144_RESET_REGISTER,
+				 BIT_GROUPED_PARAM_HOLD);
+}
+
+static int ar0144_set_selection(struct v4l2_subdev *sd,
+				struct v4l2_subdev_state *state,
+				struct v4l2_subdev_selection *sel)
+{
+	struct ar0144 *sensor = to_ar0144(sd);
+	const struct ar0144_sensor_limits *limits = sensor->model->data->limits;
+	struct v4l2_rect *_crop;
+	unsigned int max_w, max_h;
+	int ret = 0;
+
+	if (sel->target != V4L2_SEL_TGT_CROP)
+		return -EINVAL;
+
+	mutex_lock(&sensor->lock);
+
+	if (sensor->is_streaming &&
+	    (sel->r.width != sensor->crop.width ||
+	     sel->r.height != sensor->crop.height)) {
+		ret = -EBUSY;
+		goto out;
+	}
+
+	_crop = ar0144_get_pad_crop(sensor, state, sel->pad, sel->which);
+
+	/* Check againts max, min values */
+	max_w = limits->x.max - limits->x.min + 1;
+	max_h = limits->y.max - limits->y.min + 1;
+
+	_crop->top = min_t(unsigned int, ALIGN(sel->r.top, 2), max_h);
+	_crop->left = min_t(unsigned int, ALIGN(sel->r.left, 2), max_w);
+	_crop->width = min_t(unsigned int, sel->r.width, max_w - _crop->left);
+	_crop->height = min_t(unsigned int, sel->r.height, max_h - _crop->top);
+
+	if (sensor->is_streaming) {
+		ret = ar0144_group_param_hold(sensor);
+		if (ret)
+			goto out;
+
+		ret = ar0144_config_frame(sensor);
+		if (ret)
+			goto out;
+
+		ret = ar0144_group_param_release(sensor);
+		if (ret)
+			goto out;
+	}
+
+	sel->r = *_crop;
+
+out:
+	mutex_unlock(&sensor->lock);
+	return ret;
+}
+
+static int ar0144_get_selection(struct v4l2_subdev *sd,
+				struct v4l2_subdev_state *state,
+				struct v4l2_subdev_selection *sel)
+{
+	struct ar0144 *sensor = to_ar0144(sd);
+	struct v4l2_rect *_crop;
+	unsigned int x_min = sensor->model->data->limits->x.min;
+	unsigned int y_min = sensor->model->data->limits->y.min;
+	unsigned int x_max = sensor->model->data->limits->x.max;
+	unsigned int y_max = sensor->model->data->limits->y.max;
+
+	switch (sel->target) {
+	case V4L2_SEL_TGT_CROP:
+		mutex_lock(&sensor->lock);
+
+		_crop = ar0144_get_pad_crop(sensor, state, sel->pad, sel->which);
+		sel->r = *_crop;
+
+		mutex_unlock(&sensor->lock);
+		break;
+	case V4L2_SEL_TGT_CROP_DEFAULT:
+		sel->r.left = 4;
+		sel->r.top = 4;
+		sel->r.width = sensor->model->data->def_width;
+		sel->r.height = sensor->model->data->def_height;
+		break;
+	case V4L2_SEL_TGT_CROP_BOUNDS:
+		sel->r.left = x_min;
+		sel->r.top = y_min;
+		sel->r.width = (x_max - x_min + 1);
+		sel->r.height = (y_max - y_min + 1);
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int ar0144_get_mbus_config(struct v4l2_subdev *sd, unsigned int pad,
+				  struct v4l2_mbus_config *cfg)
+{
+	struct ar0144 *sensor = to_ar0144(sd);
+	struct ar0144_businfo *info = &sensor->info;
+
+	cfg->type = info->bus_type;
+
+	if (cfg->type == V4L2_MBUS_PARALLEL)
+		cfg->bus.parallel = info->bus.parallel;
+	else
+		cfg->bus.mipi_csi2 = info->bus.mipi;
+
+	return 0;
+}
+
+static int ar0144_get_frame_desc(struct v4l2_subdev *sd, unsigned int pad,
+				 struct v4l2_mbus_frame_desc *fd)
+{
+	struct ar0144 *sensor = to_ar0144(sd);
+	struct ar0144_businfo *info = &sensor->info;
+	struct v4l2_mbus_framefmt *fmt;
+
+	mutex_lock(&sensor->lock);
+
+	fmt = &sensor->fmt;
+
+	memset(fd, 0, sizeof(*fd));
+
+	if (info->bus_type == V4L2_MBUS_CSI2_DPHY) {
+		fd->type = V4L2_MBUS_FRAME_DESC_TYPE_CSI2;
+		fd->num_entries = 1;
+
+		fd->entry[0].pixelcode = fmt->code;
+		fd->entry[0].bus.csi2.vc = 0;
+
+		switch (sensor->bpp) {
+		case 8:
+			fd->entry[0].bus.csi2.dt = MIPI_CSI2_DT_RAW8;
+			break;
+		case 10:
+			fd->entry[0].bus.csi2.dt = MIPI_CSI2_DT_RAW10;
+			break;
+		case 12:
+			fd->entry[0].bus.csi2.dt = MIPI_CSI2_DT_RAW12;
+			break;
+		}
+	} else {
+		fd->type = V4L2_MBUS_FRAME_DESC_TYPE_PARALLEL;
+		fd->num_entries = 1;
+
+		fd->entry[0].pixelcode = fmt->code;
+	}
+
+	mutex_unlock(&sensor->lock);
+
+	return 0;
+}
+
+static const struct v4l2_subdev_core_ops ar0144_subdev_core_ops = {
+	.s_power		= ar0144_s_power,
+	.ioctl			= ar0144_priv_ioctl,
+#ifdef CONFIG_VIDEO_ADV_DEBUG
+	.s_register		= ar0144_s_register,
+	.g_register		= ar0144_g_register,
+#endif
+};
+
+static const struct v4l2_subdev_video_ops ar0144_subdev_video_ops = {
+	.s_stream		= ar0144_s_stream,
+	.g_frame_interval	= ar0144_g_frame_interval,
+};
+
+static const struct v4l2_subdev_pad_ops ar0144_subdev_pad_ops = {
+	.enum_mbus_code		= ar0144_enum_mbus_code,
+	.enum_frame_size	= ar0144_enum_frame_size,
+	.set_fmt		= ar0144_set_fmt,
+	.get_fmt		= ar0144_get_fmt,
+	.set_selection		= ar0144_set_selection,
+	.get_selection		= ar0144_get_selection,
+	.get_mbus_config	= ar0144_get_mbus_config,
+	.get_frame_desc		= ar0144_get_frame_desc,
+};
+
+static const struct v4l2_subdev_ops ar0144_subdev_ops = {
+	.core			= &ar0144_subdev_core_ops,
+	.video			= &ar0144_subdev_video_ops,
+	.pad			= &ar0144_subdev_pad_ops,
+};
+
+static const struct media_entity_operations ar0144_entity_ops = {
+	.get_fwnode_pad		= v4l2_subdev_get_fwnode_pad_1_to_1,
+};
+
+static int ar0144_set_analogue_gain(struct ar0144 *sensor, unsigned int val)
+{
+	unsigned int coarse, fine;
+
+	for (coarse = 0; coarse < 5; coarse++)
+		if (val < (1u << (coarse + 1)) * 1000)
+			break;
+
+	val = val / (1u << coarse);
+	fine = DIV_ROUND_CLOSEST(32 * (val - 1000), val);
+
+	if (fine > 15)
+		fine = 15;
+
+	ar0144_update_bits(sensor, AR0144_ANALOG_GAIN,
+			   BIT_COARSE_GAIN_MASK | BIT_FINE_GAIN_MASK,
+			   BIT_COARSE_GAIN(coarse) | BIT_FINE_GAIN(fine));
+
+	return 1000 * (1u << coarse) * 32 / (32 - fine);
+}
+
+unsigned int ar0144_get_min_color_gain(struct ar0144 *sensor)
+{
+	unsigned int gains[4];
+	int min_idx = 0;
+	int i;
+
+	gains[0] = sensor->gains.red_ctrl->val;
+	gains[1] = sensor->gains.greenr_ctrl->val;
+	gains[2] = sensor->gains.greenb_ctrl->val;
+	gains[3] = sensor->gains.blue_ctrl->val;
+
+	for (i = 0; i < 4; i++) {
+		if (gains[i] < gains[min_idx])
+			min_idx = i;
+	}
+
+	return gains[min_idx];
+}
+
+static int ar0144_set_digital_gain(struct ar0144 *sensor,
+				   struct v4l2_ctrl *ctrl)
+{
+	unsigned int coarse, fine;
+	unsigned int gain, gain_min;
+	int ret;
+
+	coarse = ctrl->val / 1000;
+	fine = (ctrl->val % 1000) * 128 / 1000;
+
+	switch (ctrl->id) {
+	case V4L2_CID_DIGITAL_GAIN:
+		if (sensor->color == AR0144_MODEL_MONOCHROME) {
+			ret = ar0144_write(sensor, AR0144_GLOBAL_GAIN,
+					   (coarse << 7) | fine);
+			return ret;
+		}
+
+		gain = sensor->gains.red * ctrl->val;
+		gain = gain / sensor->gains.min_ref;
+		gain = clamp_t(unsigned int, gain, 1000, 15999);
+		coarse = gain / 1000;
+		fine = (gain % 1000) * 128 / 1000;
+		ret = ar0144_write(sensor, AR0144_RED_GAIN,
+				   (coarse << 7) | fine);
+		if (ret)
+			return ret;
+
+		sensor->gains.red_ctrl->val = gain;
+		sensor->gains.red_ctrl->cur.val = gain;
+
+		gain = sensor->gains.greenr * ctrl->val;
+		gain = gain / sensor->gains.min_ref;
+		gain = clamp_t(unsigned int, gain, 1000, 15999);
+		coarse = gain / 1000;
+		fine = (gain % 1000) * 128 / 1000;
+		ret = ar0144_write(sensor, AR0144_GREENR_GAIN,
+				   (coarse << 7) | fine);
+		if (ret)
+			return ret;
+
+		sensor->gains.greenr_ctrl->val = gain;
+		sensor->gains.greenr_ctrl->cur.val = gain;
+
+		gain = sensor->gains.greenb * ctrl->val;
+		gain = gain / sensor->gains.min_ref;
+		gain = clamp_t(unsigned int, gain, 1000, 15999);
+		coarse = gain / 1000;
+		fine = (gain % 1000) * 128 / 1000;
+		ret = ar0144_write(sensor, AR0144_GREENB_GAIN,
+				   (coarse << 7) | fine);
+		if (ret)
+			return ret;
+
+		sensor->gains.greenb_ctrl->val = gain;
+		sensor->gains.greenb_ctrl->cur.val = gain;
+
+		gain = sensor->gains.blue * ctrl->val;
+		gain = gain / sensor->gains.min_ref;
+		gain = clamp_t(unsigned int, gain, 1000, 15999);
+		coarse = gain / 1000;
+		fine = (gain % 1000) * 128 / 1000;
+		ret = ar0144_write(sensor, AR0144_BLUE_GAIN,
+				   (coarse << 7) | fine);
+		if (ret)
+			return ret;
+
+		sensor->gains.blue_ctrl->val = gain;
+		sensor->gains.blue_ctrl->cur.val = gain;
+
+		break;
+	case V4L2_CID_X_DIGITAL_GAIN_RED:
+		ret = ar0144_write(sensor, AR0144_RED_GAIN,
+				   (coarse << 7) | fine);
+		if (ret)
+			return ret;
+		break;
+	case V4L2_CID_X_DIGITAL_GAIN_GREENR:
+		ret = ar0144_write(sensor, AR0144_GREENR_GAIN,
+				   (coarse << 7) | fine);
+		if (ret)
+			return ret;
+		break;
+	case V4L2_CID_X_DIGITAL_GAIN_GREENB:
+		ret = ar0144_write(sensor, AR0144_GREENB_GAIN,
+				   (coarse << 7) | fine);
+		if (ret)
+			return ret;
+		break;
+	case V4L2_CID_X_DIGITAL_GAIN_BLUE:
+		ret = ar0144_write(sensor, AR0144_BLUE_GAIN,
+				   (coarse << 7) | fine);
+		if (ret)
+			return ret;
+		break;
+	default: /* Should not end up here, ctrl id was validated by caller */
+		return -EINVAL;
+	}
+
+	switch (ctrl->id) {
+	case V4L2_CID_X_DIGITAL_GAIN_RED:
+	case V4L2_CID_X_DIGITAL_GAIN_GREENR:
+	case V4L2_CID_X_DIGITAL_GAIN_GREENB:
+	case V4L2_CID_X_DIGITAL_GAIN_BLUE:
+		gain_min = ar0144_get_min_color_gain(sensor);
+		sensor->gains.red = sensor->gains.red_ctrl->val;
+		sensor->gains.greenr = sensor->gains.greenr_ctrl->val;
+		sensor->gains.greenb = sensor->gains.greenb_ctrl->val;
+		sensor->gains.blue = sensor->gains.blue_ctrl->val;
+		sensor->gains.min_ref = gain_min;
+		sensor->gains.dig_ctrl->val = gain_min;
+		sensor->gains.dig_ctrl->cur.val = gain_min;
+		break;
+	default:
+		break;
+	}
+
+	return 0;
+}
+
+static int ar0144_s_ctrl(struct v4l2_ctrl *ctrl)
+{
+	struct ar0144 *sensor = ctrl->priv;
+	int ret = 0;
+	u16 val;
+
+	switch (ctrl->id) {
+	case V4L2_CID_VBLANK:
+		unsigned int vlen_old;
+
+		if (sensor->is_streaming) {
+			ret = ar0144_group_param_hold(sensor);
+			if (ret)
+				break;
+		}
+
+		vlen_old = sensor->vlen;
+		sensor->vlen = sensor->fmt.height + ctrl->val;
+
+		if (sensor->is_streaming) {
+			ret = ar0144_config_frame(sensor);
+			if (ret) {
+				sensor->vlen = vlen_old;
+				break;
+			}
+
+			ret = ar0144_group_param_release(sensor);
+			if (ret)
+				sensor->vlen = vlen_old;
+		}
+
+		break;
+	case V4L2_CID_HBLANK:
+		unsigned int hlen_old;
+
+		if (sensor->is_streaming) {
+			ret = ar0144_group_param_hold(sensor);
+			if (ret)
+				break;
+		}
+
+		hlen_old = sensor->hlen;
+		sensor->hlen = sensor->fmt.width + ctrl->val;
+
+		if (sensor->is_streaming) {
+			ret = ar0144_config_frame(sensor);
+			if (ret) {
+				sensor->hlen = hlen_old;
+				break;
+			}
+
+			ret = ar0144_group_param_release(sensor);
+			if (ret)
+				sensor->hlen = hlen_old;
+		}
+
+		break;
+	case V4L2_CID_HFLIP:
+		ret = ar0144_update_bits(sensor, AR0144_READ_MODE,
+					 BIT_HORIZ_MIRROR,
+					 ctrl->val ? BIT_HORIZ_MIRROR : 0);
+		break;
+	case V4L2_CID_VFLIP:
+		ret = ar0144_update_bits(sensor, AR0144_READ_MODE,
+					 BIT_VERT_FLIP,
+					 ctrl->val ? BIT_VERT_FLIP : 0);
+		break;
+	case V4L2_CID_EXPOSURE:
+		/* TODO: implement EXPOSURE -> 100us * conversion and combine
+		 * with V4L2_CID_X_EXPOSURE_FINE
+		 */
+		ret = ar0144_write(sensor, AR0144_COARSE_INT_TIME, ctrl->val);
+		break;
+	case V4L2_CID_X_EXPOSURE_FINE:
+		/* TODO: remove me; see V4L2_CID_EXPOSURE */
+		ret = ar0144_write(sensor, AR0144_FINE_INT_TIME, ctrl->val);
+		break;
+	case V4L2_CID_TEST_PATTERN_RED:
+		ret = ar0144_write(sensor, AR0144_TEST_DATA_RED, ctrl->val);
+		break;
+	case V4L2_CID_TEST_PATTERN_GREENR:
+		ret = ar0144_write(sensor, AR0144_TEST_DATA_GREENR, ctrl->val);
+		break;
+	case V4L2_CID_TEST_PATTERN_BLUE:
+		ret = ar0144_write(sensor, AR0144_TEST_DATA_BLUE, ctrl->val);
+		break;
+	case V4L2_CID_TEST_PATTERN_GREENB:
+		ret = ar0144_write(sensor, AR0144_TEST_DATA_GREENB, ctrl->val);
+		break;
+	case V4L2_CID_EXPOSURE_AUTO:
+		val = ctrl->val == V4L2_EXPOSURE_AUTO ? BIT_AE_EN : 0;
+		ret = ar0144_update_bits(sensor, AR0144_AECTRL, BIT_AE_EN, val);
+		break;
+	case V4L2_CID_X_AUTO_EXPOSURE_TGT:
+		ret = ar0144_write(sensor, AR0144_AE_LUMA_TGT, ctrl->val);
+		break;
+	case V4L2_CID_X_AUTO_EXPOSURE_MIN:
+		ret = ar0144_write(sensor, AR0144_AE_MIN_EXPOSURE, ctrl->val);
+		break;
+	case V4L2_CID_X_AUTO_EXPOSURE_MAX:
+		ret = ar0144_write(sensor, AR0144_AE_MAX_EXPOSURE, ctrl->val);
+		break;
+	case V4L2_CID_X_AUTOGAIN_ANALOGUE:
+		ret = ar0144_update_bits(sensor, AR0144_AECTRL, BIT_AUTO_AG_EN,
+					 ctrl->val ? BIT_AUTO_AG_EN : 0);
+		break;
+	case V4L2_CID_X_AUTOGAIN_DIGITAL:
+		ret = ar0144_update_bits(sensor, AR0144_AECTRL, BIT_AUTO_DG_EN,
+					 ctrl->val ? BIT_AUTO_DG_EN : 0);
+		break;
+	case V4L2_CID_X_AUTOGAIN_ANALOGUE_MIN:
+		ret = ar0144_update_bits(sensor, AR0144_AECTRL,
+					 BIT_MIN_ANA_GAIN_MASK,
+					 BIT_MIN_ANA_GAIN(ctrl->val));
+		break;
+	case V4L2_CID_X_EMBEDDED_DATA:
+		if (sensor->is_streaming)
+			return -EBUSY;
+
+		/*
+		 * Embedded statistics are always enabled but only shown when
+		 * the corresponding ctrl is set.
+		 */
+		val = ctrl->val & V4L2_X_EMBEDDED_DATA ?
+		       BIT_EMBEDDED_DATA : 0;
+		ret = ar0144_update_bits(sensor, AR0144_SMIA_TEST,
+					 BIT_EMBEDDED_DATA, val);
+
+		if (ret)
+			return ret;
+
+		sensor->embedded_stat = ctrl->val & V4L2_X_EMBEDDED_STAT ?
+					true : false;
+		sensor->embedded_data = ctrl->val & V4L2_X_EMBEDDED_DATA ?
+					true : false;
+
+		break;
+	case V4L2_CID_TEST_PATTERN:
+		ret = ar0144_write(sensor, AR0144_TEST_PATTERN,
+				   ctrl->val < 4 ? ctrl->val : 256);
+		if (ret)
+			return ret;
+
+		/* This is undocumented but necessary */
+		ret = ar0144_update_bits(sensor, 0x3044, 3u << 4, 0);
+		break;
+	case V4L2_CID_X_BINNING_COL:
+		switch (ctrl->val) {
+		case 0:
+			val = 0;
+			break;
+		case 1:
+			val = BIT_RM_COL_BIN;
+			break;
+		case 2:
+			val = BIT_RM_COL_SUM;
+			break;
+		}
+		ret = ar0144_update_bits(sensor, AR0144_READ_MODE,
+					 BIT_RM_COL_BIN | BIT_RM_COL_SUM, val);
+		break;
+	case V4L2_CID_X_BINNING_ROW:
+		ret = ar0144_update_bits(sensor, AR0144_READ_MODE,
+					 BIT_RM_ROW_BIN,
+					 ctrl->val > 0 ? BIT_RM_ROW_BIN : 0);
+		break;
+	case V4L2_CID_X_COMPANDING:
+		ret = ar0144_update_bits(sensor, AR0144_COMPANDING,
+					 BIT_COMPAND_EN,
+					 ctrl->val ? BIT_COMPAND_EN : 0);
+		break;
+	case V4L2_CID_DIGITAL_GAIN:
+	case V4L2_CID_X_DIGITAL_GAIN_RED:
+	case V4L2_CID_X_DIGITAL_GAIN_GREENR:
+	case V4L2_CID_X_DIGITAL_GAIN_BLUE:
+	case V4L2_CID_X_DIGITAL_GAIN_GREENB:
+		ret = ar0144_set_digital_gain(sensor, ctrl);
+		break;
+	case V4L2_CID_ANALOGUE_GAIN:
+		ctrl->val = ar0144_set_analogue_gain(sensor, ctrl->val);
+		break;
+	case V4L2_CID_X_BLACK_LEVEL_AUTO:
+		ret = ar0144_update_bits(sensor, AR0144_DELTA_DK_CTRL,
+					 BIT_DK_SUB_EN,
+					 ctrl->val ? BIT_DK_SUB_EN : 0);
+		break;
+	case V4L2_CID_FLASH_LED_MODE:
+		val = ctrl->val ? BIT_LED_FLASH_EN : 0;
+		ret = ar0144_update_bits(sensor, AR0144_FLASH_CTRL,
+					 BIT_LED_FLASH_EN, val);
+		break;
+	case V4L2_CID_X_FLASH_DELAY:
+		ret = ar0144_update_bits(sensor, AR0144_FLASH_CTRL,
+					 BIT_LED_DELAY_MASK,
+					 BIT_LED_DELAY(ctrl->val));
+		break;
+	case V4L2_CID_X_DYNAMIC_PIXEL_CORRECTION:
+		if (sensor->is_streaming)
+			return -EBUSY;
+
+		val = ctrl->val ? BIT_PIX_DEF_1D_DDC_EN : 0;
+
+		ret = ar0144_update_bits(sensor, AR0144_PIX_DEF_ID,
+					 BIT_PIX_DEF_1D_DDC_EN, val);
+		break;
+	case V4L2_CID_X_TRIGGER_MODE:
+		sensor->trigger = ctrl->val ? true : false;
+
+		if (!sensor->is_streaming)
+			break;
+
+		if (sensor->trigger)
+			ret = ar0144_start_trigger(sensor);
+		else
+			ret = ar0144_start_stream(sensor);
+
+		break;
+	default:
+		ret = -EINVAL;
+		break;
+	}
+
+	return ret;
+}
+
+static int ar0144_g_volatile_ctrl(struct v4l2_ctrl *ctrl)
+{
+	struct ar0144 *sensor = ctrl->priv;
+	int index;
+	int ret;
+	u16 val;
+
+	index = bpp_to_index(sensor, sensor->bpp);
+
+	switch (ctrl->id) {
+	case V4L2_CID_X_AUTO_EXPOSURE_CUR:
+		ret = ar0144_read(sensor, AR0144_AE_COARSE_INT_TIME, &val);
+		if (ret)
+			return ret;
+
+		ctrl->val = val;
+		break;
+	case V4L2_CID_LINK_FREQ:
+		if (sensor->info.bus_type == V4L2_MBUS_PARALLEL)
+			break;
+
+		ctrl->val = index;
+		break;
+	case V4L2_CID_PIXEL_RATE:
+		*ctrl->p_new.p_s64 = sensor->pll[index].pix_freq;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static const struct v4l2_ctrl_ops ar0144_ctrl_ops = {
+	.s_ctrl			= ar0144_s_ctrl,
+	.g_volatile_ctrl	= ar0144_g_volatile_ctrl,
+};
+
+static const char * const ar0144_test_pattern_menu[] = {
+	"disabled",
+	"solid color",
+	"color bar",
+	"fade to gray",
+	"walking 1 (12 bit)"
+};
+
+static const char * const ar0144_embdata_menu[] = {
+	"disabled",
+	"stats",
+	"data",
+	"both",
+};
+
+static const char * const ar0144_binning_menu[] = {
+	"none",
+	"avg",
+	"sum",
+};
+
+static const char * const ar0144_ana_gain_min_menu[] = {
+	"1x",
+	"2x",
+	"4x",
+	"8x",
+};
+
+static const struct v4l2_ctrl_config ar0144_ctrls[] = {
+	{
+		.ops		= &ar0144_ctrl_ops,
+		.id		= V4L2_CID_VBLANK,
+		.type		= V4L2_CTRL_TYPE_INTEGER,
+		.min		= 22,
+		.max		= 65535,
+		.step		= 1,
+		.def		= 22,
+	}, {
+		.ops		= &ar0144_ctrl_ops,
+		.id		= V4L2_CID_HBLANK,
+		.type		= V4L2_CTRL_TYPE_INTEGER,
+		.min		= 208,
+		.max		= 65535,
+		.step		= 1,
+		.def		= 208,
+	}, {
+		.ops		= &ar0144_ctrl_ops,
+		.id		= V4L2_CID_HFLIP,
+		.type		= V4L2_CTRL_TYPE_BOOLEAN,
+	}, {
+		.ops		= &ar0144_ctrl_ops,
+		.id		= V4L2_CID_VFLIP,
+		.type		= V4L2_CTRL_TYPE_BOOLEAN,
+	}, {
+		.ops		= &ar0144_ctrl_ops,
+		.id		= V4L2_CID_EXPOSURE,
+		.type		= V4L2_CTRL_TYPE_INTEGER,
+		.min		= 0,
+		.max		= 65535,
+		.step		= 1,
+	}, {
+		/* TODO: remove me and replace by EXPOSURE -> 100us
+		 * conversion
+		 */
+		.ops		= &ar0144_ctrl_ops,
+		.id		= V4L2_CID_X_EXPOSURE_FINE,
+		.type		= V4L2_CTRL_TYPE_INTEGER,
+		.name		= "Exposure Fine",
+		.min		= 0,
+		.max		= 65535,
+		.step		= 1,
+		.def		= 10,
+	}, {
+		.ops		= &ar0144_ctrl_ops,
+		.id		= V4L2_CID_TEST_PATTERN_RED,
+		.type		= V4L2_CTRL_TYPE_INTEGER,
+		.min		= 0,
+		.step		= 1,
+	}, {
+		.ops		= &ar0144_ctrl_ops,
+		.id		= V4L2_CID_TEST_PATTERN_GREENR,
+		.type		= V4L2_CTRL_TYPE_INTEGER,
+		.min		= 0,
+		.step		= 1,
+	}, {
+		.ops		= &ar0144_ctrl_ops,
+		.id		= V4L2_CID_TEST_PATTERN_GREENB,
+		.type		= V4L2_CTRL_TYPE_INTEGER,
+		.min		= 0,
+		.step		= 1,
+	}, {
+		.ops		= &ar0144_ctrl_ops,
+		.id		= V4L2_CID_TEST_PATTERN_BLUE,
+		.type		= V4L2_CTRL_TYPE_INTEGER,
+		.min		= 0,
+		.step		= 1,
+	}, {
+		.ops		= &ar0144_ctrl_ops,
+		.id		= V4L2_CID_X_AUTO_EXPOSURE_TGT,
+		.type		= V4L2_CTRL_TYPE_INTEGER,
+		.name		= "Auto Exposure Target",
+		.min		= 0,
+		.max		= 65535,
+		.step		= 1,
+		.def		= 0x5000,
+	}, {
+		.ops		= &ar0144_ctrl_ops,
+		.id		= V4L2_CID_X_AUTO_EXPOSURE_MIN,
+		.type		= V4L2_CTRL_TYPE_INTEGER,
+		.name		= "Auto Exposure Min",
+		.max		= 65535,
+		.step		= 1,
+	}, {
+		.ops		= &ar0144_ctrl_ops,
+		.id		= V4L2_CID_X_AUTO_EXPOSURE_MAX,
+		.type		= V4L2_CTRL_TYPE_INTEGER,
+		.name		= "Auto Exposure Max",
+		.max		= 65535,
+		.step		= 1,
+	}, {
+		.ops		= &ar0144_ctrl_ops,
+		.id		= V4L2_CID_X_AUTO_EXPOSURE_CUR,
+		.type		= V4L2_CTRL_TYPE_INTEGER,
+		.name		= "Auto Exposure Cur",
+		.flags		= (V4L2_CTRL_FLAG_READ_ONLY |
+				   V4L2_CTRL_FLAG_VOLATILE),
+		.min		= 0,
+		.max		= 65535,
+		.step		= 1,
+	}, {
+		.ops		= &ar0144_ctrl_ops,
+		.id		= V4L2_CID_EXPOSURE_AUTO,
+		.type		= V4L2_CTRL_TYPE_MENU,
+		.min		= 0,
+		.max		= V4L2_EXPOSURE_MANUAL,
+		.menu_skip_mask	= ~(BIT(V4L2_EXPOSURE_AUTO) |
+				    BIT(V4L2_EXPOSURE_MANUAL)),
+		.def		= V4L2_EXPOSURE_AUTO,
+	}, {
+		.ops		= &ar0144_ctrl_ops,
+		.id		= V4L2_CID_X_AUTOGAIN_ANALOGUE,
+		.type		= V4L2_CTRL_TYPE_BOOLEAN,
+		.name		= "Autogain Analogue",
+		.min		= 0,
+		.max		= 1,
+		.step		= 1,
+		.def		= 1,
+	}, {
+		.ops		= &ar0144_ctrl_ops,
+		.id		= V4L2_CID_X_AUTOGAIN_DIGITAL,
+		.type		= V4L2_CTRL_TYPE_BOOLEAN,
+		.name		= "Autogain Digital",
+		.min		= 0,
+		.max		= 1,
+		.step		= 1,
+		.def		= 0,
+	}, {
+		.ops		= &ar0144_ctrl_ops,
+		.id		= V4L2_CID_TEST_PATTERN,
+		.type		= V4L2_CTRL_TYPE_MENU,
+		.min		= 0,
+		.max		= ARRAY_SIZE(ar0144_test_pattern_menu) - 1,
+		.qmenu		= ar0144_test_pattern_menu,
+	}, {
+		.ops		= &ar0144_ctrl_ops,
+		.id		= V4L2_CID_X_EMBEDDED_DATA,
+		.type		= V4L2_CTRL_TYPE_MENU,
+		.flags		= V4L2_CTRL_FLAG_MODIFY_LAYOUT,
+		.name		= "Embedded Data",
+		.min		= V4L2_X_EMBEDDED_OFF,
+		.max		= ARRAY_SIZE(ar0144_embdata_menu) - 1,
+		.def		= V4L2_X_EMBEDDED_OFF,
+		.qmenu		= ar0144_embdata_menu,
+	}, {
+		.ops		= &ar0144_ctrl_ops,
+		.id		= V4L2_CID_X_BINNING_COL,
+		.type		= V4L2_CTRL_TYPE_MENU,
+		.name		= "Col Binning",
+		.min		= 0,
+		.max		= ARRAY_SIZE(ar0144_binning_menu) - 1,
+		.qmenu		= ar0144_binning_menu,
+	}, {
+		.ops		= &ar0144_ctrl_ops,
+		.id		= V4L2_CID_X_BINNING_ROW,
+		.type		= V4L2_CTRL_TYPE_MENU,
+		.name		= "Row Binning",
+		.min		= 0,
+		/* filter out 'sum' from the menu by omitting last entry */
+		.max		= ARRAY_SIZE(ar0144_binning_menu) - 2,
+		.qmenu		= ar0144_binning_menu,
+	}, {
+		.ops		= &ar0144_ctrl_ops,
+		.id		= V4L2_CID_X_COMPANDING,
+		.type		= V4L2_CTRL_TYPE_BOOLEAN,
+		.name		= "Compading",
+		.min		= 0,
+		.max		= 1,
+		.step		= 1,
+		.def		= 0,
+	}, {
+		.ops		= &ar0144_ctrl_ops,
+		.id		= V4L2_CID_ANALOGUE_GAIN,
+		.type		= V4L2_CTRL_TYPE_INTEGER,
+		.min		= 1684,
+		.step		= 1,
+		.def		= 2000,
+	}, {
+		.ops		= &ar0144_ctrl_ops,
+		.id		= V4L2_CID_DIGITAL_GAIN,
+		.type		= V4L2_CTRL_TYPE_INTEGER,
+		.min		= 1000,
+		.step		= 1,
+		.max		= 15999,
+		.def		= 1000,
+	}, {
+		.ops		= &ar0144_ctrl_ops,
+		.id		= V4L2_CID_X_DIGITAL_GAIN_RED,
+		.type		= V4L2_CTRL_TYPE_INTEGER,
+		.name		= "Digital Gain Red",
+		.min		= 1000,
+		.step		= 1,
+		.max		= 15999,
+		.def		= 1000,
+	}, {
+		.ops		= &ar0144_ctrl_ops,
+		.id		= V4L2_CID_X_DIGITAL_GAIN_GREENR,
+		.type		= V4L2_CTRL_TYPE_INTEGER,
+		.name		= "Digital Gain Green (Red)",
+		.min		= 1000,
+		.step		= 1,
+		.max		= 15999,
+		.def		= 1000,
+	}, {
+		.ops		= &ar0144_ctrl_ops,
+		.id		= V4L2_CID_X_DIGITAL_GAIN_GREENB,
+		.type		= V4L2_CTRL_TYPE_INTEGER,
+		.name		= "Digital Gain Green (Blue)",
+		.min		= 1000,
+		.step		= 1,
+		.max		= 15999,
+		.def		= 1000,
+	}, {
+		.ops		= &ar0144_ctrl_ops,
+		.id		= V4L2_CID_X_DIGITAL_GAIN_BLUE,
+		.type		= V4L2_CTRL_TYPE_INTEGER,
+		.name		= "Digital Gain Blue",
+		.min		= 1000,
+		.step		= 1,
+		.max		= 15999,
+		.def		= 1000,
+	}, {
+		.ops		= &ar0144_ctrl_ops,
+		.id		= V4L2_CID_X_AUTOGAIN_ANALOGUE_MIN,
+		.type		= V4L2_CTRL_TYPE_MENU,
+		.name		= "Analogue Gain Auto Min",
+		.min		= 0,
+		.max		= ARRAY_SIZE(ar0144_ana_gain_min_menu) - 1,
+		.def		= 1,
+		.qmenu		= ar0144_ana_gain_min_menu,
+	}, {
+		.ops		= &ar0144_ctrl_ops,
+		.id		= V4L2_CID_LINK_FREQ,
+		.type		= V4L2_CTRL_TYPE_INTEGER_MENU,
+		.min		= 0,
+	}, {
+		.ops		= &ar0144_ctrl_ops,
+		.id		= V4L2_CID_PIXEL_RATE,
+		.type		= V4L2_CTRL_TYPE_INTEGER64,
+		.min		= 0,
+		.max		= INT_MAX,
+		.step		= 1,
+	}, {
+		.ops		= &ar0144_ctrl_ops,
+		.id		= V4L2_CID_X_BLACK_LEVEL_AUTO,
+		.type		= V4L2_CTRL_TYPE_BOOLEAN,
+		.name		= "Black Level Correction",
+		.min		= 0,
+		.max		= 1,
+		.step		= 1,
+		.def		= 1,
+	}, {
+		.ops		= &ar0144_ctrl_ops,
+		.id		= V4L2_CID_FLASH_LED_MODE,
+		.type		= V4L2_CTRL_TYPE_MENU,
+		.min		= 0,
+		.max		= V4L2_FLASH_LED_MODE_FLASH,
+		.menu_skip_mask = BIT(V4L2_FLASH_LED_MODE_TORCH),
+		.def		= V4L2_FLASH_LED_MODE_NONE,
+	}, {
+		.ops		= &ar0144_ctrl_ops,
+		.id		= V4L2_CID_X_FLASH_DELAY,
+		.type		= V4L2_CTRL_TYPE_INTEGER,
+		.name		= "Flash Delay",
+		.min		= -128,
+		.step		= 1,
+		.max		= 127,
+		.def		= 0,
+	}, {
+		.ops		= &ar0144_ctrl_ops,
+		.id		= V4L2_CID_X_DYNAMIC_PIXEL_CORRECTION,
+		.type		= V4L2_CTRL_TYPE_BOOLEAN,
+		.name		= "Dynamic Defect Pixel Correction",
+		.min		= 0,
+		.max		= 1,
+		.step		= 1,
+		.def		= 0,
+	}, {
+		.ops		= &ar0144_ctrl_ops,
+		.id		= V4L2_CID_X_TRIGGER_MODE,
+		.type		= V4L2_CTRL_TYPE_BOOLEAN,
+		.name		= "Trigger Mode",
+		.min		= 0,
+		.max		= 1,
+		.step		= 1,
+		.def		= 0,
+	},
+};
+
+static int ar0144_create_ctrls(struct ar0144 *sensor)
+{
+	struct ar0144_model_data *data = sensor->model->data;
+	struct v4l2_ctrl_config ctrl_cfg;
+	struct v4l2_ctrl *ctrl;
+	int i;
+	int ret;
+
+	ret = v4l2_ctrl_handler_init(&sensor->ctrls, 10);
+	if (ret)
+		return ret;
+
+	sensor->subdev.ctrl_handler = &sensor->ctrls;
+	sensor->ctrls.lock = &sensor->lock;
+
+	for (i = 0; i < ARRAY_SIZE(ar0144_ctrls); i++) {
+		ctrl_cfg = ar0144_ctrls[i];
+
+		switch (ctrl_cfg.id) {
+		case V4L2_CID_X_DIGITAL_GAIN_RED:
+		case V4L2_CID_X_DIGITAL_GAIN_GREENR:
+		case V4L2_CID_X_DIGITAL_GAIN_BLUE:
+		case V4L2_CID_X_DIGITAL_GAIN_GREENB:
+			if (sensor->color == AR0144_MODEL_MONOCHROME)
+				continue;
+
+			break;
+		case V4L2_CID_TEST_PATTERN_RED:
+		case V4L2_CID_TEST_PATTERN_GREENR:
+		case V4L2_CID_TEST_PATTERN_GREENB:
+		case V4L2_CID_TEST_PATTERN_BLUE:
+			ctrl_cfg.max = data->max_tp_color;
+			break;
+		case V4L2_CID_X_EMBEDDED_DATA:
+			if (sensor->info.bus_type == V4L2_MBUS_CSI2_DPHY)
+				continue;
+
+			break;
+		case V4L2_CID_ANALOGUE_GAIN:
+			if (sensor->info.bus_type == V4L2_MBUS_PARALLEL)
+				ctrl_cfg.max = data->max_parallel_again;
+			else
+				ctrl_cfg.max = data->max_mipi_again;
+
+			sensor->gains.max_again = ctrl_cfg.max;
+			break;
+		case V4L2_CID_EXPOSURE:
+			ctrl_cfg.def = data->def_height;
+			break;
+		case V4L2_CID_X_AUTO_EXPOSURE_MIN:
+			ctrl_cfg.min = data->aec_min_exposure;
+			ctrl_cfg.def = data->aec_min_exposure;
+			break;
+		case V4L2_CID_X_AUTO_EXPOSURE_MAX:
+			ctrl_cfg.min = data->aec_min_exposure;
+			ctrl_cfg.def = data->def_height;
+			break;
+		case V4L2_CID_HBLANK:
+			ctrl_cfg.min = data->limits->hlen.min - data->def_width;
+			ctrl_cfg.def = ctrl_cfg.min;
+			break;
+		case V4L2_CID_VBLANK:
+			ctrl_cfg.min = data->limits->vblank.min;
+			ctrl_cfg.def = ctrl_cfg.min;
+			break;
+		case V4L2_CID_LINK_FREQ:
+			ctrl_cfg.qmenu_int = sensor->info.link_freqs;
+			ctrl_cfg.def = sensor->num_fmts - 1;
+			ctrl_cfg.max = sensor->num_fmts - 1;
+			break;
+		default:
+			break;
+		}
+
+		ctrl = v4l2_ctrl_new_custom(&sensor->ctrls,
+					    &ctrl_cfg, sensor);
+
+		ret = sensor->ctrls.error;
+		if (ret) {
+			dev_warn(sensor->dev,
+				  "failed to register control "
+				  "'%s'(0x%x): %d\n",
+				  ctrl_cfg.name ? ctrl_cfg.name :
+				  v4l2_ctrl_get_name(ctrl_cfg.id),
+				  ctrl_cfg.id, ret);
+			return ret;
+		}
+
+		switch (ctrl->id) {
+		case V4L2_CID_PIXEL_RATE:
+			ctrl->flags |= V4L2_CTRL_FLAG_READ_ONLY |
+				       V4L2_CTRL_FLAG_VOLATILE;
+			break;
+		case V4L2_CID_LINK_FREQ:
+			ctrl->flags |= V4L2_CTRL_FLAG_READ_ONLY |
+				       V4L2_CTRL_FLAG_VOLATILE;
+			break;
+		case V4L2_CID_EXPOSURE:
+			sensor->exp_ctrl = ctrl;
+			break;
+		case V4L2_CID_VBLANK:
+			sensor->vblank_ctrl = ctrl;
+			break;
+		case V4L2_CID_HBLANK:
+			sensor->hblank_ctrl = ctrl;
+			break;
+		case V4L2_CID_ANALOGUE_GAIN:
+			sensor->gains.ana_ctrl = ctrl;
+			break;
+		case V4L2_CID_DIGITAL_GAIN:
+			ctrl->flags |= V4L2_CTRL_FLAG_EXECUTE_ON_WRITE |
+				       V4L2_CTRL_FLAG_UPDATE;
+			sensor->gains.dig_ctrl = ctrl;
+			break;
+		case V4L2_CID_X_DIGITAL_GAIN_RED:
+			if (sensor->color == AR0144_MODEL_COLOR)
+				sensor->gains.red_ctrl = ctrl;
+			break;
+		case V4L2_CID_X_DIGITAL_GAIN_GREENB:
+			if (sensor->color == AR0144_MODEL_COLOR)
+				sensor->gains.greenb_ctrl = ctrl;
+			break;
+		case V4L2_CID_X_DIGITAL_GAIN_GREENR:
+			if (sensor->color == AR0144_MODEL_COLOR)
+				sensor->gains.greenr_ctrl = ctrl;
+			break;
+		case V4L2_CID_X_DIGITAL_GAIN_BLUE:
+			if (sensor->color == AR0144_MODEL_COLOR)
+				sensor->gains.blue_ctrl = ctrl;
+			break;
+		default:
+			break;
+		}
+	}
+
+	return 0;
+}
+
+static struct ar0144_register ar0144_mipi_regs[] = {
+	{.reg = 0x30b0, .val = 0x0028},
+};
+
+static struct ar0144_register ar0234_mipi_regs[] = {
+	{.reg = 0x30ba, .val = 0x0000},
+	{.reg = 0x3ed0, .val = 0xff44},
+	{.reg = 0x3ed2, .val = 0x5596},
+	{.reg = 0x3ed4, .val = 0x031f},
+	{.reg = 0x3eee, .val = 0xa4ff},
+};
+
+static struct ar0144_register ar0234_parallel_regs[] = {
+	{.reg = 0x30ba, .val = 0x0000},
+	{.reg = 0x3ed0, .val = 0xff44},
+	{.reg = 0x3ed2, .val = 0x5596},
+	{.reg = 0x3ed4, .val = 0x031f},
+	{.reg = 0x3eee, .val = 0xa4aa},
+};
+
+static int ar0144_init_mipi_sensor(struct ar0144 *sensor)
+{
+	struct ar0144_model_data *data = sensor->model->data;
+	struct ar0144_register *mipi_regs;
+	unsigned int num_regs;
+	int ret, i;
+	u16 val = 0;
+
+	for (i = 0; i < data->size_timing0; i++) {
+		val |= (data->timing0[i].value << data->timing0[i].shift);
+		dev_dbg(sensor->dev, "%s: %u << %u\n", data->timing0[i].name,
+			data->timing0[i].value, data->timing0[i].shift);
+	}
+
+	dev_dbg(sensor->dev, "MIPI TIMING0: 0x%04x\n", val);
+
+	ret = ar0144_write(sensor, AR0144_MIPI_TIMING_0, val);
+	if (ret)
+		return ret;
+
+	val = 0;
+	for (i = 0; i < data->size_timing1; i++) {
+		val |= (data->timing1[i].value << data->timing1[i].shift);
+		dev_dbg(sensor->dev, "%s: %u << %u\n", data->timing1[i].name,
+			data->timing1[i].value, data->timing1[i].shift);
+	}
+
+	dev_dbg(sensor->dev, "MIPI TIMING1: 0x%04x\n", val);
+
+	ret = ar0144_write(sensor, AR0144_MIPI_TIMING_1, val);
+	if (ret)
+		return ret;
+
+	val = 0;
+	for (i = 0; i < data->size_timing2; i++) {
+		val |= (data->timing2[i].value << data->timing2[i].shift);
+		dev_dbg(sensor->dev, "%s: %u << %u\n", data->timing2[i].name,
+			data->timing2[i].value, data->timing2[i].shift);
+	}
+
+	dev_dbg(sensor->dev, "MIPI TIMING2: 0x%04x\n", val);
+
+	ret = ar0144_write(sensor, AR0144_MIPI_TIMING_2, val);
+	if (ret)
+		return ret;
+
+	val = 0;
+	for (i = 0; i < data->size_timing3; i++) {
+		val |= (data->timing3[i].value << data->timing3[i].shift);
+		dev_dbg(sensor->dev, "%s: %u << %u\n", data->timing3[i].name,
+			data->timing3[i].value, data->timing3[i].shift);
+	}
+
+	dev_dbg(sensor->dev, "MIPI TIMING3: 0x%04x\n", val);
+
+	ret = ar0144_write(sensor, AR0144_MIPI_TIMING_3, val);
+	if (ret)
+		return ret;
+
+	val = 0;
+	for (i = 0; i < data->size_timing4; i++) {
+		val |= (data->timing4[i].value << data->timing4[i].shift);
+		dev_dbg(sensor->dev, "%s: %u << %u\n", data->timing4[i].name,
+			data->timing4[i].value, data->timing4[i].shift);
+	}
+
+	dev_dbg(sensor->dev, "MIPI TIMING4: 0x%04x\n", val);
+
+	ret = ar0144_write(sensor, AR0144_MIPI_TIMING_4, val);
+	if (ret)
+		return ret;
+
+	switch (sensor->info.num_lanes) {
+	case 1:
+		val = BIT_SINGLE_LANE;
+		break;
+	case 2:
+		val = BIT_DUAL_LANE;
+		break;
+	case 4:
+		val = BIT_QUAD_LANE;
+		break;
+	}
+
+	ret = ar0144_update_bits(sensor, AR0144_SERIAL_FORMAT,
+				 BIT_QUAD_LANE | BIT_DUAL_LANE |
+				 BIT_SINGLE_LANE, val);
+	if (ret)
+		return ret;
+
+	if (sensor->model->chip == AR0144) {
+		mipi_regs = ar0144_mipi_regs;
+		num_regs = ARRAY_SIZE(ar0144_mipi_regs);
+	} else {
+		mipi_regs = ar0234_mipi_regs;
+		num_regs = ARRAY_SIZE(ar0234_mipi_regs);
+	}
+
+	for (i = 0; i < num_regs; i++) {
+		ret = ar0144_write(sensor, mipi_regs[i].reg, mipi_regs[i].val);
+		if (ret)
+			return ret;
+	}
+
+	return 0;
+}
+
+static int ar0144_init_parallel_sensor(struct ar0144 *sensor)
+{
+	unsigned int slew_rate_dat = sensor->info.slew_rate_dat;
+	unsigned int slew_rate_clk = sensor->info.slew_rate_clk;
+	u16 val = 0;
+	u16 mask = 0;
+	int i;
+	int ret;
+
+	if (slew_rate_dat != AR0144_NO_SLEW_RATE) {
+		val |= BIT_SLEW_RATE_DAT(slew_rate_dat);
+		mask |= BIT_SLEW_RATE_DAT_MASK;
+	}
+
+	if (slew_rate_clk != AR0144_NO_SLEW_RATE) {
+		val |= BIT_SLEW_RATE_CLK(slew_rate_clk);
+		mask |= BIT_SLEW_RATE_CLK_MASK;
+	}
+
+	if (mask) {
+		ret = ar0144_update_bits(sensor, AR0144_DATAPATH_SEL,
+					 mask, val);
+		if (ret)
+			return ret;
+	}
+
+	ret = ar0144_clear_bits(sensor, AR0144_SERIAL_FORMAT,
+				BIT_QUAD_LANE | BIT_DUAL_LANE |
+				BIT_SINGLE_LANE);
+	if (ret)
+		return ret;
+
+	/* Following settings are only relevant for AR0234 sensor */
+	if (sensor->model->chip == AR0144)
+		return 0;
+
+	for (i = 0; i < ARRAY_SIZE(ar0234_mipi_regs); i++) {
+		ret = ar0144_write(sensor, ar0234_parallel_regs[i].reg,
+				   ar0234_parallel_regs[i].val);
+		if (ret)
+			return ret;
+	}
+
+	return 0;
+}
+
+static unsigned long ar0144_clk_mul_div(unsigned long freq,
+					unsigned int mul,
+					unsigned int div)
+{
+	uint64_t result;
+
+	if (WARN_ON(div == 0))
+		return 0;
+
+	result = freq;
+	result *= mul;
+	result = div_u64(result, div);
+
+	return result;
+}
+
+static int ar0144_calculate_pll(struct ar0144 *sensor,
+				struct ar0144_pll_config *pll,
+				unsigned long ext_freq,
+				u64 link_freq,
+				unsigned int bpp)
+{
+	struct device *dev = sensor->dev;
+	const struct ar0144_sensor_limits *limits = sensor->model->data->limits;
+	unsigned long vco;
+	unsigned long word_clk;
+	unsigned long pix_clk;
+	unsigned long pix_target;
+	unsigned long diff, diff_old;
+	unsigned int lanes;
+	unsigned int div, mul, vt_sys_div, vt_pix_div;
+	unsigned int op_multiplier = 2;
+	unsigned int pix_clk_multiplier = 1;
+
+	if (sensor->info.bus_type == V4L2_MBUS_PARALLEL) {
+		lanes = 1;
+		pix_target = link_freq;
+	} else {
+		lanes = sensor->info.num_lanes;
+		pix_target = ar0144_clk_mul_div(link_freq, 2 * lanes, bpp);
+	}
+
+	if (sensor->model->chip == AR0234)
+		pix_clk_multiplier = lanes;
+
+	diff_old = pix_target;
+
+	pll->pre_pll_div = 1;
+	pll->pre_pll_mul = 0;
+	pll->vt_sys_div = 1;
+	pll->vt_pix_div = bpp;
+	pll->op_sys_div = 2;
+	pll->op_pix_div = bpp;
+
+	div = limits->div_lim.min;
+	mul = limits->mul_lim.min;
+	vt_sys_div = limits->vt_div_lim.min;
+	vt_pix_div = bpp;
+
+	if (sensor->model->chip == AR0144)
+		op_multiplier = lanes;
+
+	while (div <= limits->div_lim.max) {
+		if (mul % 2 != 0)
+			mul++;
+
+		if (mul > limits->mul_lim.max) {
+			mul = limits->mul_lim.min;
+			vt_sys_div = vt_sys_div == 1 ? 2 : vt_sys_div + 2;
+		}
+
+		if (vt_sys_div > limits->vt_div_lim.max) {
+			vt_sys_div = limits->vt_div_lim.min;
+			div++;
+		}
+
+		if (div > limits->div_lim.max) {
+			if (vt_pix_div < bpp)
+				break;
+
+			div = limits->div_lim.min;
+			vt_pix_div >>= 1;
+
+			if (op_multiplier <= 1)
+				break;
+
+			op_multiplier >>= 1;
+		}
+
+		if (vt_sys_div * op_multiplier > limits->vt_div_lim.max) {
+			mul++;
+			continue;
+		}
+
+		vco = ar0144_clk_mul_div(ext_freq, mul, div);
+
+		if (vco < limits->vco_lim.min || vco > limits->vco_lim.max) {
+			mul++;
+			continue;
+		}
+
+		word_clk = ar0144_clk_mul_div(vco, 1, vt_pix_div * vt_sys_div);
+		pix_clk = word_clk * pix_clk_multiplier;
+
+		if (word_clk > limits->word_clk_lim.max) {
+			mul++;
+			continue;
+		}
+
+		if (pix_clk > pix_target) {
+			mul++;
+			continue;
+		}
+
+		diff = pix_target - pix_clk;
+		if (diff >= diff_old) {
+			mul++;
+			continue;
+		}
+
+		diff_old = diff;
+
+		pll->pre_pll_div = div;
+		pll->pre_pll_mul = mul;
+		pll->op_sys_div = op_multiplier * vt_sys_div;
+		pll->vt_sys_div = vt_sys_div;
+		pll->vt_pix_div = vt_pix_div;
+		pll->vco_freq = vco;
+		pll->pix_freq = pix_clk;
+
+		dev_dbg(dev, "%s: vco: %lu pix_clk: %lu\n",
+			__func__, vco, pix_clk);
+		dev_dbg(dev, "%s vt_pix_div: %d vt_sys_div: %d\n",
+			__func__, pll->vt_pix_div, pll->vt_sys_div);
+		dev_dbg(dev, "%s op_sys_div: %d pll_div: %d pll_mul: %d\n",
+			__func__, pll->op_sys_div, div, mul);
+
+		if (sensor->info.bus_type == V4L2_MBUS_PARALLEL)
+			pll->ser_freq = pix_clk;
+		else
+			pll->ser_freq = ar0144_clk_mul_div(pix_clk, bpp,
+							   2 * lanes);
+
+		mul++;
+	}
+
+	if (pll->pre_pll_mul == 0) {
+		dev_err(dev, "Unable to find matching pll config\n");
+		return -EINVAL;
+	}
+
+	dev_dbg(dev, "PLL: bpp: %u VCO: %lu, PIX: %lu, SER: %lu\n",
+		bpp, pll->vco_freq, pll->pix_freq, pll->ser_freq);
+
+	return 0;
+}
+
+static int ar0144_setup_pll(struct ar0144 *sensor)
+{
+	struct device *dev = sensor->dev;
+	struct ar0144_businfo *info = &sensor->info;
+	unsigned long ext_freq;
+	u64 *link_freqs;
+	int ret;
+	int i;
+
+	link_freqs = devm_kcalloc(dev, sensor->num_fmts,
+				  sizeof(*info->link_freqs), GFP_KERNEL);
+	if (!link_freqs)
+		return -ENOMEM;
+
+	sensor->pll = devm_kcalloc(dev, sensor->num_fmts,
+				   sizeof(*sensor->pll), GFP_KERNEL);
+	if (!sensor->pll)
+		return -ENOMEM;
+
+	ext_freq = clk_get_rate(sensor->extclk);
+
+	for (i = 0; i < sensor->num_fmts; i++) {
+		ret = ar0144_calculate_pll(sensor, &sensor->pll[i],
+					   ext_freq,
+					   info->target_link_frequency,
+					   index_to_bpp(sensor, i));
+		if (ret)
+			return ret;
+
+		link_freqs[i] = sensor->pll[i].ser_freq;
+	}
+
+	info->link_freqs = link_freqs;
+
+	return 0;
+}
+
+static void ar0144_set_defaults(struct ar0144 *sensor)
+{
+	struct ar0144_model_data *data = sensor->model->data;
+	unsigned char bus_width;
+
+	sensor->crop.left = data->def_offset_x;
+	sensor->crop.top = data->def_offset_y;
+	sensor->crop.width = data->def_width;
+	sensor->crop.height = data->def_height;
+
+	sensor->fmt.width = data->def_width;
+	sensor->fmt.height = data->def_height;
+	sensor->fmt.field = V4L2_FIELD_NONE;
+
+	switch (sensor->model->chip) {
+	case AR0144:
+		if (sensor->color == AR0144_MODEL_MONOCHROME) {
+			sensor->formats = ar0144_mono_formats;
+			sensor->num_fmts = ARRAY_SIZE(ar0144_mono_formats);
+			sensor->fmt.colorspace = V4L2_COLORSPACE_SRGB;
+		} else {
+			sensor->formats = ar0144_col_formats;
+			sensor->num_fmts = ARRAY_SIZE(ar0144_col_formats);
+			sensor->fmt.colorspace = V4L2_COLORSPACE_RAW;
+		}
+		break;
+	case AR0234:
+		if (sensor->color == AR0144_MODEL_MONOCHROME) {
+			sensor->formats = ar0234_mono_formats;
+			sensor->num_fmts = ARRAY_SIZE(ar0234_mono_formats);
+			sensor->fmt.colorspace = V4L2_COLORSPACE_SRGB;
+		} else {
+			sensor->formats = ar0234_col_formats;
+			sensor->num_fmts = ARRAY_SIZE(ar0234_col_formats);
+			sensor->fmt.colorspace = V4L2_COLORSPACE_RAW;
+		}
+		break;
+	}
+
+	/* In case of parallel bus data-shifting re-calculate num_fmts */
+	if (sensor->info.bus_type == V4L2_MBUS_PARALLEL) {
+		bus_width = sensor->info.bus.parallel.bus_width;
+		sensor->num_fmts = bpp_to_index(sensor, bus_width) + 1;
+	}
+
+	sensor->fmt.code = sensor->formats[sensor->num_fmts - 1].code;
+	sensor->bpp = sensor->formats[sensor->num_fmts - 1].bpp;
+
+	sensor->w_skip = 1;
+	sensor->h_skip = 1;
+	sensor->hlen = data->limits->hlen.min;
+	sensor->vlen = sensor->fmt.height + data->limits->vblank.min;
+	sensor->gains.red = 1000;
+	sensor->gains.greenr = 1000;
+	sensor->gains.greenb = 1000;
+	sensor->gains.blue = 1000;
+	sensor->gains.min_ref = 1000;
+}
+
+static int ar0144_subdev_registered(struct v4l2_subdev *sd)
+{
+	struct ar0144 *sensor = to_ar0144(sd);
+	int ret;
+
+	ar0144_set_defaults(sensor);
+
+	ret = ar0144_setup_pll(sensor);
+	if (ret)
+		return ret;
+
+	if (sensor->info.bus_type == V4L2_MBUS_CSI2_DPHY)
+		ret = ar0144_init_mipi_sensor(sensor);
+	else
+		ret = ar0144_init_parallel_sensor(sensor);
+
+	if (ret)
+		return ret;
+
+	ret = ar0144_create_ctrls(sensor);
+	if (ret)
+		return ret;
+
+	v4l2_ctrl_handler_setup(&sensor->ctrls);
+
+	return 0;
+}
+
+static const struct v4l2_subdev_internal_ops ar0144_subdev_internal_ops = {
+	.registered		= ar0144_subdev_registered,
+};
+
+static int ar0144_check_chip_id(struct ar0144 *sensor)
+{
+	struct device *dev = sensor->dev;
+	u16 model_id, customer_rev;
+	int ret;
+
+	ret = ar0144_power_on(sensor);
+	if (ret) {
+		dev_err(dev, "Failed to power on sensor (%d)\n", ret);
+		return ret;
+	}
+
+	ar0144_reset(sensor);
+
+	ret = ar0144_read(sensor, AR0144_MODEL_ID, &model_id);
+	if (ret) {
+		dev_err(dev, "Failed to read model ID (%d)\n", ret);
+		goto out;
+	}
+
+	if (model_id != sensor->model->chip_version) {
+		dev_err(dev, "Wrong chip version: 0x%04x <-> 0x%04x\n",
+			model_id, sensor->model->chip_version);
+		ret = -ENOENT;
+		goto out;
+	}
+
+	ret = ar0144_read(sensor, AR0144_CUSTOMER_REV, &customer_rev);
+	if (ret)
+		goto out;
+
+	dev_info(dev, "Device ID: 0x%04x, %s model\n",
+		 model_id, customer_rev & BIT_COLOR ? "color" : "monochrome");
+
+	if (sensor->model->color == AR0144_MODEL_UNKNOWN) {
+		if (customer_rev & BIT_COLOR)
+			sensor->color = AR0144_MODEL_COLOR;
+		else
+			sensor->color = AR0144_MODEL_MONOCHROME;
+	} else {
+		sensor->color = sensor->model->color;
+	}
+
+out:
+	ar0144_power_off(sensor);
+	return ret;
+}
+
+static int ar0144_parse_parallel_props(struct ar0144 *sensor,
+				       struct fwnode_handle *ep,
+				       struct v4l2_fwnode_endpoint *bus_cfg)
+{
+	struct v4l2_mbus_config_parallel *parallel_bus;
+	unsigned int tmp;
+
+	sensor->info.bus.parallel = bus_cfg->bus.parallel;
+	parallel_bus = &sensor->info.bus.parallel;
+
+	if (parallel_bus->bus_width != 8 &&
+	    parallel_bus->bus_width != 10 &&
+	    parallel_bus->bus_width != 12) {
+		dev_err(sensor->dev, "Wrong bus width configured");
+		return -EINVAL;
+	}
+
+	if (parallel_bus->data_shift != 0 &&
+	    parallel_bus->data_shift != 2 &&
+	    parallel_bus->data_shift != 4) {
+		dev_err(sensor->dev, "Wrong data shift configured");
+		return -EINVAL;
+	}
+
+	if ((sensor->model->chip == AR0144 &&
+	    parallel_bus->bus_width + parallel_bus->data_shift > 12) ||
+	    (sensor->model->chip == AR0234 &&
+	    parallel_bus->bus_width + parallel_bus->data_shift > 10) ||
+	    (parallel_bus->bus_width + parallel_bus->data_shift < 8)) {
+		dev_err(sensor->dev,
+		    "Wrong combined bus width configured for %s",
+		    sensor->model->chip == AR0234 ? "AR0234" : "AR0144");
+		return -EINVAL;
+	}
+
+	tmp = AR0144_NO_SLEW_RATE;
+	fwnode_property_read_u32(ep, "onsemi,slew-rate-dat", &tmp);
+	sensor->info.slew_rate_dat = clamp_t(unsigned int, tmp, 0, 0x7);
+
+	tmp = AR0144_NO_SLEW_RATE;
+	fwnode_property_read_u32(ep, "onsemi,slew-rate-clk", &tmp);
+	sensor->info.slew_rate_clk = clamp_t(unsigned int, tmp, 0, 0x7);
+
+	return 0;
+}
+
+static int ar0144_parse_mipi_props(struct ar0144 *sensor,
+				   struct fwnode_handle *ep,
+				   struct v4l2_fwnode_endpoint *bus_cfg)
+{
+	struct ar0144_model_data *data = sensor->model->data;
+	unsigned int tmp;
+	int i;
+
+	sensor->info.num_lanes = bus_cfg->bus.mipi_csi2.num_data_lanes;
+	if (sensor->info.num_lanes < 1 ||
+	    sensor->info.num_lanes > data->max_lanes) {
+		dev_err(sensor->dev, "Wrong number of lanes configured");
+		return -EINVAL;
+	}
+
+	sensor->info.bus.mipi = bus_cfg->bus.mipi_csi2;
+
+	for (i = 0; i < data->size_timing0; i++) {
+		tmp = data->timing0[i].value;
+		fwnode_property_read_u32(ep, data->timing0[i].name, &tmp);
+		data->timing0[i].value = clamp_t(unsigned int, tmp, 0,
+						 data->timing0[i].max);
+	}
+
+	for (i = 0; i < data->size_timing1; i++) {
+		tmp = data->timing1[i].value;
+		fwnode_property_read_u32(ep, data->timing1[i].name, &tmp);
+		data->timing1[i].value = clamp_t(unsigned int, tmp, 0,
+						 data->timing1[i].max);
+	}
+
+	for (i = 0; i < data->size_timing2; i++) {
+		tmp = data->timing2[i].value;
+		fwnode_property_read_u32(ep, data->timing2[i].name, &tmp);
+		data->timing2[i].value = clamp_t(unsigned int, tmp, 0,
+						 data->timing2[i].max);
+	}
+
+	for (i = 0; i < data->size_timing3; i++) {
+		tmp = data->timing3[i].value;
+		fwnode_property_read_u32(ep, data->timing3[i].name, &tmp);
+		data->timing3[i].value = clamp_t(unsigned int, tmp, 0,
+						 data->timing3[i].max);
+	}
+
+	for (i = 0; i < data->size_timing4; i++) {
+		tmp = data->timing4[i].value;
+		fwnode_property_read_u32(ep, data->timing4[i].name, &tmp);
+		data->timing4[i].value = clamp_t(unsigned int, tmp, 0,
+						 data->timing4[i].max);
+	}
+
+	return 0;
+}
+
+static int ar0144_of_probe(struct ar0144 *sensor)
+{
+	struct device *dev = sensor->dev;
+	struct ar0144_businfo *info = &sensor->info;
+	struct ar0144_model_data *data = sensor->model->data;
+	struct clk *clk;
+	struct gpio_desc *gpio;
+	struct fwnode_handle *ep;
+	struct v4l2_fwnode_endpoint bus_cfg = {
+		.bus_type = V4L2_MBUS_UNKNOWN,
+	};
+	int ret;
+
+	clk = devm_clk_get(dev, "ext");
+	ret = PTR_ERR_OR_ZERO(clk);
+	if (ret == -EPROBE_DEFER)
+		return ret;
+	if (ret < 0) {
+		dev_err(dev, "Failed to get external clock (%d)\n", ret);
+		return ret;
+	}
+
+	sensor->extclk = clk;
+
+	gpio = devm_gpiod_get_optional(dev, "reset", GPIOD_OUT_HIGH);
+	ret = PTR_ERR_OR_ZERO(gpio);
+	if (ret < 0) {
+		dev_err(dev, "Failed to get reset gpio (%d)\n", ret);
+		return ret;
+	}
+
+	sensor->reset_gpio = gpio;
+
+	sensor->reset_delay_ms = AR0144_DEFAULT_RESET_DELAY;
+	of_property_read_u32(dev->of_node, "onsemi,reset-delay-ms",
+			     &sensor->reset_delay_ms);
+
+	ep = fwnode_graph_get_next_endpoint(dev_fwnode(dev), NULL);
+	if (!ep)
+		return -EINVAL;
+
+	ret = v4l2_fwnode_endpoint_alloc_parse(ep, &bus_cfg);
+	if (ret) {
+		dev_err(dev, "Failed to parse bus info (%d)\n", ret);
+		goto out_put;
+	}
+
+	info->bus_type = bus_cfg.bus_type;
+
+	if (bus_cfg.nr_of_link_frequencies != 1) {
+		dev_err(dev, "Link frequency required\n");
+		ret = -EINVAL;
+		goto out_put;
+	}
+
+	if (info->bus_type == V4L2_MBUS_PARALLEL &&
+	    bus_cfg.link_frequencies[0] > data->max_parallel_link_freq) {
+		dev_err(dev, "Parallel Link frequency exceeds maximum\n");
+		ret = -EINVAL;
+		goto out_put;
+	}
+
+	if (info->bus_type == V4L2_MBUS_CSI2_DPHY &&
+	    bus_cfg.link_frequencies[0] > data->max_mipi_link_freq) {
+		dev_err(dev, "MIPI Link frequency exceeds maximum\n");
+		ret = -EINVAL;
+		goto out_put;
+	}
+
+	info->target_link_frequency = bus_cfg.link_frequencies[0];
+
+	switch (info->bus_type) {
+	case V4L2_MBUS_PARALLEL:
+		ret = ar0144_parse_parallel_props(sensor, ep, &bus_cfg);
+		break;
+	case V4L2_MBUS_CSI2_DPHY:
+		ret = ar0144_parse_mipi_props(sensor, ep, &bus_cfg);
+		break;
+	default:
+		dev_err(dev, "Invalid bus type\n");
+		ret = -EINVAL;
+	}
+
+	if (ret)
+		goto out_put;
+
+out_put:
+	v4l2_fwnode_endpoint_free(&bus_cfg);
+	fwnode_handle_put(ep);
+	return ret;
+}
+
+static const struct i2c_device_id ar0144_id_table[];
+
+static int ar0144_probe(struct i2c_client *i2c)
+{
+	struct ar0144 *sensor;
+	struct v4l2_subdev *sd;
+	struct ar0144_model *model;
+	int ret;
+
+	sensor = devm_kzalloc(&i2c->dev, sizeof(*sensor), GFP_KERNEL);
+	if (!sensor)
+		return -ENOMEM;
+
+	if (i2c->dev.of_node)
+		model = (struct ar0144_model *)device_get_match_data(&i2c->dev);
+	else
+		model = (void *)i2c_match_id(ar0144_id_table, i2c)->driver_data;
+
+	sd = &sensor->subdev;
+	sensor->model = model;
+	sensor->dev = &i2c->dev;
+
+	dev_info(sensor->dev, "Probing %s Driver\n",
+		 model->chip == AR0234 ? "AR0234" : "AR0144");
+
+	ret = ar0144_of_probe(sensor);
+	if (ret)
+		return ret;
+
+	mutex_init(&sensor->lock);
+
+	v4l2_i2c_subdev_init(sd, i2c, &ar0144_subdev_ops);
+
+	switch (sensor->model->chip) {
+	case AR0144:
+		v4l2_i2c_subdev_set_name(sd, i2c, "ar0144", NULL);
+		break;
+	case AR0234:
+		v4l2_i2c_subdev_set_name(sd, i2c, "ar0234", NULL);
+		break;
+	}
+
+	sd->flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;
+	sd->internal_ops = &ar0144_subdev_internal_ops;
+	sd->entity.function = MEDIA_ENT_F_CAM_SENSOR;
+	sd->entity.ops = &ar0144_entity_ops;
+
+	sensor->pad.flags = MEDIA_PAD_FL_SOURCE;
+
+	ret = media_entity_pads_init(&sd->entity, 1, &sensor->pad);
+	if (ret)
+		goto out_media;
+
+	ret = ar0144_check_chip_id(sensor);
+	if (ret)
+		goto out_media;
+
+	ret = v4l2_async_register_subdev_sensor(&sensor->subdev);
+	if (ret)
+		goto out;
+
+	return 0;
+
+out:
+	v4l2_ctrl_handler_free(&sensor->ctrls);
+out_media:
+	media_entity_cleanup(&sd->entity);
+	mutex_destroy(&sensor->lock);
+	return ret;
+}
+
+static void ar0144_remove(struct i2c_client *i2c)
+{
+	struct v4l2_subdev *sd = i2c_get_clientdata(i2c);
+	struct ar0144 *sensor = to_ar0144(sd);
+
+	v4l2_async_unregister_subdev(sd);
+	v4l2_ctrl_handler_free(&sensor->ctrls);
+	media_entity_cleanup(&sd->entity);
+	mutex_destroy(&sensor->lock);
+}
+
+static const struct ar0144_sensor_limits ar0144_limits = {
+			/* min		max	 */
+	.x		= {0,		1295      },
+	.y		= {0,		807       },
+	.hlen		= {1488,	65534     },
+	.vlen		= {29,		65535     },
+	.hblank		= {208,		65535     },
+	.vblank		= {27,		65535     },
+	.ext_clk	= {6000000,	48000000  },
+	.div_lim	= {1,		63	  },
+	.mul_lim	= {32,		254	  },
+	.vt_div_lim	= {1,		16	  },
+	.word_clk_lim	= {0,		74250000  },
+	.vco_lim	= {384000000,	768000000 },
+};
+
+static struct ar0144_mipi_timing ar0144_timing0[] = {
+	{.name = "onsemi,t-hs-prep", .value = 2, .max = 15, .shift = 12 },
+	{.name = "onsemi,t-hs-zero", .value = 6, .max = 15, .shift = 8 },
+	{.name = "onsemi,t-hs-trail", .value = 6, .max = 15, .shift = 4 },
+	{.name = "onsemi,t-clk-trail", .value = 5, .max = 15, .shift = 0 },
+};
+
+static struct ar0144_mipi_timing ar0144_timing1[] = {
+	{.name = "onsemi,t-clk-prep", .value = 1, .max = 15, .shift = 12 },
+	{.name = "onsemi,t-hs-exit", .value = 4, .max = 63, .shift = 6 },
+	{.name = "onsemi,t-clk-zero", .value = 14, .max = 63, .shift = 0 },
+};
+
+static struct ar0144_mipi_timing ar0144_timing2[] = {
+	{.name = "onsemi,t-bgap", .value = 2, .max = 15, .shift = 12 },
+	{.name = "onsemi,t-clk-pre", .value = 1, .max = 63, .shift = 6 },
+	{.name = "onsemi,t-clk-post", .value = 7, .max = 63, .shift = 0 },
+};
+
+static struct ar0144_mipi_timing ar0144_timing3[] = {
+	{.name = "onsemi,t-lpx", .value = 2, .max = 63, .shift = 7 },
+	{.name = "onsemi,t-wakeup", .value = 5, .max = 127, .shift = 0 },
+};
+
+static struct ar0144_mipi_timing ar0144_timing4[] = {
+	{.name = "onsemi,cont-tx-clk", .value = 0, .max = 1, .shift = 15 },
+	{.name = "onsemi,heavy-lp-load", .value = 0, .max = 1, .shift = 14 },
+	{.name = "onsemi,t-init", .value = 4, .max = 127, .shift = 0 },
+};
+
+static const struct ar0144_sensor_limits ar0234_limits = {
+			/* min		max	 */
+	.x		= {0,		1927      },
+	.y		= {0,		1215      },
+	.hlen		= {2448,	65534     },
+	.vlen		= {29,		65535     },
+	.hblank		= {200,		65535     },
+	.vblank		= {21,		65535     },
+	.ext_clk	= {6000000,	54000000  },
+	.div_lim	= {1,		63	  },
+	.mul_lim	= {32,		254	  },
+	.vt_div_lim	= {1,		16	  },
+	.word_clk_lim	= {0,		90000000  },
+	.vco_lim	= {384000000,	768000000 },
+};
+
+static struct ar0144_mipi_timing ar0234_timing0[] = {
+	{.name = "onsemi,t-hs-prep", .value = 5, .max = 15, .shift = 12 },
+	{.name = "onsemi,t-hs-trail", .value = 9, .max = 31, .shift = 6 },
+	{.name = "onsemi,t-clk-trail", .value = 8, .max = 31, .shift = 0 },
+};
+
+static struct ar0144_mipi_timing ar0234_timing1[] = {
+	{.name = "onsemi,t-clk-prep", .value = 3, .max = 15, .shift = 12 },
+	{.name = "onsemi,t-hs-exit", .value = 10, .max = 63, .shift = 6 },
+	{.name = "onsemi,t-clk-zero", .value = 24, .max = 63, .shift = 0 },
+};
+
+static struct ar0144_mipi_timing ar0234_timing2[] = {
+	{.name = "onsemi,t-bgap", .value = 9, .max = 15, .shift = 12 },
+	{.name = "onsemi,t-clk-pre", .value = 1, .max = 63, .shift = 6 },
+	{.name = "onsemi,t-clk-post", .value = 11, .max = 63, .shift = 0 },
+};
+
+static struct ar0144_mipi_timing ar0234_timing3[] = {
+	{.name = "onsemi,t-lpx", .value = 6, .max = 63, .shift = 7 },
+	{.name = "onsemi,t-wakeup", .value = 12, .max = 127, .shift = 0 },
+};
+
+static struct ar0144_mipi_timing ar0234_timing4[] = {
+	{.name = "onsemi,cont-tx-clk", .value = 1, .max = 1, .shift = 15 },
+	{.name = "onsemi,heavy-lp-load", .value = 0, .max = 1, .shift = 14 },
+	{.name = "onsemi,t-init", .value = 10, .max = 127, .shift = 0 },
+};
+
+struct ar0144_model_data ar0144_data = {
+	.max_lanes = 2,
+	.multiplier = 1,
+	.max_parallel_link_freq = 74250000,
+	.max_mipi_link_freq = 384000000,
+	.max_parallel_again = 16000,
+	.max_mipi_again = 16000,
+	.max_tp_color = 4095,
+	.aec_min_exposure = 1,
+	.def_width = 1280,
+	.def_height = 800,
+	.def_offset_x = 4,
+	.def_offset_y = 4,
+	.timing0 = ar0144_timing0,
+	.size_timing0 = ARRAY_SIZE(ar0144_timing0),
+	.timing1 = ar0144_timing1,
+	.size_timing1 = ARRAY_SIZE(ar0144_timing1),
+	.timing2 = ar0144_timing2,
+	.size_timing2 = ARRAY_SIZE(ar0144_timing2),
+	.timing3 = ar0144_timing3,
+	.size_timing3 = ARRAY_SIZE(ar0144_timing3),
+	.timing4 = ar0144_timing4,
+	.size_timing4 = ARRAY_SIZE(ar0144_timing4),
+	.limits = &ar0144_limits,
+};
+
+struct ar0144_model_data ar0234_data = {
+	.max_lanes = 4,
+	.multiplier = 4,
+	.max_parallel_link_freq = 360000000,
+	.max_mipi_link_freq = 450000000,
+	.max_parallel_again = 8000,
+	.max_mipi_again = 16000,
+	.max_tp_color = 1023,
+	.aec_min_exposure = 2,
+	.def_width = 1920,
+	.def_height = 1200,
+	.def_offset_x = 6,
+	.def_offset_y = 6,
+	.timing0 = ar0234_timing0,
+	.size_timing0 = ARRAY_SIZE(ar0234_timing0),
+	.timing1 = ar0234_timing1,
+	.size_timing1 = ARRAY_SIZE(ar0234_timing1),
+	.timing2 = ar0234_timing2,
+	.size_timing2 = ARRAY_SIZE(ar0234_timing2),
+	.timing3 = ar0234_timing3,
+	.size_timing3 = ARRAY_SIZE(ar0234_timing3),
+	.timing4 = ar0234_timing4,
+	.size_timing4 = ARRAY_SIZE(ar0234_timing4),
+	.limits = &ar0234_limits,
+};
+
+struct ar0144_model ar0144_unknown = {
+	.chip = AR0144,
+	.color = AR0144_MODEL_UNKNOWN,
+	.chip_version = AR0144_CHIP_VERSION,
+	.data = &ar0144_data,
+};
+
+struct ar0144_model ar0144_col = {
+	.chip = AR0144,
+	.color = AR0144_MODEL_COLOR,
+	.chip_version = AR0144_CHIP_VERSION,
+	.data = &ar0144_data,
+};
+
+struct ar0144_model ar0144_mono = {
+	.chip = AR0144,
+	.color = AR0144_MODEL_MONOCHROME,
+	.chip_version = AR0144_CHIP_VERSION,
+	.data = &ar0144_data,
+};
+
+struct ar0144_model ar0234_unknown = {
+	.chip = AR0234,
+	.color = AR0144_MODEL_UNKNOWN,
+	.chip_version = AR0234_CHIP_VERSION,
+	.data = &ar0234_data,
+};
+
+struct ar0144_model ar0234_col = {
+	.chip = AR0234,
+	.color = AR0144_MODEL_COLOR,
+	.chip_version = AR0234_CHIP_VERSION,
+	.data = &ar0234_data,
+};
+
+struct ar0144_model ar0234_mono = {
+	.chip = AR0234,
+	.color = AR0144_MODEL_MONOCHROME,
+	.chip_version = AR0234_CHIP_VERSION,
+	.data = &ar0234_data,
+};
+
+static const struct i2c_device_id ar0144_id_table[] = {
+	{ "ar0144", (kernel_ulong_t)&ar0144_unknown },
+	{ "ar0144c", (kernel_ulong_t)&ar0144_col },
+	{ "ar0144m", (kernel_ulong_t)&ar0144_mono },
+	{ "ar0234", (kernel_ulong_t)&ar0234_unknown },
+	{ "ar0234c", (kernel_ulong_t)&ar0234_col },
+	{ "ar0234m", (kernel_ulong_t)&ar0234_mono },
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(i2c, ar0144_id_table);
+
+static const struct of_device_id ar0144_of_match[] = {
+	{
+		.compatible = "onsemi,ar0144",
+		.data = (void *)&ar0144_unknown,
+	}, {
+		.compatible = "onsemi,ar0144c",
+		.data = (void *)&ar0144_col,
+	}, {
+		.compatible = "onsemi,ar0144m",
+		.data = (void *)&ar0144_mono,
+	}, {
+		.compatible = "onsemi,ar0234",
+		.data = (void *)&ar0234_unknown,
+	}, {
+		.compatible = "onsemi,ar0234c",
+		.data = (void *)&ar0234_col,
+	}, {
+		.compatible = "onsemi,ar0234m",
+		.data = (void *)&ar0234_mono,
+	},
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(of, ar0144_of_match);
+
+static struct i2c_driver ar0144_i2c_driver = {
+	.driver	= {
+		.name = "ar0144",
+		.of_match_table	= of_match_ptr(ar0144_of_match),
+	},
+	.probe		= ar0144_probe,
+	.remove		= ar0144_remove,
+	.id_table	= ar0144_id_table,
+};
+module_i2c_driver(ar0144_i2c_driver);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Stefan Riedmueller <s.riedmueller@phytec.de>");
diff --git a/drivers/media/i2c/vvsensor.h b/drivers/media/i2c/vvsensor.h
new file mode 100644
index 000000000000..0a4a538a470f
--- /dev/null
+++ b/drivers/media/i2c/vvsensor.h
@@ -0,0 +1,225 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+/*
+ * Copyright (c) 2020-2021 VeriSilicon Holdings Co., Ltd.
+ */
+
+#ifndef _VVSENSOR_PUBLIC_HEADER_H_
+#define _VVSENSOR_PUBLIC_HEADER_H_
+
+#ifndef __KERNEL__
+#include <stdint.h>
+#else
+#include <linux/uaccess.h>
+#endif
+
+#define VVCAM_SUPPORT_MAX_MODE_COUNT                6
+#define VVCAM_CAP_BUS_INFO_I2C_ADAPTER_NR_POS       8
+
+#define SENSOR_FIX_FRACBITS 10
+
+enum {
+	VVSENSORIOC_RESET = 0x100,
+	VVSENSORIOC_S_POWER,
+	VVSENSORIOC_G_POWER,
+	VVSENSORIOC_S_CLK,
+	VVSENSORIOC_G_CLK,
+	VVSENSORIOC_QUERY,
+	VVSENSORIOC_S_SENSOR_MODE,
+	VVSENSORIOC_G_SENSOR_MODE,
+	VVSENSORIOC_READ_REG,
+	VVSENSORIOC_WRITE_REG,
+	VVSENSORIOC_READ_ARRAY,
+	VVSENSORIOC_WRITE_ARRAY,
+	VVSENSORIOC_G_NAME,
+	VVSENSORIOC_G_RESERVE_ID,
+	VVSENSORIOC_G_CHIP_ID,
+	VVSENSORIOC_S_INIT,
+	VVSENSORIOC_S_STREAM,
+	VVSENSORIOC_S_LONG_EXP,
+	VVSENSORIOC_S_EXP,
+	VVSENSORIOC_S_VSEXP,
+	VVSENSORIOC_S_LONG_GAIN,
+	VVSENSORIOC_S_GAIN,
+	VVSENSORIOC_S_VSGAIN,
+	VVSENSORIOC_S_FPS,
+	VVSENSORIOC_G_FPS,
+	VVSENSORIOC_S_HDR_RADIO,
+	VVSENSORIOC_S_WB,
+	VVSENSORIOC_S_BLC,
+	VVSENSORIOC_G_EXPAND_CURVE,
+	VVSENSORIOC_S_TEST_PATTERN,
+	VVSENSORIOC_G_LENS,
+	VVSENSORIOC_MAX,
+};
+
+struct vvcam_clk_s {
+	uint32_t      status;
+	unsigned long sensor_mclk;
+	unsigned long csi_max_pixel_clk;
+};
+/* W/R registers */
+struct vvcam_sccb_data_s {
+	uint32_t addr;
+	uint32_t data;
+};
+
+/* vsi native usage */
+struct vvcam_sccb_cfg_s {
+	uint8_t slave_addr;
+	uint8_t addr_byte;
+	uint8_t data_byte;
+};
+
+struct vvcam_sccb_array_s {
+	uint32_t count;
+	struct vvcam_sccb_data_s *sccb_data;
+};
+
+typedef struct sensor_hdr_artio_s {
+	uint32_t ratio_l_s;
+	uint32_t ratio_s_vs;
+	uint32_t accuracy;
+} sensor_hdr_artio_t;
+
+typedef struct vvcam_ae_info_s {
+	uint32_t def_frm_len_lines;
+	uint32_t curr_frm_len_lines;
+	uint32_t one_line_exp_time_ns;
+	/*
+	 * normal use  max_integration_line
+	 * 2Expsoure use max_integration_line and max_vsintegration_line
+	 *
+	 */
+	uint32_t max_longintegration_line;
+	uint32_t min_longintegration_line;
+
+	uint32_t max_integration_line;
+	uint32_t min_integration_line;
+
+	uint32_t max_vsintegration_line;
+	uint32_t min_vsintegration_line;
+
+	uint32_t max_long_again;
+	uint32_t min_long_again;
+	uint32_t max_long_dgain;
+	uint32_t min_long_dgain;
+
+	uint32_t max_again;
+	uint32_t min_again;
+	uint32_t max_dgain;
+	uint32_t min_dgain;
+
+	uint32_t max_short_again;
+	uint32_t min_short_again;
+	uint32_t max_short_dgain;
+	uint32_t min_short_dgain;
+
+	uint32_t start_exposure;
+
+	uint32_t gain_step;
+	uint32_t cur_fps;
+	uint32_t max_fps;
+	uint32_t min_fps;
+	uint32_t min_afps;
+	uint8_t  int_update_delay_frm;
+	uint8_t  gain_update_delay_frm;
+	struct sensor_hdr_artio_s hdr_ratio;
+} vvcam_ae_info_t;
+
+struct sensor_mipi_info_s {
+	uint32_t mipi_lane;
+};
+
+enum sensor_hdr_mode_e {
+	SENSOR_MODE_LINEAR,
+	SENSOR_MODE_HDR_STITCH,
+	SENSOR_MODE_HDR_NATIVE,
+};
+
+enum sensor_bayer_pattern_e {
+	BAYER_RGGB = 0,
+	BAYER_GRBG = 1,
+	BAYER_GBRG = 2,
+	BAYER_BGGR = 3,
+	BAYER_BUTT
+};
+
+enum sensor_stitching_mode_e {
+	SENSOR_STITCHING_DUAL_DCG           = 0,    /**< dual DCG mode 3x12-bit */
+	SENSOR_STITCHING_3DOL               = 1,    /**< dol3 frame 3x12-bit */
+	SENSOR_STITCHING_LINEBYLINE         = 2,    /**< 3x12-bit line by line without waiting */
+	SENSOR_STITCHING_16BIT_COMPRESS     = 3,    /**< 16-bit compressed data + 12-bit RAW */
+	SENSOR_STITCHING_DUAL_DCG_NOWAIT    = 4,    /**< 2x12-bit dual DCG without waiting */
+	SENSOR_STITCHING_2DOL               = 5,    /**< dol2 frame or 1 CG+VS sx12-bit RAW */
+	SENSOR_STITCHING_L_AND_S            = 6,    /**< L+S 2x12-bit RAW */
+	SENSOR_STITCHING_MAX
+
+};
+
+typedef struct sensor_test_pattern_s {
+	uint8_t enable;
+	uint32_t pattern;
+}sensor_test_pattern_t;
+
+typedef struct sensor_expand_curve_s {
+	uint32_t x_bit;
+	uint32_t y_bit;
+	uint8_t expand_px[64];
+	uint32_t expand_x_data[65];
+	uint32_t expand_y_data[65];
+} sensor_expand_curve_t;
+
+typedef struct sensor_data_compress_s {
+	uint32_t enable;
+	uint32_t x_bit;
+	uint32_t y_bit;
+} sensor_data_compress_t;
+
+typedef struct vvcam_size_s {
+	uint32_t bounds_width;
+	uint32_t bounds_height;
+	uint32_t top;
+	uint32_t left;
+	uint32_t width;
+	uint32_t height;
+} vvcam_size_t;
+
+typedef struct vvcam_mode_info_s {
+	uint32_t index;
+	vvcam_size_t size;
+	uint32_t hdr_mode;
+	uint32_t stitching_mode;
+	uint32_t bit_width;
+	sensor_data_compress_t data_compress;
+	uint32_t bayer_pattern;
+	vvcam_ae_info_t ae_info;
+	struct sensor_mipi_info_s mipi_info;
+	void *preg_data;
+	uint32_t reg_data_count;
+} vvcam_mode_info_t;
+
+typedef struct sensor_blc_s {
+	uint32_t red;
+	uint32_t gr;
+	uint32_t gb;
+	uint32_t blue;
+} sensor_blc_t;
+
+typedef struct sensor_white_balance_s {
+	uint32_t r_gain;
+	uint32_t gr_gain;
+	uint32_t gb_gain;
+	uint32_t b_gain;
+} sensor_white_balance_t;
+
+typedef struct vvcam_mode_info_array_s {
+	uint32_t count;
+	struct vvcam_mode_info_s modes[VVCAM_SUPPORT_MAX_MODE_COUNT];
+} vvcam_mode_info_array_t;
+
+typedef struct vvcam_lens_s {
+	uint32_t id;
+	char name[16];
+} vvcam_lens_t;
+
+#endif
diff --git a/drivers/media/platform/st/stm32/stm32-dcmi.c b/drivers/media/platform/st/stm32/stm32-dcmi.c
index 320425a72a9c..4f2bd9ba8a61 100644
--- a/drivers/media/platform/st/stm32/stm32-dcmi.c
+++ b/drivers/media/platform/st/stm32/stm32-dcmi.c
@@ -1710,6 +1710,14 @@ static const struct dcmi_format dcmi_formats[] = {
 		.fourcc = V4L2_PIX_FMT_SRGGB14,
 		.mbus_code = MEDIA_BUS_FMT_SRGGB14_1X14,
 		.bpp = 2,
+	}, {
+		.fourcc = V4L2_PIX_FMT_GREY,
+		.mbus_code = MEDIA_BUS_FMT_Y8_1X8,
+		.bpp = 1,
+	}, {
+		.fourcc = V4L2_PIX_FMT_Y10,
+		.mbus_code = MEDIA_BUS_FMT_Y10_1X10,
+		.bpp = 2,
 	},
 };
 
@@ -1888,6 +1896,8 @@ static int dcmi_graph_notify_bound(struct v4l2_async_notifier *notifier,
 				   struct v4l2_async_connection *asd)
 {
 	struct stm32_dcmi *dcmi = notifier_to_dcmi(notifier);
+	struct device_node *ep = NULL;
+	struct device_node *remote_ep = NULL;
 	unsigned int ret;
 	int src_pad;
 
@@ -1902,13 +1912,28 @@ static int dcmi_graph_notify_bound(struct v4l2_async_notifier *notifier,
 	dev_dbg(dcmi->dev, "Device registered as %s\n",
 		video_device_node_name(dcmi->vdev));
 
+	ep = of_graph_get_next_endpoint(dcmi->dev->of_node, ep);
+	if (!ep)
+		return -EINVAL;
+
+	remote_ep = of_graph_get_remote_endpoint(ep);
+	of_node_put(ep);
+	if (!remote_ep)
+		return -EINVAL;
+
 	/*
 	 * Link this sub-device to DCMI, it could be
 	 * a parallel camera sensor or a bridge
 	 */
 	src_pad = media_entity_get_fwnode_pad(&subdev->entity,
-					      subdev->fwnode,
+					      of_fwnode_handle(remote_ep),
 					      MEDIA_PAD_FL_SOURCE);
+	of_node_put(remote_ep);
+	if (src_pad < 0) {
+		dev_err(dcmi->dev, "Failed to find source pad of %s (%d)\n",
+			subdev->name, src_pad);
+		return src_pad;
+	}
 
 	ret = media_create_pad_link(&subdev->entity, src_pad,
 				    &dcmi->vdev->entity, 0,
diff --git a/drivers/media/platform/st/stm32/stm32-dcmipp/dcmipp-core.c b/drivers/media/platform/st/stm32/stm32-dcmipp/dcmipp-core.c
index 7c7cc6f60b88..36760b7d161e 100644
--- a/drivers/media/platform/st/stm32/stm32-dcmipp/dcmipp-core.c
+++ b/drivers/media/platform/st/stm32/stm32-dcmipp/dcmipp-core.c
@@ -343,6 +343,7 @@ static int dcmipp_graph_notify_bound(struct v4l2_async_notifier *notifier,
 	struct dcmipp_ent_device *sink;
 	struct v4l2_fwnode_endpoint vep = { 0 };
 	struct fwnode_handle *ep;
+	struct fwnode_handle *remote_ep;
 	enum v4l2_mbus_type supported_types[] = {
 		V4L2_MBUS_PARALLEL, V4L2_MBUS_BT656, V4L2_MBUS_CSI2_DPHY
 	};
@@ -356,14 +357,6 @@ static int dcmipp_graph_notify_bound(struct v4l2_async_notifier *notifier,
 				     "st,stm32mp25-dcmipp"))
 		supported_types_nb--;
 
-	/*
-	 * Link this sub-device to DCMIPP, it could be
-	 * a parallel camera sensor or a CSI-2 to parallel bridge
-	 */
-	src_pad = media_entity_get_fwnode_pad(&subdev->entity,
-					      subdev->fwnode,
-					      MEDIA_PAD_FL_SOURCE);
-
 	/* Get bus characteristics from devicetree */
 	ep = fwnode_graph_get_endpoint_by_id(dev_fwnode(dcmipp->dev), 0, 0,
 					     FWNODE_GRAPH_ENDPOINT_NEXT);
@@ -372,6 +365,20 @@ static int dcmipp_graph_notify_bound(struct v4l2_async_notifier *notifier,
 		return -ENODEV;
 	}
 
+	remote_ep = fwnode_graph_get_remote_endpoint(ep);
+	if (!remote_ep) {
+		dev_err(dcmipp->dev, "Could not find the remote endpoint\n");
+		return -ENODEV;
+	}
+
+	/*
+	 * Link this sub-device to DCMIPP, it could be
+	 * a parallel camera sensor or a CSI-2 to parallel bridge
+	 */
+	src_pad = media_entity_get_fwnode_pad(&subdev->entity,
+					      remote_ep,
+					      MEDIA_PAD_FL_SOURCE);
+
 	/* Check for supported MBUS type */
 	for (i = 0; i < supported_types_nb; i++) {
 		vep.bus_type = supported_types[i];
diff --git a/drivers/spi/spidev.c b/drivers/spi/spidev.c
index b97206d47ec6..9ec27d3d8b42 100644
--- a/drivers/spi/spidev.c
+++ b/drivers/spi/spidev.c
@@ -715,6 +715,7 @@ static const struct spi_device_id spidev_spi_ids[] = {
 	{ .name = "spi-authenta" },
 	{ .name = "em3581" },
 	{ .name = "si3210" },
+	{ .name = "spidev" },
 	{},
 };
 MODULE_DEVICE_TABLE(spi, spidev_spi_ids);
@@ -744,6 +745,7 @@ static const struct of_device_id spidev_dt_ids[] = {
 	{ .compatible = "semtech,sx1301", .data = &spidev_of_check },
 	{ .compatible = "silabs,em3581", .data = &spidev_of_check },
 	{ .compatible = "silabs,si3210", .data = &spidev_of_check },
+	{ .compatible = "linux,spidev", .data = &spidev_of_check },
 	{},
 };
 MODULE_DEVICE_TABLE(of, spidev_dt_ids);
diff --git a/sound/soc/codecs/tlv320aic3x.c b/sound/soc/codecs/tlv320aic3x.c
index 56e795a00e22..a0702102478e 100644
--- a/sound/soc/codecs/tlv320aic3x.c
+++ b/sound/soc/codecs/tlv320aic3x.c
@@ -28,6 +28,7 @@
  *  snd_soc_dapm_disable_pin(codec, "MONO_LOUT"), etc.
  */
 
+#include <linux/clk.h>
 #include <linux/module.h>
 #include <linux/moduleparam.h>
 #include <linux/init.h>
@@ -75,6 +76,7 @@ struct aic3x_priv {
 	struct aic3x_disable_nb disable_nb[AIC3X_NUM_SUPPLIES];
 	struct aic3x_setup_data *setup;
 	unsigned int sysclk;
+	struct clk *mclk_handle;
 	unsigned int dai_fmt;
 	unsigned int tdm_delay;
 	unsigned int slot_width;
@@ -996,11 +998,21 @@ static const struct snd_soc_dapm_route intercon_3007[] = {
 	{"SPOM", NULL, "Right Class-D Out"},
 };
 
+static const struct snd_soc_dapm_widget aic3x_dapm_mclk_widgets[] = {
+	SND_SOC_DAPM_CLOCK_SUPPLY("MCLK")
+};
+
 static int aic3x_add_widgets(struct snd_soc_component *component)
 {
 	struct aic3x_priv *aic3x = snd_soc_component_get_drvdata(component);
 	struct snd_soc_dapm_context *dapm = snd_soc_component_get_dapm(component);
 
+	if (aic3x->mclk_handle) {
+		snd_soc_dapm_new_controls(dapm, aic3x_dapm_mclk_widgets, 1);
+	} else {
+		dev_warn(component->dev, "DAPM MCLK widgets not set\n");
+	}
+
 	switch (aic3x->model) {
 	case AIC3X_MODEL_3X:
 	case AIC3X_MODEL_33:
@@ -1674,6 +1686,13 @@ static int aic3x_component_probe(struct snd_soc_component *component)
 	return 0;
 }
 
+static int aic3x_of_xlate_dai_id(struct snd_soc_component *component,
+				   struct device_node *endpoint)
+{
+	/* return dai id 0, whatever the endpoint index */
+	return 0;
+}
+
 static const struct snd_soc_component_driver soc_component_dev_aic3x = {
 	.set_bias_level		= aic3x_set_bias_level,
 	.probe			= aic3x_component_probe,
@@ -1683,6 +1702,7 @@ static const struct snd_soc_component_driver soc_component_dev_aic3x = {
 	.num_dapm_widgets	= ARRAY_SIZE(aic3x_dapm_widgets),
 	.dapm_routes		= intercon,
 	.num_dapm_routes	= ARRAY_SIZE(intercon),
+	.of_xlate_dai_id	= aic3x_of_xlate_dai_id,
 	.use_pmdown_time	= 1,
 	.endianness		= 1,
 };
@@ -1788,6 +1808,13 @@ int aic3x_probe(struct device *dev, struct regmap *regmap, kernel_ulong_t driver
 
 	aic3x->model = driver_data;
 
+	aic3x->mclk_handle = devm_clk_get(dev, "MCLK");
+	if (IS_ERR(aic3x->mclk_handle)) {
+		if (PTR_ERR(aic3x->mclk_handle) != -ENOENT)
+			return PTR_ERR(aic3x->mclk_handle);
+		aic3x->mclk_handle = NULL;
+	}
+
 	aic3x->gpio_reset = devm_gpiod_get_optional(dev, "reset",
 						    GPIOD_OUT_HIGH);
 	ret = PTR_ERR_OR_ZERO(aic3x->gpio_reset);
